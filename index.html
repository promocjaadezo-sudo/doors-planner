<!DOCTYPE html>
<!-- MOJE OZNAKOWANIE: To jest mój własny kod projektu "Planner Produkcji Drzwi" - wersja użytkownika KOMPUTER. Nie kopiuj z zewnętrznych źródeł. -->
<html lang="pl">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0, post-check=0, pre-check=0"/>
<meta http-equiv="Pragma" content="no-cache"/>
<meta http-equiv="Expires" content="0"/>
<meta name="last-modified" content="2025-10-05"/>
<title>Planner Produkcji Drzwi — v5.0 (2025-10-05 14:00)</title>
<style>
:root{--bg:#0f172a;--panel:#1f2937;--muted:#94a3b8;--b:#374151;--acc:#2563eb;--ok:#16a34a;--warn:#d97706;--err:#dc2626}
*{box-sizing:border-box}body{margin:0;font-family:system-ui,Arial,sans-serif;background:var(--bg);color:#e5e7eb}
header{position:sticky;top:0;z-index:60;background:rgba(15,23,42,.92);backdrop-filter:saturate(180%) blur(6px);border-bottom:1px solid #1e293b}
.wrap{max-width:1280px;margin:0 auto;padding:16px}
.row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
.card{background:var(--panel);border-radius:14px;padding:14px;box-shadow:0 6px 18px rgba(0,0,0,.35);margin:0 0 12px}
.btn{border:0;border-radius:10px;padding:8px 12px;background:#334155;color:#e5e7eb;cursor:pointer}
.btn.gray{background:#475569;color:#e5e7eb}
.btn.primary{background:var(--acc);color:#fff}.btn.red{background:var(--err)}.btn.green{background:var(--ok)}.btn.amber{background:var(--warn)}.btn.blue{background:#3b82f6}.btn.small{padding:4px 8px;font-size:12px}
.hidden{display:none!important}
input,select,textarea{background:#111827;color:#e5e7eb;border:1px solid var(--b);border-radius:10px;padding:8px 10px;width:100%}
label{font-size:12px;color:#94a3b8}.list{display:flex;flex-direction:column;gap:8px}.muted{color:#cbd5e1;font-size:12px}
#set-info{color:#ffffff !important;font-weight:600 !important;font-size:14px !important;background:#1a2332 !important;padding:4px 8px !important;border-radius:4px !important;border:1px solid #334155 !important;display:block !important;min-height:20px !important;}
.grid2{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:10px}
.grid3{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:10px}
.table{overflow:auto; max-height:55vh} table{width:100%;border-collapse:collapse}
th,td{border-bottom:1px solid #2b3a59;padding:8px;text-align:left} th{background:#111827;position:sticky;top:0}
.pill{display:inline-block;background:#0b1222;border:1px solid #2b3a59;border-radius:999px;padding:2px 8px;font-size:11px;color:#9fb3d1}
.oktxt{color:#86efac}.err{color:#fca5a5}

/* Validation error styles */
.validation-error { background: var(--err); color: white; border: 1px solid #b91c1c; animation: fadeIn 0.3s ease-in; }
.validation-error h4 { margin: 0 0 8px 0; color: #fecaca; }
.validation-error ul { margin: 0; padding-left: 20px; }
.validation-error li { margin-bottom: 4px; }
@keyframes fadeIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }

/* Search styles */
.search-results { position: absolute; top: 100%; left: 0; right: 0; background: var(--panel); border: 1px solid var(--b); border-radius: 8px; max-height: 400px; overflow-y: auto; z-index: 1000; box-shadow: 0 8px 25px rgba(0,0,0,.5); }
.search-result-item { padding: 12px; border-bottom: 1px solid var(--b); cursor: pointer; transition: background 0.2s; }
.search-result-item:hover { background: rgba(255,255,255,0.05); }
.search-result-item:last-child { border-bottom: none; }
.search-result-category { font-size: 11px; color: var(--acc); text-transform: uppercase; margin-bottom: 4px; }
.search-result-title { font-weight: 600; color: #e5e7eb; margin-bottom: 2px; }
.search-result-details { font-size: 12px; color: #94a3b8; }
.search-no-results { padding: 20px; text-align: center; color: #94a3b8; }

/* Gantt Chart styles */
.gantt-container { border: 1px solid var(--b); border-radius: 8px; overflow: hidden; max-height: 70vh; background: var(--panel); }
.gantt-header { display: flex; background: #1f2937; border-bottom: 1px solid var(--b); position: sticky; top: 0; z-index: 10; }
.gantt-resource-column { width: 200px; padding: 12px; font-weight: 600; color: #e5e7eb; border-right: 1px solid var(--b); background: #111827; }
.gantt-timeline { flex: 1; display: flex; position: relative; }
.gantt-time-slot { flex: 1; padding: 8px 4px; text-align: center; font-size: 11px; color: #94a3b8; border-right: 1px solid rgba(148, 163, 184, 0.2); min-width: 60px; }
.gantt-body { max-height: calc(70vh - 50px); overflow-y: auto; }
.gantt-row { display: flex; border-bottom: 1px solid rgba(148, 163, 184, 0.1); }
.gantt-row:hover { background: rgba(255,255,255,0.02); }
.gantt-resource-cell { width: 200px; padding: 12px; border-right: 1px solid var(--b); background: #111827; color: #e5e7eb; font-weight: 500; }
.gantt-task-cell { flex: 1; position: relative; min-height: 50px; }
.gantt-task { position: absolute; height: 30px; background: var(--acc); border-radius: 4px; cursor: pointer; display: flex; align-items: center; padding: 0 8px; font-size: 11px; color: white; box-shadow: 0 2px 4px rgba(0,0,0,0.2); border: 2px solid transparent; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; min-width: 80px; max-width: 200px; }
.gantt-task:hover { border-color: #60a5fa; transform: translateY(-1px); }
.gantt-task.todo { background: #f59e0b; }
.gantt-task.run { background: #3b82f6; }
.gantt-task.done { background: #10b981; }
.gantt-task.overdue { background: #ef4444; box-shadow: 0 0 8px rgba(239, 68, 68, 0.5); }
.gantt-current-time { position: absolute; top: 0; bottom: 0; width: 2px; background: #ef4444; z-index: 5; }
.gantt-current-time::after { content: ''; position: absolute; top: -4px; left: -4px; width: 10px; height: 10px; background: #ef4444; border-radius: 50%; }

/* Drag & Drop styles */
.gantt-task.dragging { opacity: 0.5; transform: rotate(5deg); z-index: 1000; }
.gantt-task.drag-over { border-color: #10b981; background: rgba(16, 185, 129, 0.2); }
.gantt-drop-zone { position: absolute; height: 30px; background: rgba(16, 185, 129, 0.1); border: 2px dashed #10b981; border-radius: 4px; pointer-events: none; z-index: 999; }
.gantt-drop-zone.valid { background: rgba(16, 185, 129, 0.2); border-color: #10b981; }
.gantt-drop-zone.invalid { background: rgba(239, 68, 68, 0.1); border-color: #ef4444; }

/* Dependencies visualization */
.gantt-dependency { position: absolute; pointer-events: none; z-index: 5; overflow: visible; }
.gantt-dependency-line { stroke: #94a3b8; stroke-width: 2; fill: none; stroke-linecap: round; stroke-linejoin: round; }
.gantt-dependency-arrow { fill: #94a3b8; stroke: #94a3b8; stroke-width: 1; }
.gantt-dependency.manual { stroke: #3b82f6; stroke-width: 3; }
.gantt-dependency-arrow.manual { fill: #3b82f6; stroke: #3b82f6; }

/* Dependency creation mode */
.gantt-task.dependency-from { border-color: #3b82f6 !important; box-shadow: 0 0 8px rgba(59, 130, 246, 0.6) !important; }
.gantt-task.dependency-target { border-color: #10b981 !important; box-shadow: 0 0 8px rgba(16, 185, 129, 0.6) !important; }

/* Critical path highlighting */
.gantt-task.critical-path { background: linear-gradient(45deg, #ef4444, #dc2626); border: 2px solid #b91c1c; box-shadow: 0 0 8px rgba(239, 68, 68, 0.6); }
.gantt-dependency.critical { stroke: #ef4444; stroke-width: 3; }
.gantt-dependency-arrow.critical { fill: #ef4444; stroke: #ef4444; }

/* Float indicators */
.gantt-float-indicator { position: absolute; top: -20px; right: 2px; font-size: 10px; color: #94a3b8; background: rgba(15, 23, 42, 0.8); padding: 2px 4px; border-radius: 2px; white-space: nowrap; }
.gantt-float-indicator.positive { color: #10b981; }
.gantt-float-indicator.zero { color: #ef4444; font-weight: bold; }
.gantt-float-indicator.negative { color: #f59e0b; }

/* Capacity Analysis Styles */
.capacity-item { display: flex; justify-content: space-between; align-items: center; padding: 12px; border: 1px solid var(--b); border-radius: 6px; margin-bottom: 8px; background: var(--panel); }
.capacity-employee { font-weight: 600; color: var(--text); }
.capacity-metrics { display: flex; flex-direction: column; gap: 4px; align-items: flex-end; }
.capacity-bar { position: relative; width: 120px; height: 20px; background: #e5e7eb; border-radius: 10px; overflow: hidden; display: flex; align-items: center; justify-content: center; }
.capacity-bar span { color: white; font-size: 11px; font-weight: 600; z-index: 1; }
.capacity-fill { position: absolute; left: 0; top: 0; height: 100%; transition: width 0.3s ease; }
.capacity-fill.low { background: #10b981; }
.capacity-fill.normal { background: #3b82f6; }
.capacity-fill.high { background: #f59e0b; }
.capacity-fill.overloaded { background: #ef4444; }

.bottleneck-item { padding: 12px; border: 1px solid #ef4444; border-radius: 6px; margin-bottom: 8px; background: rgba(239, 68, 68, 0.1); }
.bottleneck-name { font-weight: 600; color: #ef4444; margin-bottom: 4px; }
.bottleneck-metrics { font-size: 13px; color: var(--text-secondary); }

.efficiency-metric { display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid rgba(148, 163, 184, 0.1); }
.efficiency-metric:last-child { border-bottom: none; }
.metric-label { color: var(--text-secondary); }
.metric-value { font-weight: 600; color: var(--text); }

.empty { text-align: center; color: var(--text-secondary); padding: 20px; font-style: italic; }
</style>
</head>
<body>
<header class="wrap">
  <div class="row" style="gap:8px">
    <button class="btn" data-nav="dash">Strona główna</button>
    <button class="btn" data-nav="tasks">Listy</button>
    <button class="btn" data-nav="order">Zlecenia</button>
    <button class="btn" data-nav="proc">Procesy</button>
    <button class="btn" data-nav="opcat">Katalog operacji</button>
    <button class="btn" data-nav="emp">Pracownicy</button>
    <button class="btn" data-nav="as">Montaż/Reklamacje</button>
    <button class="btn" data-nav="gantt">Harmonogram</button>
    <button class="btn" data-nav="capacity">Analiza</button>
    <button class="btn" data-nav="reports">Raporty</button>
    <button class="btn" data-nav="map">Mapy</button>
    <button class="btn" data-nav="monitor">Monitoring</button>
    <button class="btn" data-nav="mrp">MRP</button>
    <button class="btn" data-nav="wh">Magazyn</button>
    <button class="btn" data-nav="backup">Backup</button>
    <button class="btn" data-nav="settings">Ustawienia</button>
  </div>
  <div class="row" style="gap:8px;margin-top:8px">
    <input type="text" id="global-search" placeholder="Szukaj zamówień, pracowników, zadań..." style="flex:1;max-width:400px">
    <button class="btn" id="search-btn">🔍 Szukaj</button>
    <div id="search-results" class="search-results" style="display:none"></div>
  </div>
</header>

<div class="wrap">
  <div class="row" style="justify-content:space-between"><h1>Planner Produkcji Drzwi — v5.0</h1></div>

  <div class="card" id="p-dash">
    <h3>Panel</h3>
    <div class="grid3">
      <div class="card"><div>Zlecenia</div><div id="dash-orders" class="pill">0</div></div>
      <div class="card"><div>Procesy</div><div id="dash-proc" class="pill">0</div></div>
      <div class="card"><div>Operacje</div><div id="dash-ops" class="pill">0</div></div>
    </div>
  </div>

  <div class="card hidden" id="p-tasks">
    <div class="row" style="justify-content:space-between">
      <h3>Listy produkcyjne</h3>
      <div class="row">
          <span class="pill" id="tasks-count">0</span>
          <select id="tasks-filter-order"></select>
          <select id="tasks-filter-status"><option value="">Wszystkie</option><option value="todo">todo</option><option value="run">run</option><option value="done">done</option></select>
          <button class="btn" id="tasks-gen-by-emp" title="Generuj listy zadań pogrupowane według pracownika">Generuj wg prac.</button>
          <button class="btn" id="tasks-export-csv-by-emp" title="Eksportuj listy pracowników do CSV">Eksport CSV</button>
          <button class="btn" id="tasks-show-by-emp" title="Pokaż/ukryj podział na pracowników">Pokaż podział</button>
        </div>
    </div>
    <div id="tasks-list" class="list"></div>
    <div id="tasks-by-worker" class="list" style="margin-top:12px"></div>
  </div>

  <div class="card hidden" id="p-order">
    <div class="row" style="justify-content:space-between"><h3>Zlecenia</h3></div>
    <form class="grid3" id="order-form">
      <input type="hidden" id="o-id">
      <div><label>Nr zlecenia</label><input id="o-name" required></div>
      <div><label>Klient</label><input id="o-client"></div>
      <div><label>Model</label><input id="o-model" placeholder="np. HYGGE-80"></div>
      <div><label>Ilość sztuk</label><input id="o-qty" type="number" min="1" value="1"></div>
      <div><label>Data przyjęcia</label><input id="o-start" type="date"></div>
      <div>
        <label>Ilość tygodni</label>
        <select id="o-weeks">
          <option value="1">1 tydzień</option>
          <option value="2" selected>2 tygodnie</option>
          <option value="3">3 tygodnie</option>
          <option value="4">4 tygodnie</option>
          <option value="5">5 tygodni</option>
          <option value="6">6 tygodni</option>
          <option value="7">7 tygodni</option>
          <option value="8">8 tygodni</option>
          <option value="9">9 tygodni</option>
          <option value="10">10 tygodni</option>
        </select>
      </div>
      <div><label>Termin (auto)</label><input id="o-end" type="date"></div>
      <div><label>Proces</label><select id="o-proc"></select></div>
      <div><label>Uwagi</label><textarea id="o-notes" rows="2"></textarea></div>
    <div><label>Termin montażu</label><input id="o-install" type="date"></div>
  <div><label>Adres montażu</label><input id="o-addr" placeholder="ulica nr, miejscowość"></div>
  <div><label>Kod montażu</label><input id="o-post" placeholder="kod miejsca / 00-000" ></div>
  <div><label>Telefon</label><input id="o-phone" placeholder="+48 600 000 000" pattern="\+?[0-9\s]{6,}" title="Minimum 6 cyfr, opcjonalny '+' na początku"></div>
      <div style="grid-column:1/-1;text-align:right"><button class="btn primary" type="submit">Zapisz</button></div>
    </form>
    <div class="table" style="margin-top:8px">
      <table>
        <thead>
          <tr>
            <th>Nr zlecenia</th>
            <th>Klient</th>
            <th>Model</th>
            <th>Ilość</th>
            <th>Data przyjęcia</th>
            <th>Termin</th>
            <th>Montaż</th>
            <th>Kod montażu</th>
            <th>Akcje</th>
          </tr>
        </thead>
        <tbody id="ord-tb"></tbody>
      </table>
    </div>
  </div>

  <div class="card hidden" id="p-opcat">
    <div class="row" style="justify-content:space-between">
      <h3>Katalog operacji</h3><span class="pill" id="op-count">0</span>
      <div class="row">
          <button class="btn" id="op-normalize">Porządkuj</button>
          <button class="btn" id="op-sort-az">Sortuj A→Z</button>
          <select id="op-comp-select" style="min-width:160px;margin-left:8px"><option value="">— wybierz komponent —</option></select>
          <button class="btn" id="op-sort-comp" style="margin-left:6px">Sortuj po komponencie</button>
          <button class="btn green" id="op-save-db" style="margin-left:6px">Zapisz do DB</button>
        </div>
    </div>
    <form class="grid3" id="op-form">
      <input type="hidden" id="op-id">
      <div><label>Nr (kolejność)</label><input id="op-no" type="number" min="1" value="1"></div>
      <div><label>Nazwa</label><input id="op-name" required></div>
      <div><label>Czas [min] (≥1)</label><input id="op-time" type="number" min="1" value="10"></div>
      <div><label>Domyślna liczba prac. (≥1)</label><input id="op-workers" type="number" min="1" value="1"></div>
      <div style="grid-column:1/-1"><label>Komponenty (;)</label>
        <input id="op-skills" placeholder="np. piła; wkręty; listwa">
      </div>
      <div style="grid-column:1/-1"><label>Domyślni pracownicy (multi)</label>
        <select id="op-emp" multiple size="5" style="height:140px"></select>
      </div>
      <div style="grid-column:1/-1;text-align:right">
        <button class="btn primary" type="submit">Dodaj / Zapisz</button>
      </div>
      <div class="muted" id="op-msg"></div>
    </form>
    <div class="table" style="margin-top:8px">
      <table>
        <thead>
          <tr><th>Nr</th><th>Nazwa</th><th>min</th><th>prac.</th><th>komponenty</th><th>domyślni prac.</th><th>Akcje</th></tr>
        </thead>
        <tbody id="op-tb"></tbody>
      </table>
    </div>
  </div>

  <div class="card hidden" id="p-proc">
    <div class="row" style="justify-content:space-between"><h3>Procesy</h3><span class="pill" id="proc-count">0</span></div>
    <form class="grid3" id="proc-form">
      <input type="hidden" id="proc-id">
      <div><label>Nazwa procesu</label><input id="proc-name" required></div>
      <div><label>Dodaj z katalogu</label><select id="proc-op-select"></select></div>
      <div style="grid-column:1/-1" class="row">
        <button class="btn" id="proc-add-op" type="button">➕ Dodaj operację</button>
        <button class="btn primary" type="submit">Zapisz proces</button>
      </div>
    </form>
    <div><b>Operacje w procesie</b></div>
    <div class="list" id="proc-ops"></div>
    <div class="list" id="proc-list"></div>
  </div>

  <div class="card hidden" id="p-emp">
    <div class="row" style="justify-content:space-between"><h3>Pracownicy</h3><button class="btn" id="emp-add">Dodaj</button></div>
    <div class="table"><table><thead><tr><th>Imię i nazwisko</th><th>cap%</th><th>h/d</th><th>Akcje</th></tr></thead><tbody id="emp-tb"></tbody></table></div>
  </div>

  <div class="card hidden" id="p-as">
    <div class="row" style="justify-content:space-between">
      <h3>Montaż / Reklamacje</h3>
      <button class="btn" data-refresh-as>Odśwież z bazy</button>
    </div>
    <form class="grid3" id="as-form">
      <input type="hidden" id="as-id">
      <div><label>Typ</label><select id="as-type"><option>montaż</option><option>reklamacja</option></select></div>
      <div><label>Zlecenie</label><select id="as-order"></select></div>
      <div style="display:none">
        <input id="as-order-phone" placeholder="phone">
        <input id="as-order-placecode" placeholder="placecode">
      </div>
      <div><label>Status</label><select id="as-status"><option>nowe</option><option>w toku</option><option>zamknięte</option></select></div>
      <div><label>Termin montażu</label><input id="as-install" type="date"></div>
      <div><label>Godzina wyjazdu</label><input id="as-go" type="time"></div>
      <div><label>Godzina wizyty</labe><input id="as-visit" type="time"></div>
      <div style="grid-column:1/-1"><label>Opis</label><textarea id="as-desc" rows="2"></textarea></div>
      <div style="grid-column:1/-1;text-align:right"><button class="btn primary" type="submit">Zapisz</button></div>
    </form>
    <div class="list" id="as-list"></div>
  </div>

  <div class="card hidden" id="p-map"><h3>Mapy Model↔Proces</h3><div class="muted">Placeholder.</div></div>
  <div class="card hidden" id="p-monitor"><h3>Monitoring postępów</h3><div class="muted">Placeholder.</div></div>
  <div class="card hidden" id="p-mrp">
    <div class="row" style="justify-content:space-between">
      <h3>Zakupy (MRP)</h3>
      <button class="btn green" id="mrp-generate">Generuj listę zakupów</button>
    </div>
    <div class="list" id="mrp-list"></div>
  </div>
  <div class="card hidden" id="p-wh">
    <div class="row" style="justify-content:space-between;margin-bottom:16px">
      <h3>📦 Magazyn</h3>
      <div class="row" style="gap:8px">
        <button class="btn green" id="btn-add-warehouse">➕ Dodaj pozycję</button>
        <button class="btn" id="btn-refresh-warehouse">🔄 Odśwież</button>
        <button class="btn blue" id="btn-export-warehouse">📊 Eksport</button>
      </div>
    </div>

    <!-- Filtry i wyszukiwanie -->
    <div class="row" style="gap:16px;margin-bottom:16px;flex-wrap:wrap">
      <input type="text" id="wh-search" placeholder="🔍 Szukaj pozycji..." style="flex:1;min-width:200px">
      <select id="wh-category-filter" style="min-width:150px">
        <option value="">Wszystkie kategorie</option>
        <option value="materialy">Materiały</option>
        <option value="okucia">Okucia</option>
        <option value="farby">Farby i lakiery</option>
        <option value="narzedzia">Narzędzia</option>
        <option value="inne">Inne</option>
      </select>
      <select id="wh-status-filter" style="min-width:120px">
        <option value="">Wszystkie stany</option>
        <option value="dostepny">Dostępny</option>
        <option value="niski">Niski stan</option>
        <option value="brak">Brak</option>
      </select>
    </div>

    <!-- Statystyki -->
    <div class="row" style="gap:16px;margin-bottom:16px">
      <div class="card" style="flex:1;padding:12px;background:#f8f9fa">
        <div style="font-size:24px;font-weight:bold;color:#28a745" id="wh-stat-total">0</div>
        <div style="color:#666;font-size:12px">Łączna liczba pozycji</div>
      </div>
      <div class="card" style="flex:1;padding:12px;background:#f8f9fa">
        <div style="font-size:24px;font-weight:bold;color:#ffc107" id="wh-stat-low">0</div>
        <div style="color:#666;font-size:12px">Niski stan</div>
      </div>
      <div class="card" style="flex:1;padding:12px;background:#f8f9fa">
        <div style="font-size:24px;font-weight:bold;color:#dc3545" id="wh-stat-empty">0</div>
        <div style="color:#666;font-size:12px">Brak na stanie</div>
      </div>
      <div class="card" style="flex:1;padding:12px;background:#f8f9fa">
        <div style="font-size:24px;font-weight:bold;color:#17a2b8" id="wh-stat-value">0 zł</div>
        <div style="color:#666;font-size:12px">Wartość magazynu</div>
      </div>
    </div>

    <!-- Lista pozycji magazynowych -->
    <div class="list" id="wh-list">
      <div style="text-align:center;padding:40px;color:#999">
        Brak pozycji w magazynie. Kliknij "Dodaj pozycję" aby rozpocząć.
      </div>
    </div>
  </div>
  
  <script>
  // Szybki test inicjalizacji magazynu
  console.log('Quick warehouse test - checking if simpleWarehouse is available');
  if (window.simpleWarehouse) {
    console.log('Simple warehouse initialization successful');
  } else {
    console.log('Simple warehouse not yet available');
  }
  </script>
  
  <div class="card hidden" id="p-backup">
    <div class="row" style="justify-content:space-between;margin-bottom:16px">
      <h3>💾 Backup i Odzyskiwanie</h3>
      <div class="row" style="gap:8px">
        <button class="btn green" id="backup-create">📦 Utwórz backup</button>
        <button class="btn" id="backup-refresh">🔄 Odśwież listę</button>
        <button class="btn" id="backup-cleanup">🧹 Wyczyść stare</button>
      </div>
    </div>

    <!-- Statystyki backupów -->
    <div class="card" style="margin-bottom:16px">
      <h4>📊 Statystyki backupów</h4>
      <div class="grid3" id="backup-stats">
        <div class="card" style="text-align:center">
          <div style="font-size:24px;font-weight:bold;color:var(--acc)" id="backup-count">0</div>
          <div style="color:var(--text-secondary)">Liczba backupów</div>
        </div>
        <div class="card" style="text-align:center">
          <div style="font-size:24px;font-weight:bold;color:var(--ok)" id="backup-latest">-</div>
          <div style="color:var(--text-secondary)">Najnowszy backup</div>
        </div>
        <div class="card" style="text-align:center">
          <div style="font-size:24px;font-weight:bold;color:var(--warn)" id="backup-size">0 MB</div>
          <div style="color:var(--text-secondary)">Całkowity rozmiar</div>
        </div>
      </div>
    </div>

    <!-- Lista backupów -->
    <div class="card" style="margin-bottom:16px">
      <h4>📁 Dostępne backupy</h4>
      <div id="backup-list" class="list" style="max-height:300px;overflow-y:auto">
        <div class="muted">Brak dostępnych backupów. Utwórz pierwszy backup.</div>
      </div>
    </div>

    <!-- Opcje backupu -->
    <div class="card">
      <h4>⚙️ Opcje backupu</h4>
      <div class="grid2" style="margin-top:12px">
        <div>
          <label><input type="checkbox" id="backup-include-settings" checked> Dołącz ustawienia aplikacji</label>
        </div>
        <div>
          <label><input type="checkbox" id="backup-include-logs" checked> Dołącz historię operacji</label>
        </div>
        <div>
          <label><input type="checkbox" id="backup-compress" checked> Kompresuj backup (ZIP)</label>
        </div>
        <div>
          <label><input type="checkbox" id="backup-auto-cleanup"> Automatyczne czyszczenie starych backupów</label>
        </div>
      </div>

      <div style="margin-top:16px">
        <label>Maksymalna liczba backupów do przechowywania:</label>
        <select id="backup-max-count" style="margin-left:8px;padding:4px">
          <option value="5">5</option>
          <option value="10" selected>10</option>
          <option value="20">20</option>
          <option value="50">50</option>
          <option value="unlimited">Bez limitu</option>
        </select>
      </div>

      <div style="margin-top:16px;text-align:right">
        <button class="btn" id="backup-settings-save">💾 Zapisz ustawienia</button>
      </div>
    </div>

    <!-- Informacje o bezpieczeństwie -->
    <div class="card" style="margin-top:16px;background:#1a2332;border:1px solid #334155">
      <h4>🔒 Bezpieczeństwo danych</h4>
      <ul style="margin:8px 0;padding-left:20px">
        <li>Backupy są przechowywane lokalnie w przeglądarce</li>
        <li>Dane są kompresowane i zabezpieczone</li>
        <li>Można eksportować backupy jako pliki do zewnętrznego przechowywania</li>
        <li>Zaleca się regularne tworzenie backupów przed ważnymi zmianami</li>
      </ul>
    </div>
  </div>

  <div class="card hidden" id="p-gantt">
    <div class="row" style="justify-content:space-between">
      <h3>Harmonogram Produkcji (Gantt)</h3>
      <div class="row">
        <select id="gantt-view">
          <option value="week">Widok tygodniowy</option>
          <option value="month">Widok miesięczny</option>
        </select>
  <button class="btn" id="gantt-refresh">Odśwież</button>
  <button class="btn amber" id="gantt-replan-all" title="Resetuj i przelicz wszystkie zadania z uwzględnieniem aktualnej konfiguracji">Przelicz harmonogram</button>
        <button class="btn" id="gantt-auto-assign">Auto-przypisz</button>
        <button class="btn" id="gantt-generate-test">Generuj dane testowe</button>
        <button class="btn" id="gantt-export">Eksport PNG</button>
        <button class="btn" id="gantt-show-dependencies" title="Pokaż/ukryj zależności między zadaniami">📊 Zależności</button>
        <button class="btn" id="gantt-create-dependency" title="Utwórz zależność między zadaniami">🔗 Utwórz zależność</button>
        <button class="btn" id="gantt-manage-dependencies" title="Zarządzaj zależnościami">📋 Zarządzaj</button>
        <button class="btn" id="gantt-show-critical-path" title="Pokaż/ukryj ścieżkę krytyczną">🎯 Ścieżka krytyczna</button>
      </div>
    </div>
    <div id="gantt-container" class="gantt-container">
      <div class="gantt-header">
        <div class="gantt-resource-column">Zasób</div>
        <div class="gantt-timeline" id="gantt-timeline"></div>
      </div>
      <div class="gantt-body" id="gantt-body">
        <!-- Dependencies visualization layer -->
        <svg id="gantt-dependencies" class="gantt-dependency" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1;"></svg>
      </div>
    </div>
  </div>

  <div class="card hidden" id="p-capacity">
    <div class="row" style="justify-content:space-between">
      <h3>Analiza Przepustowości Produkcji</h3>
      <div class="row">
        <select id="capacity-period">
          <option value="day">Dzień</option>
          <option value="week" selected>Tydzień</option>
          <option value="month">Miesiąc</option>
        </select>
        <button class="btn" id="capacity-refresh">Odśwież</button>
        <button class="btn" id="capacity-optimize">🔄 Optymalizuj obciążenie</button>
        <button class="btn" id="capacity-export">Eksport CSV</button>
      </div>
    </div>

    <div class="grid2" style="margin-top: 16px;">
      <div class="card">
        <h4>Wykorzystanie Zasobów</h4>
        <div id="capacity-resources" class="list"></div>
      </div>

      <div class="card">
        <h4>Wąskie Gardła</h4>
        <div id="capacity-bottlenecks" class="list"></div>
      </div>
    </div>

    <div class="card" style="margin-top: 16px;">
      <h4>Efektywność Produkcji</h4>
      <div id="capacity-efficiency" class="list"></div>
    </div>

    <div class="card" style="margin-top: 16px;">
      <h4>💡 Sugestie optymalizacji obciążenia</h4>
      <div id="capacity-optimization" class="list"></div>
    </div>
  </div>

  <div class="card hidden" id="p-settings">
    <div class="row" style="justify-content:space-between"><h3>Ustawienia</h3></div>
    
    <div id="high-contrast-toggle-wrapper">
      <label><input type="checkbox" id="toggle-high-contrast"> Wysoki kontrast ostrzeżeń</label>
    </div>
    
    <div class="grid3">
      <div><label>Tryb</label><select id="set-mode"><option value="local">localStorage</option><option value="firebase" selected>Firebase</option></select></div>
	<div><label>Początek dnia (h)</label><input id="sched-start" type="number" min="0" max="23" value="8"></div>
	<div><label>Długość dnia (h)</label><input id="sched-len" type="number" min="1" max="16" value="8"></div>
      <div><label>App ID</label><input id="set-appid" value="doors-demo"></div>
      <div><label>User ID</label><input id="set-userid" value="hala-1"></div>
      <div style="grid-column:1/4;margin-top:8px">
        <fieldset style="border:1px solid #334155;padding:8px;border-radius:4px">
          <legend style="padding:0 6px;font-size:13px">Dni wolne tygodnia</legend>
          <div style="display:flex;flex-wrap:wrap;gap:8px;font-size:13px">
            <label><input type="checkbox" class="sched-offday" value="1"> Poniedziałek (1)</label>
            <label><input type="checkbox" class="sched-offday" value="2"> Wtorek (2)</label>
            <label><input type="checkbox" class="sched-offday" value="3"> Środa (3)</label>
            <label><input type="checkbox" class="sched-offday" value="4"> Czwartek (4)</label>
            <label><input type="checkbox" class="sched-offday" value="5"> Piątek (5)</label>
            <label><input type="checkbox" class="sched-offday" value="6"> Sobota (6)</label>
            <label><input type="checkbox" class="sched-offday" value="0"> Niedziela (0)</label>
          </div>
          <div style="margin-top:6px;display:flex;align-items:center;gap:8px;flex-wrap:wrap">
            <button type="button" class="btn tiny" id="btn-offdays-weekend">Weekend</button>
            <button type="button" class="btn tiny" id="btn-offdays-workweek">Tylko weekend</button>
            <button type="button" class="btn tiny" id="btn-offdays-clear">Wyczyść</button>
            <span style="font-size:11px;color:#94a3b8">Zaznaczone dni są POMIJANE w planowaniu (Date.getDay(): Niedziela=0 ... Sobota=6)</span>
          </div>
        </fieldset>
      </div>
      <div style="grid-column:1/4;margin-top:8px">
        <label style="display:block;font-size:13px;margin-bottom:4px">Święta / dodatkowe dni wolne (YYYY-MM-DD, po przecinku)</label>
        <textarea id="sched-holidays" rows="2" placeholder="2025-11-01,2025-12-25" style="width:100%;resize:vertical"></textarea>
      </div>
    </div>
  <div class="list" style="margin-top:8px">
      <label>Firebase config (JSON)</label>
      <textarea id="set-fb" rows="8">{
  "apiKey": "AIzaSyD93UqqsHWoAUBV7g8OVKAnajIfGDX_ZdY",
  "authDomain": "doors-planner.firebaseapp.com",
  "projectId": "doors-planner",
  "storageBucket": "doors-planner.appspot.com",
  "messagingSenderId": "513098608067",
  "appId": "1:513098608067:web:1fe3855b3470ca7ef22176"
}</textarea>
      <div class="row">
        <button class="btn primary" id="set-test">Test &amp; Connect</button>
        <button class="btn green"   id="set-save">Zapisz do DB</button>
        <button class="btn"         id="set-load">Wczytaj z DB</button>
      </div>
      <div class="row" style="margin-top:8px">
  <label style="font-size:13px"><input type="checkbox" id="set-autosave-assign" checked> Auto-save do Firebase przy ważnych zmianach (np. przypisania)</label>
      </div>
    <div class="row" style="margin-top:8px">
  <label style="font-size:13px"><input type="checkbox" id="set-autoload-db"> Automatycznie wczytaj z Firebase przy starcie (jeśli tryb = Firebase)</label>
    </div>
      <div class="row" style="margin-top:8px">
        <label style="font-size:13px">Threshold wąskich gardeł: <input id="set-monitor-threshold" type="number" min="1" value="5" style="width:80px;margin-left:8px"></label>
      </div>
      <div class="row" style="margin-top:8px">
        <label style="font-size:13px"><input type="checkbox" id="set-monitor-alerts" checked> Włącz alerty monitoringu (baner gdy threshold przekroczony)</label>
      </div>
    <div class="row" style="margin-top:8px">
      <label style="font-size:13px"><input type="checkbox" id="set-auto-cleanup"> Automatyczne czyszczenie zleceń (usuń zadania po zamknięciu wszystkich)</label>
    </div>
    <div class="row" style="margin-top:8px">
  <label style="font-size:13px"><input type="checkbox" id="set-spellcheck-enforce"> Wymuszaj sprawdzanie pisowni (PL) dla wszystkich pól</label>
    </div>
      <div class="row" style="margin-top:8px;gap:8px">
        <button class="btn" id="export-tasks">Eksport zadań (.json)</button>
        <input type="file" id="import-tasks-file" accept=".json" style="display:none">
        <button class="btn" id="import-tasks">Import zadań</button>
        <button class="btn red" id="restore-authentic-data" title="Przywróć autentyczne dane z backupu">🔄 Przywróć dane</button>
        <button class="btn blue" id="restore-click-delegation" title="Przywróć normalną obsługę kliknięć">🔧 Napraw kliknięcia</button>
      </div>
      <div class="row" style="margin-top:8px;gap:8px">
        <button class="btn green" id="gen-test-data">Zaktualizuj dane testowe</button>
        <button class="btn" id="export-data">Eksportuj dane</button>
        <button class="btn" id="import-data">Importuj dane</button>
        <button class="btn red" id="clear-data">Wyczyść dane</button>
      </div>
      <div id="set-info" style="color:#ffffff !important;font-weight:600;font-size:14px;background:#1a2332;padding:4px 8px;border-radius:4px;border:1px solid #334155;"></div>
    </div>
  </div>
</div>

<!-- Raporty produkcyjne -->
<div class="card hidden" id="p-reports">
  <div class="row" style="justify-content:space-between;margin-bottom:16px">
    <h3>Raporty produkcyjne</h3>
    <div class="row" style="gap:8px">
      <select id="report-period" style="padding:6px 8px;border-radius:6px;border:1px solid var(--b)">
        <option value="week">Tydzień</option>
        <option value="month">Miesiąc</option>
        <option value="quarter">Kwartał</option>
        <option value="year">Rok</option>
      </select>
      <button class="btn" id="report-generate-test">Generuj dane testowe</button>
      <button class="btn" id="report-generate">📊 Generuj raport</button>
      <button class="btn" id="report-export">📄 Eksport PDF</button>
    </div>
  </div>

  <div id="reports-content">
    <!-- Progress bar -->
    <div id="reports-progress" class="card hidden" style="margin-bottom:16px">
      <div style="display:flex;align-items:center;gap:12px;margin-bottom:8px">
        <span id="reports-progress-text">Generowanie raportu...</span>
        <span id="reports-progress-percent">0%</span>
      </div>
      <div style="width:100%;height:8px;background:#e5e7eb;border-radius:4px;overflow:hidden">
        <div id="reports-progress-bar" style="width:0%;height:100%;background:linear-gradient(90deg,#3b82f6,#1d4ed8);transition:width 0.3s ease"></div>
      </div>
    </div>

    <!-- Statystyki ogólne -->
    <div class="card" style="margin-bottom:16px">
      <h4>📈 Statystyki produkcji</h4>
      <div class="grid3" id="report-stats">
        <div class="card" style="text-align:center">
          <div style="font-size:24px;font-weight:bold;color:var(--acc)" id="stat-total-orders">0</div>
          <div style="color:var(--text-secondary)">Zleceń</div>
        </div>
        <div class="card" style="text-align:center">
          <div style="font-size:24px;font-weight:bold;color:var(--ok)" id="stat-completed-tasks">0</div>
          <div style="color:var(--text-secondary)">Ukończonych zadań</div>
        </div>
        <div class="card" style="text-align:center">
          <div style="font-size:24px;font-weight:bold;color:var(--warn)" id="stat-efficiency">0%</div>
          <div style="color:var(--text-secondary)">Efektywność</div>
        </div>
      </div>
    </div>

    <!-- Wykresy wydajności -->
    <div class="card" style="margin-bottom:16px">
      <h4>📊 Wydajność pracowników</h4>
      <div id="report-employee-performance" style="height:300px">
        <div class="empty">Wybierz okres i kliknij "Generuj raport"</div>
      </div>
    </div>

    <!-- Raport kosztów -->
    <div class="card" style="margin-bottom:16px">
      <h4>💰 Koszty produkcji</h4>
      <div id="report-costs">
        <div class="empty">Wybierz okres i kliknij "Generuj raport"</div>
      </div>
    </div>

    <!-- Szczegółowe statystyki -->
    <div class="card">
      <h4>📋 Szczegółowe statystyki</h4>
      <div id="report-details" class="table">
        <div class="empty">Wybierz okres i kliknij "Generuj raport"</div>
      </div>
    </div>
  </div>
</div>

<div id="client-window" class="hidden">
  <!-- Szczegóły klienta będą renderowane dynamicznie -->
</div>

<!-- Wczytanie podstawowych utili oraz UI zanim główny skrypt inline uruchomi diagnostykę -->
<script src="js/base-utils.js?v=20251005-1400"></script>
<script src="js/store.js?v=20251005-1400"></script>
<script src="js/main.js?v=20251005-1400"></script>
<script src="js/ui.js?v=20251005-1415"></script>
<script src="js/schedule.js?v=20251005-1500"></script>
<script src="js/app-helpers.js?v=20251005-1400"></script>
<script>
// === MAGAZYN - NAJWYŻSZY PRIORYTET ===
// System magazynowy zostanie zainicjalizowany później w kodzie
console.log('Magazyn: Inicjalizacja systemu zarządzania magazynem...');

// Automatyczne renderowanie magazynu - zostanie wykonane później
setTimeout(() => {
  if (window.simpleWarehouse) {
    console.log('Magazyn: Automatyczne renderowanie listy pozycji');
    window.simpleWarehouse.render();
  }
}, 1000);

(function(){
  // create on-page developer log panel with visible toggle so user can read logs without DevTools
  try{
    const initDevLog = ()=>{
      const devLogEl = document.createElement('div');
      devLogEl.id = 'dev-log';
      Object.assign(devLogEl.style, {
        position: 'fixed', right: '12px', bottom: '48px', maxWidth: '420px', maxHeight: '40vh', overflow: 'auto',
        background: 'rgba(8,8,12,0.95)', color: '#cbd5e1', padding: '8px', borderRadius: '8px', fontSize: '12px', zIndex: '99999', boxShadow: '0 6px 18px rgba(0,0,0,.5)', border: '1px solid rgba(255,255,255,0.04)'
      });
      devLogEl.innerHTML = '<b style="display:block;margin-bottom:6px">Dev log</b>';

      const toggle = document.createElement('button');
      toggle.type = 'button'; toggle.id = 'dev-log-toggle'; toggle.textContent = 'DevLog';
      Object.assign(toggle.style, { position:'fixed', right:'12px', bottom:'12px', zIndex:'100000', padding:'8px 10px', borderRadius:'8px', border:'1px solid rgba(0,0,0,0.2)', background:'#f59e0b', color:'#071019', fontWeight:'700', cursor:'pointer', boxShadow:'0 6px 18px rgba(245,158,11,0.12)' });
      toggle.addEventListener('click', ()=>{
        if(document.body.contains(devLogEl)){ document.body.removeChild(devLogEl); toggle.textContent='DevLog'; } else { document.body.appendChild(devLogEl); toggle.textContent='Hide'; }
      });

      // ensure we don't append duplicates
      if(!document.getElementById('dev-log-toggle')) document.body.appendChild(toggle);
      if(!document.getElementById('dev-log')) document.body.appendChild(devLogEl);

      window.logDev = function(){
        try{
          // Respect runtime flag: state.storage.devLogEnabled === false disables dev logging
          const enabled = !(window.state && window.state.storage && window.state.storage.devLogEnabled === false);
          if(!enabled) return;
          const args = Array.from(arguments).map(a=> (typeof a==='object'?JSON.stringify(a):String(a)) );
          const line = document.createElement('div');
          line.textContent = args.join(' ');
          devLogEl.appendChild(line);
          devLogEl.scrollTop = devLogEl.scrollHeight;
          console.log.apply(console, arguments);
        }catch(_){ try{ console.log.apply(console, arguments); }catch(__){} }
      };
      // alias for simpler calls
      window.plog = window.logDev;
    };
    if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', initDevLog); else initDevLog();
  }catch(_){/* ignore */}

  const qs=s=>document.querySelector(s), qsa=s=>Array.from(document.querySelectorAll(s));

  // Emergency focus unlock function - make it available immediately
  window.unlockFocus = function(){
    console.log('Attempting to unlock focus...');
    
    // Hide any visible modals
    ['app-confirm-modal', 'app-preview-modal', '__scroll_debug_overlay'].forEach(id => {
      const el = document.getElementById(id);
      if (el) {
        el.style.display = 'none';
        console.log('Hidden modal:', id);
      }
    });
    
    // Remove any focus locks
    document.body.style.pointerEvents = '';
    document.body.style.userSelect = '';
    
    // Try to focus on a safe element
    try {
      const safeElement = document.querySelector('input, button, [tabindex]');
      if (safeElement) {
        safeElement.focus();
        console.log('Focused on safe element');
      }
    } catch (e) {
      console.warn('Could not focus on safe element:', e);
    }
    
    console.log('Focus unlock attempt completed');
  };

  // Emergency click diagnostics & recovery
  window.diagnoseClicks = function(){
    try{
      const report = [];
      // 1. Sprawdź globalne style blokujące interakcje
      const bodyPE = getComputedStyle(document.body).pointerEvents;
      const bodyUS = getComputedStyle(document.body).userSelect;
      if(bodyPE === 'none') report.push('[!] body ma pointer-events:none');
      if(bodyUS === 'none') report.push('[!] body ma user-select:none');

      // 2. Poszukaj dużych, potencjalnie zasłaniających elementów z pointer-events:auto
      const vw = window.innerWidth, vh = window.innerHeight;
      const blockers = [];
      document.querySelectorAll('body *').forEach(el=>{
        try{
          const st = getComputedStyle(el);
            if(st.display==='none' || st.visibility==='hidden' || st.opacity==='0') return;
            if(st.pointerEvents==='none') return;
            const r = el.getBoundingClientRect();
            if(r.width > vw*0.8 && r.height > vh*0.8 && r.top <= 0 && r.left <= 0){
              blockers.push({tag:el.tagName, cls:el.className, id:el.id, w:Math.round(r.width), h:Math.round(r.height), z:st.zIndex});
            }
        }catch(_){/* ignore */}
      });
      if(blockers.length) report.push('[!] Możliwe elementy zasłaniające: '+ blockers.map(b=>`${b.tag}#${b.id}.${b.cls} ${b.w}x${b.h} z=${b.z}`).join('; '));

      // 3. Test elementFromPoint
      const midEl = document.elementFromPoint(vw/2, vh/2);
      if(midEl) report.push('[i] elementFromPoint(środek): '+ midEl.tagName + (midEl.id?('#'+midEl.id):''));

      // 4. Szybki test czy listener działa (syntetyczny click)
      let syntheticOk = false;
      const testBtn = document.createElement('button');
      testBtn.textContent='__test_click__';
      testBtn.style.position='fixed'; testBtn.style.top='4px'; testBtn.style.left='4px'; testBtn.style.zIndex=999999; testBtn.style.opacity='0.4';
      testBtn.addEventListener('click', ()=>{ syntheticOk = true; console.log('[diagnoseClicks] Syntetyczny click dotarł do listenera.'); setTimeout(()=>testBtn.remove(), 50); });
      document.body.appendChild(testBtn);
      testBtn.click();
      setTimeout(()=>{ if(!syntheticOk){ console.warn('[diagnoseClicks] Wygląda jakby eventy click nie były obsługiwane (brak reakcji listenera).'); } }, 100);

      if(!report.length) report.push('[OK] Nie znaleziono oczywistych blokad.');
      console.log('[diagnoseClicks] Raport:', report.join('\n'));
      return report;
    }catch(e){ console.error('[diagnoseClicks] Błąd', e); return ['error:'+e.message]; }
  };

  window.recoverClicks = function(){
    try{
      console.log('[recoverClicks] Próba odblokowania zdarzeń...');
      // NAJWAŻNIEJSZE: Przywróć normalną delegację kliknięć
      window.restoreNormalClickDelegation();
      document.body.style.pointerEvents='auto';
      document.body.style.userSelect='auto';
      // Usuń ewentualne pełnoekranowe warstwy debug / modal z atrybutem data-block-ui
      document.querySelectorAll('[data-block-ui]')?.forEach(el=>{ el.remove(); });
      // Schowaj potencjalne modale
      ['app-confirm-modal','app-preview-modal','__scroll_debug_overlay'].forEach(id=>{ const el = document.getElementById(id); if(el){ el.style.display='none'; } });
      // Wyczyść style inline blokujące pointer events dla .hidden (czasem nadpisane przez błędny CSS)
      document.querySelectorAll('.hidden').forEach(el=>{ el.style.pointerEvents='none'; });
      // Dodaj delikatny znacznik powodzenia
      const tag = document.createElement('div');
      tag.textContent='[clicks recovered]';
      Object.assign(tag.style,{position:'fixed',bottom:'4px',right:'6px',background:'#059669',color:'#fff',padding:'4px 8px',borderRadius:'6px',fontSize:'11px',zIndex:999999});
      document.body.appendChild(tag); setTimeout(()=>tag.remove(), 2500);
      console.log('[recoverClicks] Zakończono');
    }catch(e){ console.error('[recoverClicks] Błąd', e); }
  };

  // Skrót klawiszowy: Ctrl+Alt+K -> diagnoza, Ctrl+Alt+R -> próba naprawy
  window.addEventListener('keydown', (ev)=>{
    if(ev.ctrlKey && ev.altKey && ev.key.toLowerCase()==='k'){ diagnoseClicks(); }
    if(ev.ctrlKey && ev.altKey && ev.key.toLowerCase()==='r'){ recoverClicks(); }
  });

  // Validation functions
  function validateOrderForm() {
    const errors = [];
    const name = qs('#o-name').value.trim();
    const qty = parseInt(qs('#o-qty').value) || 0;
    const startDate = qs('#o-start').value;
    const endDate = qs('#o-end').value;

    if (!name) errors.push('Nazwa zamówienia jest wymagana');
    if (name.length < 3) errors.push('Nazwa zamówienia musi mieć co najmniej 3 znaki');
    if (qty <= 0) errors.push('Ilość musi być większa od 0');
    if (qty > 1000) errors.push('Ilość nie może przekraczać 1000');

    if (startDate && endDate) {
      const start = new Date(startDate);
      const end = new Date(endDate);
      if (start > end) errors.push('Data rozpoczęcia nie może być późniejsza niż data zakończenia');
    }

    // Check for duplicate names (optional)
    const existingOrder = state.orders.find(o => o.name.toLowerCase() === name.toLowerCase() && o.id !== qs('#o-id').value);
    if (existingOrder) errors.push('Zamówienie o tej nazwie już istnieje');

    return errors;
  }

  function validateEmployeeForm() {
    const errors = [];
    const name = qs('#emp-name').value.trim();
    const capacity = parseInt(qs('#emp-cap').value) || 0;
    const hoursPerDay = parseInt(qs('#emp-hours').value) || 0;

    if (!name) errors.push('Imię i nazwisko pracownika jest wymagane');
    if (name.length < 2) errors.push('Imię i nazwisko musi mieć co najmniej 2 znaki');
    if (capacity <= 0 || capacity > 100) errors.push('Wydajność musi być między 1 a 100');
    if (hoursPerDay <= 0 || hoursPerDay > 24) errors.push('Godziny pracy dziennie muszą być między 1 a 24');

    // Check for duplicate names
    const existingEmp = state.employees.find(e => e.name.toLowerCase() === name.toLowerCase() && e.id !== qs('#emp-id').value);
    if (existingEmp) errors.push('Pracownik o tym imieniu i nazwisku już istnieje');

    return errors;
  }

  function showValidationErrors(errors) {
    // Remove existing error messages
    const existingErrors = document.querySelectorAll('.validation-error');
    existingErrors.forEach(el => el.remove());

    if (errors.length === 0) return;

    // Create error message container
    const errorDiv = document.createElement('div');
    errorDiv.className = 'validation-error card error';
    errorDiv.innerHTML = '<h4>Błędy walidacji:</h4><ul>' + errors.map(err => `<li>${err}</li>`).join('') + '</ul>';

    // Insert at the top of the current panel
    const currentPanel = document.querySelector('.card:not(.hidden)');
    if (currentPanel) {
      currentPanel.insertBefore(errorDiv, currentPanel.firstChild);
    }

    // Auto-hide after 5 seconds
    setTimeout(() => {
      if (errorDiv.parentNode) {
        errorDiv.remove();
      }
    }, 5000);
  }

  // Global search functions
  function performGlobalSearch(query) {
    if (!query || query.trim().length < 2) {
      hideSearchResults();
      return;
    }

    const results = [];
    const searchTerm = query.toLowerCase().trim();

    // Search orders
    (state.orders || []).forEach(order => {
      if (order.name && order.name.toLowerCase().includes(searchTerm)) {
        results.push({
          type: 'order',
          id: order.id,
          title: order.name,
          details: `Klient: ${order.client || 'Brak'} • Ilość: ${order.quantity || 0}`,
          navTarget: 'order'
        });
      }
      if (order.client && order.client.toLowerCase().includes(searchTerm)) {
        results.push({
          type: 'order',
          id: order.id,
          title: `Zamówienie: ${order.name}`,
          details: `Klient: ${order.client} • Ilość: ${order.quantity || 0}`,
          navTarget: 'order'
        });
      }
    });

    // Search employees
    (state.employees || []).forEach(emp => {
      if (emp.name && emp.name.toLowerCase().includes(searchTerm)) {
        results.push({
          type: 'employee',
          id: emp.id,
          title: emp.name,
          details: `Wydajność: ${emp.cap || 100}% • Godziny: ${emp.hoursPerDay || 8}/dzień`,
          navTarget: 'emp'
        });
      }
    });

    // Search tasks
    (state.tasks || []).forEach(task => {
      if (task.opName && task.opName.toLowerCase().includes(searchTerm)) {
        const orderName = task.orderId ? (state.orders.find(o => o.id === task.orderId)?.name || task.orderId) : 'Brak zamówienia';
        results.push({
          type: 'task',
          id: task.id,
          title: task.opName,
          details: `Zamówienie: ${orderName} • Status: ${task.status || 'todo'}`,
          navTarget: 'tasks'
        });
      }
    });

    // Search processes
    (state.processes || []).forEach(proc => {
      if (proc.name && proc.name.toLowerCase().includes(searchTerm)) {
        results.push({
          type: 'process',
          id: proc.id,
          title: proc.name,
          details: `Operacji: ${(proc.operations || []).length}`,
          navTarget: 'proc'
        });
      }
    });

    // Search operations catalog
    (state.operationsCatalog || []).forEach(op => {
      if (op.name && op.name.toLowerCase().includes(searchTerm)) {
        results.push({
          type: 'operation',
          id: op.id,
          title: op.name,
          details: `Czas: ${op.time || 0}min • Nr: ${op.no || 0}`,
          navTarget: 'opcat'
        });
      }
    });

    displaySearchResults(results.slice(0, 20)); // Limit to 20 results
  }

  function displaySearchResults(results) {
    const container = qs('#search-results');
    if (!container) return;

    if (results.length === 0) {
      container.innerHTML = '<div class="search-no-results">Brak wyników wyszukiwania</div>';
      container.style.display = 'block';
      return;
    }

    const typeLabels = {
      order: 'Zamówienie',
      employee: 'Pracownik',
      task: 'Zadanie',
      process: 'Proces',
      operation: 'Operacja'
    };

    container.innerHTML = results.map(result => `
      <div class="search-result-item" data-type="${result.type}" data-id="${result.id}" data-nav="${result.navTarget}">
        <div class="search-result-category">${typeLabels[result.type] || result.type}</div>
        <div class="search-result-title">${result.title}</div>
        <div class="search-result-details">${result.details}</div>
      </div>
    `).join('');

    container.style.display = 'block';
  }

  function hideSearchResults() {
    const container = qs('#search-results');
    if (container) {
      container.style.display = 'none';
    }
  }

  const storeKey='door_v5627_state';

  let state={storage:{mode:'firebase',appId:'doors-demo',userId:'hala-1',fbConfig:{
    "apiKey": "AIzaSyD93UqqsHWoAUBV7g8OVKAnajIfGDX_ZdY",
    "authDomain": "doors-planner.firebaseapp.com",
    "projectId": "doors-planner",
    "storageBucket": "doors-planner.appspot.com",
    "messagingSenderId": "513098608067",
    "appId": "1:513098608067:web:1fe3855b3470ca7ef22176"
  }},
    employees:[],operationsCatalog:[],processes:[],orders:[],tasks:[],after:[],PROC_TMP:[],page:'dash',_timers:{}};
  state.uiShowTasksByEmpTable = false;
  // migracja istniejących tasków (dodanie nowych pól jeśli brak)
  try{ if(window.scheduleCore){ window.scheduleCore.migrateTasks(state); } }catch(e){ console.warn('migrateTasks warn', e.message); }
  // migracja orderów - pole tasksGenerated
  try{ (state.orders||[]).forEach(o=>{ if(typeof o.tasksGenerated==='undefined') o.tasksGenerated=false; }); }catch(e){ console.warn('migrateOrders warn', e.message); }
  
  // Funkcja do sprawdzania i ładowania stanu
  function checkAndLoadState(){
    console.log('Sprawdzam stan aplikacji...');
    
    // Sprawdź czy stan istnieje
    if(!window.state){
      console.error('Stan aplikacji nie istnieje!');
      alert('Błąd: Stan aplikacji nie został załadowony!');
      return false;
    }
    
    // Sprawdź kluczowe właściwości stanu
    const requiredProps = ['storage', 'employees', 'operationsCatalog', 'processes', 'orders', 'tasks'];
    const missing = requiredProps.filter(prop => !state.hasOwnProperty(prop));
    if(missing.length > 0){
      console.error('Brakujące właściwości stanu:', missing);
      alert('Błąd stanu aplikacji! Brakujące właściwości: ' + missing.join(', '));
      return false;
    }
    
    // Sprawdź tryb storage
    console.log('Aktualny tryb storage:', state.storage.mode);
    console.log('Czy localhost:', window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1');
    
    console.log('Stan aplikacji załadowany poprawnie');
    return true;
  }
  
  // Sprawdź czy aplikacja została poprawnie załadowana
  window.addEventListener('load', function(){
    console.log('Aplikacja załadowana, sprawdzam stan...');
    
    // Sprawdź czy aplikacja jest otwierana z właściwego protokołu
    if(window.location.protocol === 'file:'){
      alert('⚠️ UWAGA: Aplikacja została otwarta z pliku lokalnego (file://).\n\nDla prawidłowego działania otwórz ją przez serwer HTTP:\nhttp://localhost:5500\n\nW VS Code użyj "Open with Live Server" lub uruchom:\npython -m http.server 5500');
      console.error('Aplikacja otwarta z file:// - niektóre funkcje mogą nie działać');
      return;
    }
    
    // Sprawdź stan aplikacji
    if(!checkAndLoadState()){
      console.error('Stan aplikacji nieprawidłowy - odświeżam stronę');
      setTimeout(() => forceRefresh(), 1000);
      return;
    }
    
    // Sprawdź czy localStorage działa
    try {
      localStorage.setItem('test', 'test');
      localStorage.removeItem('test');
      console.log('localStorage działa poprawnie');
    } catch(e) {
      console.error('localStorage nie działa:', e);
      alert('localStorage nie działa! Aplikacja może nie działać poprawnie.');
    }
    
    // Sprawdź czy wszystkie funkcje są dostępne
    const requiredFunctions = ['qs', 'save', 'renderDash', 'updateConnectionStatus'];
    const missing = requiredFunctions.filter(fn => typeof window[fn] !== 'function');
    if(missing.length > 0){
      console.error('Brakujące funkcje:', missing);
      alert('Błąd ładowania aplikacji! Brakujące funkcje: ' + missing.join(', '));
    } else {
      console.log('Wszystkie funkcje załadowane poprawnie');
    }
    
    // Wymuś aktualizację statusu
    if(typeof updateConnectionStatus === 'function'){
      updateConnectionStatus();
    }

    // Inicjalizacja przełącznika wysokiego kontrastu ostrzeżeń
    try{
      const toggle = document.getElementById('toggle-high-contrast');
      const callout = document.getElementById('startup-warning');
      if(toggle && callout){
        // wczytaj poprzednią preferencję
        const prefRaw = localStorage.getItem('highContrastWarnings');
        const pref = prefRaw === '1';
        toggle.checked = pref;
        if(pref){ callout.classList.add('high-contrast'); }
        toggle.addEventListener('change', ()=>{
          if(toggle.checked){ callout.classList.add('high-contrast'); localStorage.setItem('highContrastWarnings','1'); }
          else { callout.classList.remove('high-contrast'); localStorage.setItem('highContrastWarnings','0'); }
        });
      }
    }catch(e){ console.warn('HC toggle init error', e && e.message); }
    
    // Wymuś renderowanie dashboard
    if(typeof renderDash === 'function'){
  renderDash(); renderGantt();
  if(typeof initOffdaysQuickButtons==='function') initOffdaysQuickButtons();
    }
  });
  // If operationsCatalog is empty, seed with common operations (FUTRYNA, SKRZYDŁO, DODATKOWE)
  if(!(state.operationsCatalog && state.operationsCatalog.length)){
    state.operationsCatalog = [];
    let i = 1;
    const addOp = (name, time=10, skills=[])=>{ state.operationsCatalog.push({id: uid(), no: i++, name, time, workers:1, skills, defaultAssignees:[]}); };
    // FUTRYNA
    addOp('Frezowanie na CNC (belki futryny)', 40, ['CNC','belki']);
    addOp('Sklejanie belek (futryna)', 20, ['sklejanie','belki']);
    addOp('Kontrola wymiarów (futryna)', 10, ['kontrola']);
    addOp('Szlifowanie (futryna)', 15, ['szlifowanie']);
    addOp('Szczotkowanie (futryna)', 12, ['szczotkowanie']);
    addOp('Malowanie (futryna)', 30, ['malowanie']);
    addOp('Okuwanie (futryna)', 8, ['okucia']);
    // SKRZYDŁO
    addOp('Wycięcie belek pod skrzydło', 35, ['CNC','belki']);
    addOp('Sklejenie belek (skrzydło)', 20, ['sklejanie','belki']);
    addOp('Wycięcie sklejki', 25, ['sklejka']);
    addOp('Przygotowanie forniru', 18, ['fornir']);
    addOp('Fornirowanie', 30, ['fornirowanie']);
    addOp('Przygotowanie rurek pod elektronikę', 12, ['elektronika']);
    addOp('Montaż rurek pod elektronikę', 18, ['elektronika']);
    addOp('Przycięcie poprzeczek', 10, ['poprzeczki']);
    addOp('Montaż poprzeczek', 12, ['poprzeczki']);
    addOp('Przycięcie styropianu', 5, ['styropian']);
    addOp('Montaż styropianu', 8, ['styropian']);
    addOp('Przycięcie naciągu', 6, ['naciag']);
    addOp('Montaż naciągu', 8, ['naciag']);
    addOp('Sklejanie w prasie', 25, ['prasa']);
    addOp('Frezowanie na CNC (skrzydło)', 40, ['CNC']);
    addOp('Szlifowanie (skrzydło)', 15, ['szlifowanie']);
    addOp('Szczotkowanie (skrzydło)', 12, ['szczotkowanie']);
    addOp('Malowanie (skrzydło)', 30, ['malowanie']);
    addOp('Okuwanie (skrzydło)', 8, ['okucia']);
    // DODATKOWE
    addOp('Przygotowanie zestawu do drzwi', 10, ['zestaw']);
    addOp('Przygotowanie antaby', 8, ['antaba']);
    addOp('Zamówienie szyb', 5, ['szyby']);
    addOp('Malowanie szyb', 15, ['szyby','malowanie']);
    addOp('Klejenie szyb', 20, ['szyby','klejenie']);
    addOp('Polerowanie zamków i wypalenie logo', 12, ['zamki','polerowanie']);
    addOp('Wymiary szyby (szer, H)', 4, ['szyby','wymiary']);
  }
  // seed some default processes if none exist
  // UWAGA: seeding procesów następuje po wczytaniu localStorage (patrz niżej). Jeżeli user ma swoje dane, nie nadpisujemy.
  if(!(state.processes && state.processes.length)){
    const findByName = n => state.operationsCatalog.find(o=>o.name && o.name.indexOf(n)!==-1);
    const procAdd = (name, opNames)=>{
      const ops = (opNames||[]).map(n=>{ const o = state.operationsCatalog.find(x=>x.name===n); return o?{name:o.name,time:o.time||0}:{name:n,time:0}; });
      state.processes.push({id:uid(), name, operations: ops});
    };
    procAdd('Proces: Futryna', ['Frezowanie na CNC (belki futryny)','Sklejanie belek (futryna)','Kontrola wymiarów (futryna)','Szlifowanie (futryna)','Szczotkowanie (futryna)','Malowanie (futryna)','Okuwanie (futryna)']);
    procAdd('Proces: Skrzydło', ['Wycięcie belek pod skrzydło','Sklejenie belek (skrzydło)','Wycięcie sklejki','Fornirowanie','Frezowanie na CNC (skrzydło)','Szlifowanie (skrzydło)','Malowanie (skrzydło)','Okuwanie (skrzydło)']);
    procAdd('Proces: Drzwi kompletne', ['Frezowanie na CNC (belki futryny)','Sklejanie belek (futryna)','Wycięcie belek pod skrzydło','Sklejenie belek (skrzydło)','Sklejanie w prasie','Fornirowanie','Malowanie (skrzydło)','Okuwanie (skrzydło)']);
  }
  // ensure all requested operations exist (no duplicates by lowercased name)
  const ensureOp = (name, time=10, skills=[])=>{
    if(!name) return;
    const exists = (state.operationsCatalog||[]).some(o=> (o.name||'').toLowerCase() === name.toLowerCase());
    if(!exists){ state.operationsCatalog.push({id:uid(), no:(state.operationsCatalog||[]).length+1, name, time, workers:1, skills, defaultAssignees:[]}); }
  };
  // operations from user list
  [
    'Wycięcie belek pod futrynę', 'Frezowanie na CNC 40 m', 'Sklejanie belek', 'Kontrola wymiarów', 'Szlifowanie', 'Szczotkowanie', 'Malowanie', 'Okuwanie',
    'Wycięcie belek pod skrzydło', 'Sklejenie belek', 'Wycięcie sklejki', 'Przygotowanie forniru zgodnie z zamówieniem', 'Fornirowanie', 'Przygotowanie rurek pod elektronikę', 'Montaż rurek pod elektronikę',
    'Przycięcie poprzeczek', 'Montaż poprzeczek', 'Przycięcie styropianu', 'Montaż styropianu', 'Przycięcie naciągu', 'Montaż naciągu', 'Sklejanie w prasie', 'Frezowanie na CNC',
    'Przygotowanie zestawu do drzwi', 'Przygotowanie antaby', 'Zamówienie szyb', 'Malowanie szyb', 'Klejenie szyb', 'Polerowanie zamków i wypalenie logo', 'Wymiary szyby (szer, H)'
  ].forEach(n=>ensureOp(n, 10, []));
  // --- STORAGE HELPERS (zdefiniowane przed pierwszym użyciem) ---
  let autoSaveTimeout;
  function autoSaveDebounced(){
    clearTimeout(autoSaveTimeout);
    autoSaveTimeout = setTimeout(()=>{ try{ saveToDB(); }catch(e){ /* ignore at startup */ } }, 500);
  }
  function save(){
    try{ 
      console.log('SAVE: Zapisuję dane...', {
        employees: state.employees?.length || 0,
        operations: state.operationsCatalog?.length || 0,
        processes: state.processes?.length || 0,
        orders: state.orders?.length || 0,
        tasks: state.tasks?.length || 0
      });
      localStorage.setItem(storeKey, JSON.stringify(state)); 
      console.log('SAVE: Dane zapisane pomyślnie');
    }catch(e){ 
      console.error('SAVE: Błąd zapisu:', e);
    }
    autoSaveDebounced();
  }
  try{ window.save = save; }catch(_){ }

  // Najpierw spróbuj wczytać poprzedni stan (jeśli istnieje) ZANIM wymusimy zapis seedów
  try{
    const raw=localStorage.getItem(storeKey); 
    if(raw) {
      const loadedData = JSON.parse(raw);
      Object.assign(state, loadedData);
      console.log('LOAD: Dane załadowane z localStorage:', {
        employees: state.employees?.length || 0,
        operations: state.operationsCatalog?.length || 0,
        processes: state.processes?.length || 0,
        orders: state.orders?.length || 0,
        tasks: state.tasks?.length || 0
      });
    } else {
      console.log('LOAD: Brak danych w localStorage, używam domyślne');
    }
  }catch(e){ 
    console.error('LOAD: Błąd ładowania danych:', e);
  }
  // Jeśli użytkownik miał już własne procesy/operacje, nie nadpisujemy ich seedami (state.processes może być teraz niepuste)
  // Jeśli po wczytaniu nadal brak processes / operationsCatalog – wtedy zapisujemy seedy.
  if(!(state.processes && state.processes.length)){
    try{ save(); }catch(e){ console.warn('seed save error', e && e.message); }
  }
  // ensure stored autosave preference exists
  state.storage.autoSaveAssign = state.storage.autoSaveAssign === undefined ? true : !!state.storage.autoSaveAssign;
  // ensure stored spellcheck enforce preference exists (default: true)
  state.storage.spellcheckEnforce = state.storage.spellcheckEnforce === undefined ? true : !!state.storage.spellcheckEnforce;
  // (przeniesione wyżej – odczyt localStorage przed seedingiem)
  // ensure settings object exists and default autoCleanup = true
  state.settings = state.settings || {};
  if (typeof state.settings.autoCleanup === 'undefined') state.settings.autoCleanup = true;
  // expose state for debugging and console access
  try{ window.state = state; }catch(e){console.warn('unable to expose state', e);}

  // DEFINICJA FUNKCJI PRZED JEJ WYWOLANIEM
  window.restoreNormalClickDelegation = function(){
    window.disableGlobalClickDelegation = false;
    console.log('[rescue] Normal click delegation RESTORED');
    // Zapobiegaj ponownemu włączeniu - nadpisz funkcję awaryjną
    window.enableNoDelegateMode = function(){
      console.warn('[rescue] No-delegation mode BLOCKED - normal delegation required');
      return false;
    };
  };

  // NATYCHMIAST przywróć normalną delegację kliknięć - NAJWYŻSZY PRIORYTET
  window.restoreNormalClickDelegation();
  console.log('INIT: Normalna delegacja kliknięć przywrócona na starcie');

  // AWARYJNE: Sprawdzaj i przywracaj delegację co 5 sekund
  setInterval(() => {
    if (window.disableGlobalClickDelegation) {
      window.restoreNormalClickDelegation();
      console.log('AUTO-RESTORE: Delegacja kliknięć przywrócona automatycznie');
    }
  }, 5000);

  // (stara definicja save/autoSaveDebounced usunięta – przeniesiona wyżej)

  // call this to trigger optional immediate Firebase save when enabled in settings
  function maybeAutoSave(reason){
    try{
      const enabled = !!state.storage.autoSaveAssign;
      if(enabled){ saveToDB(); setInfoText('Auto-save: ' + (reason||'sync'), 'default'); }
    }catch(e){ console.warn('maybeAutoSave error', e); }
  }
  
  function nav(p){
    // AWARYJNE: Przy każdej nawigacji przywracaj normalną delegację kliknięć
    if (window.disableGlobalClickDelegation) {
      window.restoreNormalClickDelegation();
      console.log('[nav] Emergency delegation restore for page:', p);
    }
    const map={dash:'p-dash',tasks:'p-tasks',order:'p-order',proc:'p-proc',opcat:'p-opcat',emp:'p-emp',as:'p-as',
               map:'p-map',monitor:'p-monitor',mrp:'p-mrp',wh:'p-wh',backup:'p-backup',migr:'p-migr',settings:'p-settings',gantt:'p-gantt',capacity:'p-capacity',reports:'p-reports'};
    qsa('[id^="p-"]').forEach(el=>el.classList.add('hidden'));
    qs('#'+(map[p]||'p-dash')).classList.remove('hidden');
    state.page=p; save();
    if(p==='order') renderOrderPage(window.state||state);
    if(p==='tasks') renderTasks();
    if(p==='opcat') renderOps();
    if(p==='proc') renderProcPage();
    if(p==='emp') renderEmployees(window.state||state);
    if(p==='as') renderASPage();
    if(p==='mrp') renderMRPPage();
    if(p==='gantt') renderGantt();
    if(p==='capacity') renderCapacityAnalysis();
    if(p==='reports') renderReports();
    if(p==='monitor') try{ renderMonitor(); }catch(_){ /* no-op if monitor renderer missing */ }
    if(p==='wh') {
      try { 
        // Przywracamy normalną delegację kliknięć przy wejściu do magazynu
        window.restoreNormalClickDelegation();
        initWarehouse(); 
      } catch(e){ console.warn('[warehouse] init error', e); }
    }
  renderDash(window.state||state); renderGantt();
  }
  window.nav=nav;

  const handleEvents = async (e) => {
    let t = e.target;
    // AWARYJNE: Ignoruj flagę disableGlobalClickDelegation dla przycisków nawigacji i podstawowych kontrolek
    const isNavigationButton = t.closest && (t.closest('[data-nav]') || t.closest('button') && t.closest('header'));
    const isBasicControl = t.closest && (t.closest('#restore-click-delegation') || t.closest('#set-save') || t.closest('#set-load'));
    if (window.disableGlobalClickDelegation && !isNavigationButton && !isBasicControl) {
      return;
    }
    while(t && t !== document.body) {
      if(e.type === 'click') {
        // Jeśli element ma atrybut data-no-global, przerywamy delegację (pozwalamy lokalnym listenerom działać bez wpływu globalnego handlera)
        if(t.hasAttribute && t.hasAttribute('data-no-global')) break;
        if(t.dataset.nav) { nav(t.dataset.nav); break; }
        if(t.dataset.od) {
          const id = t.dataset.od; state.orders = state.orders.filter(x => x.id !== id); state.tasks = state.tasks.filter(t => t.orderId !== id); state.after = state.after.filter(a => a.order !== id); save();
          renderOrderPage(); renderASPage(); renderDash(window.state||state); renderGantt(); break;
        }
        if(t.dataset.oed) {
          const id = t.dataset.oed;
          const o = state.orders.find(x => x.id === id);
          if (!o) return;
          qs('#o-id').value = o.id || '';
          qs('#o-name').value = o.name || '';
          qs('#o-client').value = o.client || '';
          qs('#o-model').value = o.model || '';
          qs('#o-qty').value = o.quantity || 1;
          qs('#o-start').value = o.startDate || '';
          qs('#o-end').value = o.endDate || '';
          qs('#o-notes').value = o.notes || '';
          qs('#o-install').value = o.installDate || '';
          qs('#o-addr').value = o.address || '';
          qs('#o-post').value = o.postalCode || '';
          qs('#o-phone').value = o.phone || '';
          qs('#o-proc').value = o.processId || '';
          window.scrollTo({top: 0, behavior: 'smooth'});
          break;
        }
        if(t.dataset.ogen) {
          const id = t.dataset.ogen; const o = state.orders.find(x => x.id === id); if (!o) return;
          qs('#o-id').value = o.id || '';
          qs('#o-name').value = o.name || '';
          qs('#o-client').value = o.client || '';
          qs('#o-model').value = o.model || '';
          qs('#o-qty').value = o.quantity || 1;
          qs('#o-start').value = o.startDate || '';
          qs('#o-end').value = o.endDate || '';
          qs('#o-notes').value = o.notes || '';
          qs('#o-install').value = o.installDate || '';
          qs('#o-addr').value = o.address || '';
          if(qs('#o-post')) qs('#o-post').value = o.postalCode || o.post || '';
          qs('#o-post').value = o.postalCode || '';
          qs('#o-phone').value = o.phone || '';
          qs('#o-name').value = o.name || o.number || o.orderNumber || '';
          qs('#o-proc').value = o.processId || '';
          // Sprawdź czy zlecenie ma przypisany proces
          if (!o.processId) {
            alert('To zlecenie nie ma przypisanego procesu. Najpierw wybierz proces w edycji zlecenia.');
            break;
          }
          
          // Znajdź przypisany proces
          let p = state.processes.find(x => x.id === o.processId);
          if (!p) {
            alert('Nie znaleziono przypisanego procesu (ID: ' + o.processId + '). Wybierz inny proces.');
            break;
          }
          
          // Sprawdź czy proces ma operacje
          if (!p.operations || !p.operations.length) {
            alert('Wybrany proces nie zawiera żadnych operacji. Wybierz inny proces lub dodaj operacje do obecnego.');
            break;
          }
          
          // Sprawdź czy zamówienie już ma zadania
          const existingOrderTasks = (state.tasks || []).filter(t => t.orderId === o.id);
          if (existingOrderTasks.length > 0) {
            alert('To zamówienie już ma wygenerowane zadania. Jeśli chcesz wygenerować ponownie, najpierw usuń istniejące zadania.');
            break;
          }
          
          console.log('Przed generowaniem zadań:', {
            currentTasks: state.tasks ? state.tasks.length : 0,
            currentOrderId: o.id
          });
          
          // Zachowaj istniejące zadania niezwiązane z tym zleceniem
          const existingTasks = Array.isArray(state.tasks) ? state.tasks : [];
          const otherTasks = existingTasks.filter(t => t.orderId !== o.id);
          const newTasks = [];
          
          console.log('Generowanie zadań z procesu:', {
            processId: p.id,
            processName: p.name,
            operations: p.operations.length
          });
          
          // Dodaj nowe zadania z procesu wybranego dla zlecenia
          (p.operations || []).forEach(op => {
            // Znajdź definicję operacji w katalogu
            const catalogOp = (state.operationsCatalog || []).find(co => co.name === op.name);
            
            // Użyj przypisań z procesu, a jeśli brak to z katalogu operacji
            const assignees = op.assignee ? [op.assignee] : 
                            (catalogOp && catalogOp.defaultAssignees ? catalogOp.defaultAssignees : []);
            newTasks.push({
              id: uid(), 
              orderId: o.id,
              processId: p.id, // Dodajemy ID procesu
              opName: op.name,
              status: 'todo',
              elapsedMin: 0,
              estMin: op.time || 0,
              assignees: assignees,
              processName: p.name, // Dodajemy nazwę procesu
              opIndex: p.operations.indexOf(op) // Dodajemy indeks operacji w procesie
            });
          });
          
          // Połącz istniejące zadania z nowymi
          state.tasks = [...otherTasks, ...newTasks];
          
          console.log('Po dodaniu nowych zadań:', {
            newTasks: newTasks.length,
            finalTasks: state.tasks.length,
            sample: state.tasks.slice(0, 3)
          });
          
          // Upewnij się że state.tasks jest tablicą
          if (!Array.isArray(state.tasks)) {
            console.error('state.tasks nie jest tablicą!', state.tasks);
            state.tasks = [];
          }
          
          save(); try{ updateOrderProgress(o.id); }catch(_){ } nav('tasks'); break;
        }
        if(t.dataset.opEd) {
          const id = t.dataset.opEd; const o = (state.operationsCatalog || []).find(x => x.id === id); if (!o) return;
          qs('#op-id').value = o.id || ''; qs('#op-no').value = o.no || 1; qs('#op-name').value = o.name || '';
          qs('#op-time').value = o.time || 10; qs('#op-workers').value = o.workers || 1;
          qs('#op-skills').value = (o.skills || []).join(';'); populateOpEmployees();
          const sel = qs('#op-emp'); const set = new Set((o.defaultAssignees || []).map(a => a.id));
          Array.from(sel.options || []).forEach(opt => opt.selected = set.has(opt.value)); qs('#op-msg').textContent = ''; break;
        }
        if(t.dataset.opDel) {
          const id = t.dataset.opDel; if (!confirm('Usunąć operację?')) return;
          state.operationsCatalog = (state.operationsCatalog || []).filter(x => x.id !== id); save(); renderOps();
          try { if (state.storage.mode === 'firebase' && await ensureFirebase()) { await fbRoot().collection('operationsCatalog').doc(id).delete(); } } catch (e) { console.warn('Błąd usuwania operacji:', e.message); } break;
        }
        if(t.dataset.opUp) { moveOp(t.dataset.opUp, 'up'); break; }
        if(t.dataset.opDown) { moveOp(t.dataset.opDown, 'down'); break; }
        if(t.dataset.pup) { const i = +t.dataset.pup; const a = state.PROC_TMP; if (i > 0) { [a[i - 1], a[i]] = [a[i], a[i - 1]]; renderProcOps(); } break; }
        if(t.dataset.pdown) { const i = +t.dataset.pdown; const a = state.PROC_TMP; if (i < a.length - 1) { [a[i + 1], a[i]] = [a[i], a[i + 1]]; renderProcOps(); } break; }
        if(t.dataset.pdel) { const i = +t.dataset.pdel; state.PROC_TMP.splice(i, 1); renderProcOps(); break; }
        if(t.dataset.ped) {
          const p = state.processes.find(x => x.id === t.dataset.ped); if (!p) return; qs('#proc-id').value = p.id;
          qs('#proc-name').value = p.name;
          // preserve assignee when loading for edit
          state.PROC_TMP = (p.operations || []).map(x => ({name: x.name, time: x.time || 0, assignee: x.assignee || null}));
          renderProcOps(); window.scrollTo({top: 0, behavior: 'smooth'}); break;
        }
        if(t.dataset.pdel2) { state.processes = state.processes.filter(x => x.id !== t.dataset.pdel2); save(); renderProcList(); break; }
        if(t.dataset.taskStart) {
          const id = t.dataset.taskStart; const task = state.tasks.find(x => x.id === id); if (!task) return;
          task.status = 'run'; state._timers[id] = Date.now(); save(); try{ updateOrderProgress(task.orderId); }catch(_){ } renderTasks(); break;
        }
        if(t.dataset.taskPause) {
          const id = t.dataset.taskPause; const task = state.tasks.find(x => x.id === id); if (!task) return;
          if (state._timers[id]) { task.elapsedMin = (task.elapsedMin || 0) + (Date.now() - state._timers[id]) / 60000; delete state._timers[id]; }
          task.status = 'todo'; save(); try{ updateOrderProgress(task.orderId); }catch(_){ } renderTasks(); break;
        }
        if(t.dataset.taskDone) {
          const id = t.dataset.taskDone; const task = state.tasks.find(x => x.id === id); if (!task) return;
          if (state._timers[id]) { task.elapsedMin = (task.elapsedMin || 0) + (Date.now() - state._timers[id]) / 60000; delete state._timers[id]; }
          task.status = 'done'; save(); try{ updateOrderProgress(task.orderId); }catch(_){ } renderTasks(); break;
        }
        if(t.dataset.taskRepeat) {
          const id = t.dataset.taskRepeat; const task = state.tasks.find(x => x.id === id); if (!task) return;
          if (state._timers[id]) delete state._timers[id]; task.status = 'todo'; task.elapsedMin = 0; save(); try{ updateOrderProgress(task.orderId); }catch(_){ } renderTasks(); break;
        }
        if(t.dataset.taskRetry) {
          const id = t.dataset.taskRetry; const task = state.tasks.find(x => x.id === id); if (!task) return;
          task._syncPending = true; task._syncError = false; save(); try{ renderTasks(); }catch(_){ }
          if(state.storage && state.storage.mode === 'firebase'){
            try{ await saveTaskToDB(id); }catch(e){ (window.logDev||console.warn)('taskRetry saveToDB error', e && e.message); }
          }
          break;
        }
        if(t.dataset.taskDel) { const id = t.dataset.taskDel; 
          const ask = state.storage.askBeforeTaskDelete === undefined ? true : !!state.storage.askBeforeTaskDelete;
          const doDelete = await (async ()=>{
            if(!ask) return true;
            try{ return await confirmModal('Usunąć zadanie?'); }catch(_){ return false; }
          })();
          if(!doDelete) return; const toDel = (state.tasks||[]).find(x=>x.id===id); state.tasks = (state.tasks||[]).filter(x=>x.id!==id); save(); try{ if(toDel) updateOrderProgress(toDel.orderId); }catch(_){ } renderTasks(); break; }
        if(t.dataset.empDel) { state.employees = state.employees.filter(x => x.id !== t.dataset.empDel); save(); renderEmployees(); break; }
        if(t.dataset.empEd) {
          const e = state.employees.find(x => x.id === t.dataset.empEd); if (!e) return;
          const n = prompt('Nowe imię', e.name) || e.name; e.name = n; save(); renderEmployees(); break;
        }
        if(t.dataset.assign) {
          // legacy hook for assign buttons (if any). mark save and maybeAutoSave
          const id = t.dataset.assign; // task id
          // a real assign flow should update state.tasks[].assignees
          maybeAutoSave('assign');
          break;
        }
        if(t.dataset.taskStart){
          const id = t.dataset.taskStart; const task = (state.tasks||[]).find(x=>x.id===id); if(!task) break;
          // mark as running
          task.status = 'run';
          task.startedAt = new Date().toISOString();
          task.startedBy = (state.storage && state.storage.userId) || task.startedBy || null;
          if(typeof task.elapsedMin === 'undefined') task.elapsedMin = 0;
          save(); try{ renderTasks(); renderMonitor && renderMonitor(); }catch(_){ }
          maybeAutoSave('task-start');
          break;
        }
        if(t.dataset.taskDone){
          const id = t.dataset.taskDone; const task = (state.tasks||[]).find(x=>x.id===id); if(!task) break;
          task.status = 'done'; task.closedAt = new Date().toISOString(); task.closedBy = (state.storage && state.storage.userId) || task.closedBy || null;
          try{ if(task.startedAt){ const s = new Date(task.startedAt); const diff = (Date.now() - s.getTime())/60000; task.elapsedMin = Math.round((task.elapsedMin||0) + diff); } }catch(_){ }
          save(); try{ renderTasks(); renderMonitor && renderMonitor(); }catch(_){ }
          // after marking a task done, if all tasks for the same order are finished, remove tasks for that order
          try{ if(task.orderId){ cleanupTasksForOrder(task.orderId); } }catch(_){ }
          maybeAutoSave('task-done');
          break;
        }
        if(t.dataset.asDel) { state.after = state.after.filter(x => x.id !== t.dataset.asDel); save(); renderASPage(); break; }
        if(t.dataset.asEd) {
          const a = state.after.find(x => x.id === t.dataset.asEd); if (!a) return; qs('#as-id').value = a.id;
          qs('#as-type').value = a.type; qs('#as-order').value = a.order || ''; qs('#as-status').value = a.status;
          qs('#as-desc').value = a.desc || ''; qs('#as-install').value = a.installDate || '';
          qs('#as-go').value = a.departTime || ''; qs('#as-visit').value = a.visitTime || '';
          // populate hidden/order-linked fields (phone/placecode)
          if(qs('#as-order-phone')) qs('#as-order-phone').value = a.phone || '';
          if(qs('#as-order-placecode')) qs('#as-order-placecode').value = a.postalCode || a.placeCode || '';
          break;
        }
        if(t.dataset.refreshAs) { loadFromDB(); break; }
        if (t.id === 'mrp-generate') { renderMRPPage(); break; }
      } else if (e.type === 'input') {
        if(e.target && (e.target.id === 'o-start' || e.target.id === 'o-weeks' || e.target.id === 'o-end')) {
            if (e.target.id === 'o-start' || e.target.id === 'o-weeks') {
                calcEndDate();
            } else if (e.target.id === 'o-end') {
                calcInstallDate();
            }
            break;
        }
        if (t.parentElement && t.parentElement.id === 'p-settings') {
          state.storage.mode = qs('#set-mode').value;
          state.storage.appId = qs('#set-appid').value.trim();
          state.storage.userId = qs('#set-userid').value.trim();
          try { state.storage.fbConfig = JSON.parse(qs('#set-fb').value || '{}'); } catch(e) {}
          save();
          updateConnectionStatus();
          break;
        }
      }
      t = t.parentElement;
    }
  };
  document.addEventListener('click', handleEvents);

  // Tryb awaryjny: bezpośrednie listenery dla data-nav i krytycznych przycisków
  window.initDirectNavHandlers = function(){
    try{
      console.log('[rescue] Installing direct nav handlers');
      document.querySelectorAll('[data-nav]').forEach(el=>{
        if(el.__directNavBound) return;
        el.addEventListener('click', (ev)=>{ if(window.disableGlobalClickDelegation){ ev.preventDefault(); ev.stopPropagation(); nav(el.getAttribute('data-nav')); } });
        el.__directNavBound = true;
      });
      // Magazyn przyciski
      const ids=['btn-add-warehouse','btn-refresh-warehouse','btn-export-warehouse'];
      ids.forEach(id=>{ const b=document.getElementById(id); if(b && !b.__directBound){ b.addEventListener('click', ev=>{ if(window.disableGlobalClickDelegation){ ev.preventDefault(); ev.stopPropagation(); if(id==='btn-add-warehouse' && window.simpleWarehouse) window.simpleWarehouse.showAddItemModal(); if(id==='btn-refresh-warehouse' && window.simpleWarehouse) window.simpleWarehouse.render(); if(id==='btn-export-warehouse' && window.simpleWarehouse) window.simpleWarehouse.exportData(); }}); b.__directBound=true; }});
      console.log('[rescue] Direct handlers ready');
    }catch(e){ console.warn('[rescue] direct nav error', e); }
  };
  
  // Funkcja włączająca tryb awaryjny (wyłącza delegację, dodaje bezpośrednie listenery)
  window.enableNoDelegateMode = function(){
    console.warn('[BLOCKED] No-delegation mode DISABLED - normal delegation required for this app');
    // Automatycznie przywróć normalną delegację
    window.restoreNormalClickDelegation();
    return false;
  };

  // NOWA FUNKCJA: Przywracanie normalnej delegacji kliknięć - PRZENIESIONA WYŻEJ
  // window.restoreNormalClickDelegation = function(){
  //   window.disableGlobalClickDelegation = false;
  //   console.log('[rescue] Normal click delegation RESTORED');
  //   // Zapobiegaj ponownemu włączeniu - nadpisz funkcję awaryjną
  //   window.enableNoDelegateMode = function(){
  //     console.warn('[rescue] No-delegation mode BLOCKED - normal delegation required');
  //     return false;
  //   };
  // };

  // Awaryjna funkcja przywracania klikalności
  window.enableClicksRescue = function(){
    try{
      console.log('[rescue] Starting click rescue...');
      document.body.style.pointerEvents='auto';
      document.body.style.userSelect='auto';
      // Usuń potencjalne pełnoekranowe zasłony (heurystyka)
      const vw=innerWidth, vh=innerHeight;
      let removed=0;
      document.querySelectorAll('body *').forEach(el=>{
        try{
          const st=getComputedStyle(el); if(st.position!=='fixed'&&st.position!=='absolute') return;
          const r=el.getBoundingClientRect();
          if(r.width>vw*0.98 && r.height>vh*0.98){
            if(st.pointerEvents!=='none' && !el.id.includes('dev-log')){
              el.style.pointerEvents='none'; el.style.opacity='0.999'; removed++;
            }
          }
        }catch(_){/* ignore */}
      });
      console.log('[rescue] Processed overlays, modified:', removed);
      // Dodaj testowy przycisk diagnostyczny
      if(!document.getElementById('__click_test_btn')){
        const b=document.createElement('button'); b.id='__click_test_btn'; b.textContent='test click'; b.style.cssText='position:fixed;top:4px;right:4px;z-index:999999;padding:4px 8px;font-size:12px';
        b.addEventListener('click',()=>console.log('[rescue] test button clicked OK'));
        document.body.appendChild(b);
      }
      console.log('[rescue] Click rescue finished.');
    }catch(e){ console.warn('[rescue] error', e); }
  };

  // DEBUG: when Edit buttons are clicked (data-op-ed), log the event and #op-id after population
  (function attachOpEditLog(){
    document.body.addEventListener('click', function(ev){
      const btn = ev.target.closest && ev.target.closest('[data-op-ed]');
      if(!btn) return; const opId = btn.getAttribute('data-op-ed');
      (window.logDev||console.log)('[ui] Edit click', { dataOpEd: opId });
      // schedule a short tick to log #op-id after any population logic runs
      setTimeout(()=>{ const cur = qs('#op-id')?qs('#op-id').value:''; (window.logDev||console.log)('[ui] #op-id after edit click', cur); }, 50);
    }, true);
  })();
  document.addEventListener('input', handleEvents);

  // sync autosave checkbox UI with state on load
  try{ const cb = qs('#set-autosave-assign'); if(cb) cb.checked = !!state.storage.autoSaveAssign; }catch(e){}
  // sync autoload DB checkbox UI with state on load
  try{ const al = qs('#set-autoload-db'); if(al) al.checked = !!state.storage.autoLoadFromDB; }catch(e){}
  // sync monitor threshold UI with state on load
  try{ const th = qs('#set-monitor-threshold'); if(th) th.value = String(state.storage.monitorThreshold || 5); }catch(e){}
  // sync monitor alerts UI with state on load
  try{ const ma = qs('#set-monitor-alerts'); if(ma) ma.checked = (state.storage.monitorAlertsEnabled !== false); }catch(e){}
  // sync auto-cleanup UI with state on load
  try{ const ac = qs('#set-auto-cleanup'); if(ac) ac.checked = (state.settings && state.settings.autoCleanup !== false); }catch(e){}
  // sync spellcheck enforce checkbox UI with state on load
  try{ const sc = qs('#set-spellcheck-enforce'); if(sc) sc.checked = !!state.storage.spellcheckEnforce; }catch(e){}

  // persist autosave checkbox changes
  const autosaveEl = qs('#set-autosave-assign'); if(autosaveEl){ autosaveEl.addEventListener('change', (ev)=>{ state.storage.autoSaveAssign = !!ev.target.checked; save(); }); }
  // persist autoload checkbox changes
  const autoloadEl = qs('#set-autoload-db'); if(autoloadEl){ autoloadEl.addEventListener('change', (ev)=>{ state.storage.autoLoadFromDB = !!ev.target.checked; save(); }); }
  // persist monitor threshold changes
  const monitorThEl = qs('#set-monitor-threshold'); if(monitorThEl){ monitorThEl.addEventListener('change', (ev)=>{ const v = parseInt(ev.target.value||'5',10) || 5; state.storage.monitorThreshold = Math.max(1, v); save(); }); }
  // persist monitor alerts changes
  const monitorAlertEl = qs('#set-monitor-alerts'); if(monitorAlertEl){ monitorAlertEl.addEventListener('change', (ev)=>{ state.storage.monitorAlertsEnabled = !!ev.target.checked; save(); }); }
  // persist auto-cleanup changes
  const autoCleanupEl = qs('#set-auto-cleanup'); if(autoCleanupEl){ autoCleanupEl.addEventListener('change', (ev)=>{ state.settings.autoCleanup = !!ev.target.checked; save(); }); }
  // persist spellcheck enforce changes
  const spellEl = qs('#set-spellcheck-enforce'); if(spellEl){ spellEl.addEventListener('change', (ev)=>{ state.storage.spellcheckEnforce = !!ev.target.checked; save(); if(ev.target.checked) enableSpellAndLang(); else disableSpellAndLang(); }); }

  // in-page confirmation modal (promise-based)
  function confirmModal(message){
    return new Promise((resolve)=>{
      try{
        const modal = qs('#app-confirm-modal'); const msg = qs('#app-confirm-msg'); const ok = qs('#app-confirm-ok'); const cancel = qs('#app-confirm-cancel'); const close = qs('#app-confirm-close'); const noask = qs('#app-confirm-noask');
        if(!modal || !msg || !ok || !cancel) return resolve(false);
        msg.textContent = String(message||'');
        modal.classList.remove('hidden');
        const cleanup = ()=>{ modal.classList.add('hidden'); ok.removeEventListener('click', onOk); cancel.removeEventListener('click', onCancel); close && close.removeEventListener('click', onCancel); };
        const onOk = ()=>{ const na = !!noask.checked; if(na) state.storage.askBeforeTaskDelete = false; save(); cleanup(); resolve(true); };
        const onCancel = ()=>{ const na = !!noask.checked; if(na) state.storage.askBeforeTaskDelete = false; save(); cleanup(); resolve(false); };
        ok.addEventListener('click', onOk); cancel.addEventListener('click', onCancel); if(close) close.addEventListener('click', onCancel);
      }catch(e){ resolve(false); }
    });
  }

  function addWorkdays(dateString, days) {
    let d = new Date(dateString + 'T00:00:00');
    let count = 0;
    while (count < days) {
      d.setDate(d.getDate() + 1);
      if (d.getDay() !== 0 && d.getDay() !== 6) {
        count++;
      }
    }
    return d.toISOString().slice(0, 10);
  }

  function calcEndDate() {
    const s = qs('#o-start').value;
    const w = +qs('#o-weeks').value || 1;
    if (!s) return;
    const end = addWorkdays(s, w * 5 - 1);
    qs('#o-end').value = end;
    calcInstallDate();
  }

  function calcInstallDate() {
    const end = qs('#o-end').value;
    if (!end) return;
    const install = addWorkdays(end, 7);
    qs('#o-install').value = install;
  }

  // Funkcja pomocnicza do ustawiania tekstu z dobrym kontrastem
  function setInfoText(text, type = 'default') {
    const info = qs('#set-info');
    if(!info) return;
    
    info.textContent = text;
    info.style.color = '#ffffff';
    info.style.fontWeight = '600';
    info.style.fontSize = '14px';
    info.style.padding = '4px 8px';
    info.style.borderRadius = '4px';
    info.style.border = '1px solid #334155';
    
    // Kolorystyka według typu wiadomości
    switch(type) {
      case 'success':
        info.style.background = '#059669'; // Zielone
        break;
      case 'warning':
        info.style.background = '#d97706'; // Pomarańczowe
        break;
      case 'error':
        info.style.background = '#dc2626'; // Czerwone
        break;
      default:
        info.style.background = '#1a2332'; // Domyślne ciemnoniebieskie
    }
  }

  function updateConnectionStatus(){
    const info = qs('#set-info');
    if(!info) return;
    
    if(state.storage.mode === 'firebase'){
      setInfoText('Tryb Firebase - sprawdzam połączenie...', 'default');
      // Sprawdź połączenie z Firebase
      ensureFirebase().then(ok => {
        if(ok){
          setInfoText('✅ Połączono z Firebase', 'success');
        } else {
          setInfoText('⚠️ Firebase niedostępny - tryb offline', 'warning');
        }
      }).catch(() => {
        setInfoText('❌ Błąd połączenia z Firebase', 'error');
      });
    } else {
      setInfoText('Tryb localStorage (offline)', 'default');
    }
  }
  // Upewnij się że funkcja dostępna globalnie do diagnostyki ładowania
  window.updateConnectionStatus = window.updateConnectionStatus || updateConnectionStatus;
  
  function populateProcessSelect(){
    const sel = qs('#o-proc');
    if (sel) {
      sel.innerHTML = '<option value="">Brak</option>';
      (state.processes || []).forEach(p => {
        const opt = document.createElement('option');
        opt.value = p.id;
        opt.textContent = p.name;
        sel.appendChild(opt);
      });
    }
  }

  function renderOrderPage(){
    populateProcessSelect();
    const host=qs('#ord-tb'); if(!host) return; host.innerHTML='';
    // show progress column: percent + counts
    (state.orders||[]).slice().reverse().forEach(o=>{
      const tr=document.createElement('tr');
      const place = o.postalCode || o.post || '';
      const pr = computeOrderProgress(o.id) || (o.progress || {total:0,done:0,run:0,todo:0,pct:0});
      const pct = Math.round((pr.pct||0));
      const barWidth = Math.min(100, Math.max(0, pct));
      const bar = `<div style="background:#0b1222;border:1px solid #223044;border-radius:6px;height:12px;width:120px;overflow:hidden"><div style="height:100%;width:${barWidth}%;background:linear-gradient(90deg,#16a34a,#a3e635);"></div></div>`;
      // Lead time (planned) w godzinach
      const ts = (state.tasks||[]).filter(t=>t.orderId===o.id && t.startPlanned && t.endPlanned);
      let leadH = '-';
      if(ts.length){
        const startMin = Math.min(...ts.map(t=>t.startPlanned));
        const endMax = Math.max(...ts.map(t=>t.endPlanned));
        leadH = ((endMax - startMin)/3600000).toFixed(1);
      }
  const genBtn = o.tasksGenerated ? '' : `<button class=\"btn\" data-ogen=\"${o.id}\">Gen. zadania</button>`;
  const replanOneBtn = `<button class=\"btn amber\" data-replan-order=\"${o.id}\" title=\"Resetuj i przelicz tylko zadania tego zlecenia\">Replan</button>`;
  tr.innerHTML=`<td>${o.name||'-'}</td><td>${o.client||'-'}</td><td>${o.model||'-'}</td><td>${o.quantity||'-'}</td>
                    <td>${o.startDate||'-'}</td><td>${o.endDate||'-'}</td><td>${o.installDate||'-'}</td><td>${place||'-'}</td>
                    <td>${bar} <div class="muted" style="font-size:12px;margin-top:4px">${pct}% (${pr.done}/${pr.total})</div></td>
                    <td>${leadH}</td>
  <td><div class="row"><button class="btn" data-oed="${o.id}">Edytuj</button>${genBtn}${replanOneBtn}<button class="btn red" data-od="${o.id}">Usuń</button></div></td>`;
      host.appendChild(tr);
    });
  }

  // Mini-Gantt v1 (z wierszem niezaplanowanych + widoczne dni wolne)
  function renderGantt(){
    const host = qs('#gantt-container'); if(!host) return;
    const all = (state.tasks||[]).slice();
    const scheduled = all.filter(t=>t.startPlanned && t.endPlanned);
    const unplanned = all.filter(t=>!(t.startPlanned && t.endPlanned));
    if(!scheduled.length && !unplanned.length){ host.innerHTML='<div class="muted">Brak zadań</div>'; return; }
    const minStart = scheduled.length ? Math.min(...scheduled.map(t=>t.startPlanned)) : Date.now();
    const maxEnd = scheduled.length ? Math.max(...scheduled.map(t=>t.endPlanned)) : (minStart + 8*3600*1000);
    
    // Rozszerz zakres o kilka dni wstecz aby pokazać weekend przed pierwszymi zadaniami
    const expandedStart = minStart - (3 * 24*3600*1000); // 3 dni wstecz
    const expandedEnd = maxEnd + (2 * 24*3600*1000); // 2 dni naprzód
    const dayMs = 24*3600*1000;
    const days = Math.max(1, Math.ceil((expandedEnd - expandedStart)/dayMs));
    
    // Pobierz konfigurację dni wolnych
    const off = new Set(((state.scheduleConfig&&state.scheduleConfig.offWeekdays)||[]).map(Number));
    const holidays = new Set(((state.scheduleConfig&&state.scheduleConfig.holidays)||[]));
    
    let html = '<div style="position:relative;">';
    html += '<div style="display:flex;margin-bottom:4px">'+Array.from({length:days}).map((_,i)=>{
      const d=new Date(expandedStart + i*dayMs); 
      const y=d.getFullYear(); const m=(d.getMonth()+1+'').padStart(2,'0'); const dayNum=(d.getDate()+'').padStart(2,'0'); const key=`${y}-${m}-${dayNum}`;
      const isOff = off.has(d.getDay()) || holidays.has(key);
      const bgStyle = isOff ? 'background:repeating-linear-gradient(45deg,#2d1b34,#2d1b34 4px,#1e293b 4px,#1e293b 8px);opacity:0.7;' : 'background:#0f172a;';
      const title = isOff ? 'title="Dzień wolny - brak zadań"' : '';
      return `<div style=\"flex:0 0 160px;border-right:1px solid #1e293b;padding:2px 4px;${bgStyle}color:#94a3b8\" ${title}>${d.toLocaleDateString()}</div>`; 
    }).join('')+'</div>';
    const byOrder = {};
    scheduled.forEach(t=>{ (byOrder[t.orderId]||(byOrder[t.orderId]=[])).push(t); });
    Object.keys(byOrder).forEach(oid=>{
      const orderName = (state.orders||[]).find(o=>o.id===oid)?.name || oid;
      html += `<div style=\"display:flex;align-items:stretch;margin-bottom:2px;\">`;
      html += `<div style=\"position:sticky;left:0;z-index:2;background:#0b1222;border:1px solid #1e293b;min-width:120px;padding:2px 4px;color:#e2e8f0;font-weight:600\">${orderName}</div>`;
      html += `<div style=\"display:flex;position:relative;\">`;
      const rowTasks = byOrder[oid].sort((a,b)=>a.startPlanned-b.startPlanned);
      rowTasks.forEach(t=>{
        const offsetDays=(t.startPlanned-expandedStart)/dayMs; // Użyj expandedStart zamiast minStart
        const spanDays=(t.endPlanned-t.startPlanned)/dayMs;
        const left=offsetDays*160;
        const width=Math.max(6, spanDays*160 - 4);
        const crit=t.critical?'box-shadow:0 0 0 2px #dc2626 inset;':'';
        const tip=`${t.name||t.opName||''}\n${new Date(t.startPlanned).toLocaleString()} -> ${new Date(t.endPlanned).toLocaleString()}\nStatus: ${t.status||'-'}\nCzas: ${(t.estMin||t.duration||0)} min`;
        html += `<div title=\"${tip}\" style=\"position:absolute;left:${left}px;width:${width}px;height:18px;background:linear-gradient(90deg,#3b82f6,#06b6d4);border-radius:4px;border:1px solid #1e293b;${crit}overflow:hidden;\"></div>`;
      });
      for(let d=0; d<days; d++){ const gx=d*160; html += `<div style=\"position:absolute;left:${gx}px;top:0;bottom:0;width:160px;border-right:1px solid #1e293b;pointer-events:none\"></div>`; }
      html += `</div>`;
      html += `</div>`;
    });
    if(unplanned.length){
      html += `<div style=\"display:flex;align-items:stretch;margin-top:4px;\">`;
      html += `<div style=\"position:sticky;left:0;z-index:2;background:#0b1222;border:1px solid #1e293b;min-width:120px;padding:2px 4px;color:#fbbf24;font-weight:600\">(Niezaplanowane)</div>`;
      html += `<div style=\"display:flex;flex-wrap:wrap;gap:4px;padding:2px 4px;max-width:calc(160px*${days});\">`;
      unplanned.slice(0,200).forEach(t=>{ const label=(t.name||t.opName||'Zadanie').slice(0,24); const tip=`${t.name||t.opName||''}\nStatus: ${t.status||'-'}\nCzas: ${(t.estMin||t.duration||0)} min`; html += `<div title=\"${tip}\" style=\"background:#334155;color:#e2e8f0;font-size:11px;padding:2px 6px;border-radius:4px;border:1px solid #1e293b;\">${label}</div>`; });
      if(unplanned.length>200){ html += `<div style=\"font-size:11px;color:#94a3b8\">+${unplanned.length-200} więcej...</div>`; }
      html += `</div></div>`;
    }
    html += '</div>';
    host.innerHTML=html;
  }

  function updateScheduleConfigFromUI(){
    try{
      const wh = parseInt(qs('#sched-start')?.value||'8',10);
      const wl = parseInt(qs('#sched-len')?.value||'8',10);
      const offWeekdays = Array.from(document.querySelectorAll('.sched-offday:checked')).map(cb=>Number(cb.value));
      const holidaysRaw = (qs('#sched-holidays')?.value||'').split(/[\,\n]/).map(s=>s.trim()).filter(s=>/^\d{4}-\d{2}-\d{2}$/.test(s));
      state.scheduleConfig = { workdayStartHour: wh, workdayLengthHours: wl, offWeekdays, holidays: holidaysRaw };
      (window.logDev||console.log)('[scheduleConfig] updated', state.scheduleConfig);
    }catch(e){ console.warn('updateScheduleConfigFromUI error', e.message); }
  }

  // Szybkie przyciski wyboru dni wolnych
  function initOffdaysQuickButtons(){
    const weekendBtn = document.getElementById('btn-offdays-weekend');
    const workweekBtn = document.getElementById('btn-offdays-workweek');
    const clearBtn = document.getElementById('btn-offdays-clear');
    if(!weekendBtn) return; // UI nie istnieje jeszcze
    const all = Array.from(document.querySelectorAll('.sched-offday'));
    const setChecked = (values)=>{
      const set = new Set(values);
      all.forEach(cb=>{ cb.checked = set.has(Number(cb.value)); });
      updateScheduleConfigFromUI();
    };
    weekendBtn.addEventListener('click', ()=> setChecked([6,0]));
    workweekBtn.addEventListener('click', ()=> setChecked([])); // Czyść dni wolne dla dni roboczych (Pn-Pt)
    clearBtn.addEventListener('click', ()=> setChecked([]));
  }

  function computeOrderProgress(orderId){
    const tasks = (state.tasks||[]).filter(t=>t.orderId === orderId);
    const total = tasks.length;
    const done = tasks.filter(t=>t.status === 'done').length;
    const run = tasks.filter(t=>t.status === 'run').length;
    const todo = tasks.filter(t=>t.status === 'todo').length;
    const pct = total ? Math.round((done + run*0.5) / total * 100) : 0;
    return {total, done, run, todo, pct};
  }

  function updateOrderProgress(orderId){
    try{ const o = (state.orders||[]).find(x=>x.id===orderId); if(!o) return; o.progress = computeOrderProgress(orderId); save(); }catch(_){ }
  }
  qs('#order-form').addEventListener('submit',(ev)=>{
    ev.preventDefault();
    const t0 = performance.now();
    try {
      (window.logDev||console.log)('[order-form] submit start');
      const validationErrors = validateOrderForm();
      if (validationErrors.length > 0) {
        (window.logDev||console.log)('[order-form] validation errors', validationErrors);
        showValidationErrors(validationErrors);
        return;
      }
      const id = (qs('#o-id').value || '').trim();
      const nr=(qs('#o-name').value||'').trim(); if(!nr){ (window.logDev||console.log)('[order-form] brak nazwy'); return; }
      const beforeLen = (state.orders||[]).length;
      const orderObj={id:id||uid(),name:nr,client:qs('#o-client').value||'',model:qs('#o-model').value||'',quantity:parseInt(qs('#o-qty').value||'1',10),
        startDate:qs('#o-start').value||'',endDate:qs('#o-end').value||'',installDate:qs('#o-install').value||'',
        address:qs('#o-addr').value||'',postalCode:qs('#o-post').value||'',phone:qs('#o-phone').value||'',notes:qs('#o-notes').value||'',
        processId:qs('#o-proc').value||''};
      if(id){
        const existing = state.orders.find(x=>x.id===id);
        if(existing){ Object.assign(existing, orderObj); (window.logDev||console.log)('[order-form] updated', id); }
      } else {
        orderObj.tasksGenerated = false;
        state.orders.push(orderObj);
        (window.logDev||console.log)('[order-form] inserted new order', orderObj.id, 'len=', state.orders.length);
        try{
          const afterEntry = { id: uid(), type:'montaż', order: orderObj.id, status:'nowe', desc: orderObj.notes, installDate: orderObj.installDate, departTime:'', visitTime:'', phone: orderObj.phone, postalCode: orderObj.postalCode, address: orderObj.address };
          state.after.push(afterEntry);
        }catch(e){ console.warn('[order-form] after push error', e.message); }
        try{
          if(window.scheduleCore){
            const gen = window.scheduleCore.generateTasksForOrder(orderObj, state);
            if(gen && gen.length){
              state.tasks = (state.tasks||[]).concat(gen);
              if(typeof updateScheduleConfigFromUI === 'function'){ updateScheduleConfigFromUI(); }
              window.scheduleCore.generateSchedule(state);
              orderObj.tasksGenerated = true;
              (window.logDev||console.log)('[order-form] auto tasks', gen.length);
            }
          }
        }catch(e){ console.warn('[order-form] auto generate tasks error', e.message); }
      }
      const afterLen = (state.orders||[]).length;
      if(!id && afterLen === beforeLen){ console.warn('[order-form] liczba zleceń nie wzrosła!'); }
      maybeAutoSave('order-save');
      save();
      // Podsumowanie skutków zapisu
      const genTasksForOrder = (state.tasks||[]).filter(t=>t.orderId === orderObj.id);
      (window.logDev||console.log)('[order-form] summary', {
        orderId: orderObj.id,
        tasksGeneratedFlag: orderObj.tasksGenerated,
        tasksCount: genTasksForOrder.length,
        firstTask: genTasksForOrder[0] && {id:genTasksForOrder[0].id, op:genTasksForOrder[0].operationId, start:genTasksForOrder[0].startPlanned, end:genTasksForOrder[0].endPlanned}
      });
      if(orderObj.tasksGenerated && !genTasksForOrder.length){
        console.warn('[order-form] tasksGenerated=true ale brak tasków w state.tasks dla order', orderObj.id);
      }
      // Czy harmonogram ma start/end
      const scheduled = genTasksForOrder.filter(t=>t.startPlanned && t.endPlanned).length;
      if(orderObj.tasksGenerated && scheduled === 0){
        console.warn('[order-form] brak zaplanowanych czasów (startPlanned)');
      }
      ev.target.reset(); const hid = qs('#o-id'); if(hid) hid.value='';
      renderOrderPage(); renderASPage(); renderDash(window.state||state); renderGantt();
      const msg = id ? 'Zlecenie zaktualizowane.' : (orderObj.tasksGenerated ? 'Zlecenie zapisane i wygenerowano '+genTasksForOrder.length+' zadań.' : 'Zlecenie zapisane (brak zadań – sprawdź katalog operacji).');
      const feed = qs('#order-feedback');
      if(feed){ feed.textContent = msg; feed.className='ok'; setTimeout(()=>{ if(feed.textContent===msg) feed.textContent=''; }, 6000); }
      else { (window.logDev||console.log)('[order-form] feedback', msg); }
      (window.logDev||console.log)('[order-form] done in', (performance.now()-t0).toFixed(1)+'ms');
    } catch(err){
      console.error('[order-form] fatal', err); alert('Błąd zapisu zlecenia: '+(err.message||err));
    }
  });
  // Delegacja kliknięć - generowanie zadań na żądanie
  document.addEventListener('click', (ev)=>{
    const genBtn = ev.target.closest('[data-ogen]');
    const replanBtn = ev.target.closest('[data-replan-order]');
    if(!genBtn && !replanBtn) return;
    if(genBtn){
      const oid = genBtn.getAttribute('data-ogen');
      const order = (state.orders||[]).find(o=>o.id===oid);
      if(!order){ alert('Nie znaleziono zamówienia'); return; }
      if(order.tasksGenerated){ alert('Zadania już zostały wygenerowane dla tego zamówienia.'); return; }
      try{
        if(window.scheduleCore){
          if(typeof updateScheduleConfigFromUI==='function') updateScheduleConfigFromUI();
          const gen = window.scheduleCore.generateTasksForOrder(order, state);
          if(gen && gen.length){
            state.tasks = state.tasks.concat(gen);
            window.scheduleCore.generateSchedule(state);
            order.tasksGenerated = true;
            save();
            renderDash(window.state||state); renderGantt();
            renderOrderPage();
            alert('Wygenerowano '+gen.length+' zadań.');
          } else { alert('Brak operacji do wygenerowania.'); }
        }
      }catch(e){ alert('Błąd generowania: '+e.message); }
      return;
    }
    if(replanBtn){
      const oid = replanBtn.getAttribute('data-replan-order');
      if(!window.scheduleCore) return;
      if(typeof updateScheduleConfigFromUI==='function') updateScheduleConfigFromUI();
      if(!confirm('Przeliczyć od nowa zadania tego zlecenia?')) return;
      window.scheduleCore.generateSchedule(state,{force:true, onlyOrderId: oid});
      save(); renderGantt(); renderOrderPage();
      (window.logDev||console.log)('[replan] single order', oid);
    }
  });
  
  function populateOpEmployees(){
    const sel=qs('#op-emp'); if(!sel) return;
    const keep=new Set(Array.from(sel.selectedOptions||[]).map(o=>o.value));
    sel.innerHTML='';
    (state.employees||[]).forEach(e=>{const o=document.createElement('option');o.value=e.id;o.textContent=e.name||e.id;if(keep.has(e.id))o.selected=true;sel.appendChild(o);});
  }
  // Normalize operation numbers (ensure sequential no = 1..N sorted by no)
  function normalizeOpNumbers() {
    state.operationsCatalog = (state.operationsCatalog || []).slice().sort((a,b)=>(a.no||0)-(b.no||0)).map((o,i)=>{ o.no = i+1; return o; });
  }

  // Move operation by id up/down in the ordered list
  function moveOp(id, dir){
    const arr = (state.operationsCatalog || []).slice().sort((a,b)=>(a.no||0)-(b.no||0));
    const idx = arr.findIndex(x=>x.id===id);
    if(idx === -1) return;
    const newIdx = dir === 'up' ? Math.max(0, idx-1) : Math.min(arr.length-1, idx+1);
    if(newIdx === idx) return;
    const [item] = arr.splice(idx,1);
    arr.splice(newIdx,0,item);
    arr.forEach((o,i)=>o.no = i+1);
    state.operationsCatalog = arr;
    save(); renderOps();
  }
  function renderOps(){
    populateOpEmployees();
    const tb=qs('#op-tb'); if(!tb) return; tb.innerHTML='';
    // populate component selector with unique components
    const compSel = qs('#op-comp-select'); if(compSel){
      const comps = new Set(); (state.operationsCatalog||[]).forEach(op=>{(op.skills||[]).forEach(s=>comps.add(s.trim()));});
      const prev = compSel.value || '';
      compSel.innerHTML = '<option value="">— wybierz komponent —</option>' + Array.from(comps).filter(Boolean).sort().map(c=>`<option value="${c}">${c}</option>`).join('');
      if(prev) compSel.value = prev;
    }

    (state.operationsCatalog||[]).slice().sort((a,b)=>(a.no||0)-(b.no||0)).forEach((o,idx,arr)=>{
      const ass=(o.defaultAssignees||[]).map(a=>a.name).join(', ')||'-';
      const tr=document.createElement('tr');
      tr.innerHTML=`<td>${o.no||0}</td><td>${o.name||''}</td><td>${o.time||0}</td><td>${o.workers||1}</td>
                    <td>${(o.skills||[]).join(', ')}</td><td>${ass}</td>
                    <td>
                      <div class="row">
                        <button class="btn" data-op-up="${o.id}" ${idx===0?"disabled":""}>↑</button>
                        <button class="btn" data-op-down="${o.id}" ${idx===arr.length-1?"disabled":""}>↓</button>
                        <button class="btn" data-op-ed="${o.id}">Edytuj</button>
                        <button class="btn red" data-op-del="${o.id}">Usuń</button>
                      </div>
                    </td>`;
      tb.appendChild(tr);
    });
    qs('#op-count').textContent=String((state.operationsCatalog||[]).length);
    const sel=qs('#proc-op-select'); if(sel){ sel.innerHTML=''; (state.operationsCatalog||[]).forEach(o=>{ const opt=document.createElement('option'); opt.value=o.id; opt.textContent=(o.no||0)+'. '+o.name+' ('+(o.time||0)+'m)'; sel.appendChild(opt); }); }
  }
  // sort operations by whether they contain a selected component (selected first), then keep rest, normalize numbers
  function sortByComponent(component){
    if(!component) return;
    const ops = (state.operationsCatalog||[]).slice();
    const match = [];
    const rest = [];
    ops.forEach(o=>{ if((o.skills||[]).map(s=>s.toLowerCase()).indexOf(component.toLowerCase())!==-1) match.push(o); else rest.push(o); });
    const res = match.concat(rest);
    res.forEach((o,i)=>o.no = i+1);
    state.operationsCatalog = res; save(); renderOps();
  }
  // normalize numbers to 1..N (already provided as normalizeOpNumbers)
  // sort operations alphabetically by name
  function sortOpsAZ(){
    const ops = (state.operationsCatalog||[]).slice().sort((a,b)=>{ const A=(a.name||'').toLowerCase(); const B=(b.name||'').toLowerCase(); return A.localeCompare(B); });
    ops.forEach((o,i)=>o.no = i+1);
    state.operationsCatalog = ops; save(); renderOps();
  }

  // wire buttons
  const opNormalizeBtn = qs('#op-normalize'); if(opNormalizeBtn){ opNormalizeBtn.addEventListener('click', ()=>{ normalizeOpNumbers(); save(); renderOps(); }); }
  const opSortBtn = qs('#op-sort-az'); if(opSortBtn){ opSortBtn.addEventListener('click', ()=>{ sortOpsAZ(); }); }
  const opSortCompBtn = qs('#op-sort-comp'); if(opSortCompBtn){ opSortCompBtn.addEventListener('click', ()=>{ const sel = qs('#op-comp-select'); if(sel) sortByComponent(sel.value); }); }
  const opSaveDbBtn = qs('#op-save-db'); if(opSaveDbBtn){ opSaveDbBtn.addEventListener('click', async ()=>{
    try{
      if(!(state.storage.mode==='firebase' && await ensureFirebase())){ alert('Firebase nie jest skonfigurowany/aktywowany. Nie można zapisać do DB.'); return; }
      const col = fbRoot().collection('operationsCatalog');
      for(const op of (state.operationsCatalog||[])){
        try{ await col.doc(op.id).set(JSON.parse(JSON.stringify(op)),{merge:true}); }catch(e){ console.warn('Błąd zapisu op:', e.message); }
      }
      alert('Zapisano katalog operacji do DB.');
    }catch(e){ console.warn('saveAllOpsToDB error', e); alert('Błąd: ' + (e.message||e)); }
  }); }
  qs('#op-form').addEventListener('submit', async (ev)=>{
    ev.preventDefault();
    const msg=(t,ok=false)=>{const el=qs('#op-msg'); if(el){el.textContent=t||''; el.className='muted '+(ok?'oktxt':'err');}};
    const submitBtn = ev.target.querySelector('button[type="submit"]');
    if(submitBtn) submitBtn.disabled = true;
    try{
      const rawOpId = (qs('#op-id').value||'').trim();
      console.log('[op-form] submit start', { rawOpId });
      const name=(qs('#op-name').value||'').trim();
      const no=toInt(qs('#op-no').value, 1);
      const time=toInt(qs('#op-time').value, 10);
      const workers=toInt(qs('#op-workers').value, 1);
      const skills=(qs('#op-skills').value||'').split(';').map(s=>s.trim()).filter(Boolean);
      const sel=qs('#op-emp'); const assIds=Array.from(sel.selectedOptions||[]).map(o=>o.value);
      const ass=assIds.map(v=>{const e=(state.employees||[]).find(x=>x.id===v); return e?{id:e.id,name:e.name}:null;}).filter(Boolean);
      if(!name){msg('Podaj nazwę operacji.'); if(submitBtn) submitBtn.disabled = false; return;}
      if(!(time>=1)){msg('Czas [min] musi być ≥ 1.'); if(submitBtn) submitBtn.disabled = false; return;}
      if(!(workers>=1)){msg('Domyślna liczba pracowników musi być ≥ 1.'); if(submitBtn) submitBtn.disabled = false; return;}

  // use in-memory state snapshot (avoid reading localStorage here to prevent overwriting recent in-memory edits)
  state._inOpEdit = true;

      // operate on a shallow copy
      const ops = (state.operationsCatalog||[]).slice();
      const existingIdx = rawOpId ? ops.findIndex(x=> x.id === rawOpId) : -1;
      const isUpdate = existingIdx >= 0;
      console.log('[op-form] isUpdate?', isUpdate, 'existingIdx', existingIdx);
      const id = isUpdate ? rawOpId : uid();
      const payload = { id, no, name, time, workers, skills, defaultAssignees: ass };

      if(isUpdate){
        // update only the specific operation by id (preserve other fields)
        const existingOp = ops[existingIdx] || {};
        const merged = Object.assign({}, existingOp, payload);
        ops.splice(existingIdx, 1, merged);
        msg('Zaktualizowano operację.', true);
      } else {
        // always INSERT when no op-id provided — never replace existing items even if names collide
        const insertAt = Math.max(0, Math.min(no-1, ops.length));
        ops.splice(insertAt, 0, payload);
        msg('Dodano nową operację.', true);
      }

      // Persist our ops array directly into state to avoid accidental drops during
      // rapid consecutive inserts. Reindex sequentially and keep the ops order.
      try{
        ops.forEach((o,i)=>o.no = i+1);
        state.operationsCatalog = ops;
      }catch(_){ ops.forEach((o,i)=>o.no=i+1); state.operationsCatalog = ops; }

      try{ localStorage.setItem(storeKey, JSON.stringify(state)); }catch(_){ }
      save(); renderOps();
      // DEVLOG: snapshot after submit — last 3 operations and total length
      try{
        const all = (state.operationsCatalog||[]).slice().sort((a,b)=>(a.no||0)-(b.no||0));
        const last3 = all.slice(-3).map(o=>({id:o.id,name:o.name,no:o.no}));
        (window.logDev||console.log)('[op-form] post-submit snapshot', { total: all.length, last3 });
        const infoEl = qs('#set-info'); if(infoEl) infoEl.textContent = `Ops:${all.length} last:${ last3.map(x=>x.name).join(', ') }`;
      }catch(e){ (window.logDev||console.log)('[op-form] post-submit debug error', e && e.message); }
      try{ if(state.storage.mode==='firebase' && await ensureFirebase()){ await fbRoot().collection('operationsCatalog').doc(id).set(JSON.parse(JSON.stringify(payload)),{merge:true}); } }catch(e){ console.warn('Błąd zapisu operacji:', e && e.message); }
  // after save (insert or update): reset form and clear op-id so UI is clean
  try{ ev.target.reset(); }catch(_){ }
  if(qs('#op-id')) qs('#op-id').value = '';
  populateOpEmployees && populateOpEmployees();
  state._inOpEdit = false;
    }catch(e){ console.log('[op-form] submit error', e && e.message); if(qs('#op-msg')) qs('#op-msg').textContent='Błąd zapisu'; state._inOpEdit = false; }
    if(submitBtn) submitBtn.disabled = false;
  });

  function renderProcOps(){
    const box=qs('#proc-ops'); box.innerHTML='';
    (state.PROC_TMP||[]).forEach((op,i)=>{
      const d=document.createElement('div'); d.className='card';
      const empArr = (state.employees||[]).slice();
      if(op.assignee && op.assignee.id && !empArr.some(e=>e.id===op.assignee.id)){
        empArr.unshift({id:op.assignee.id, name: op.assignee.name || op.assignee.id});
      }
      const empOptions = empArr.map(e=>`<option value="${e.id}">${e.name}</option>`).join('');
  d.innerHTML = '<div class="row" style="justify-content:space-between"><div>'+op.name+' <span class="muted">('+(op.time||0)+'m)</span></div>'+
        '<div class="row"><select data-pass>'+ '<option value="">— przypisz pracownika —</option>'+ empOptions +'</select>'+
        ' <button class="btn small" data-clear-ass="'+i+'">Usuń przypisanie</button>'+
        ' <button class="btn" data-pup="'+i+'">↑</button><button class="btn" data-pdown="'+i+'">↓</button><button class="btn red" data-pdel="'+i+'">Usuń</button></div></div>';
      box.appendChild(d);
      const sel = d.querySelector('select[data-pass]');
      if(sel){
        if(op.assignee && op.assignee.id) sel.value = op.assignee.id;
        sel.addEventListener('change', ()=>{
          const val = sel.value;
          if(!val) state.PROC_TMP[i].assignee = null;
          else { const emp = (state.employees||[]).find(x=>x.id===val); state.PROC_TMP[i].assignee = emp?{id:emp.id,name:emp.name}:null; }
          save();
        });
        // clear assignment button
        const clr = d.querySelector('[data-clear-ass]'); if(clr){ clr.addEventListener('click', ()=>{ state.PROC_TMP[i].assignee = null; if(sel) sel.value = ''; save(); renderProcOps(); }); }
      }
    });
  }
  function renderProcList(){ const box=qs('#proc-list'); box.innerHTML=''; (state.processes||[]).forEach(p=>{ const assigned = Array.from(new Set((p.operations||[]).map(o=>o.assignee && o.assignee.name).filter(Boolean))); const assText = assigned.length?(' • pracownicy: '+assigned.join(', ')) : ''; const d=document.createElement('div'); d.className='card'; d.innerHTML='<div class="row" style="justify-content:space-between"><div><b>'+p.name+'</b>'+assText+' • operacji: '+((p.operations||[]).length||0)+'</div><div class="row"><button class="btn" data-ped="'+p.id+'">Edytuj</button> <button class="btn red" data-pdel2="'+p.id+'">Usuń</button></div></div>'; box.appendChild(d); }); qs('#proc-count').textContent=String((state.processes||[]).length); }
  function renderProcPage(){ const sel=qs('#proc-op-select'); if(sel){ sel.innerHTML=''; (state.operationsCatalog||[]).forEach(o=>{ const opt=document.createElement('option'); opt.value=o.id; opt.textContent=(o.no||0)+'. '+o.name+' ('+(o.time||0)+'m)'; sel.appendChild(opt); }); } renderProcOps(); renderProcList(); }
  qs('#proc-add-op').addEventListener('click',()=>{ const id=qs('#proc-op-select').value; const o=state.operationsCatalog.find(x=>x.id===id); if(o){
    let initialAssignee = null;
    if(Array.isArray(o.defaultAssignees) && o.defaultAssignees.length){ const da = o.defaultAssignees[0]; if(da && (da.id || da.name)){ const emp = (state.employees||[]).find(e=>e.id===da.id); if(emp) initialAssignee = { id: emp.id, name: emp.name }; else if(da.id) initialAssignee = { id: da.id, name: da.name || da.id }; else if(da.name) initialAssignee = { id: uid(), name: da.name }; } }
    state.PROC_TMP.push({name:o.name,time:o.time||0, assignee: initialAssignee}); renderProcOps(); save(); } });
  
  qs('#proc-form').addEventListener('submit',(ev)=>{
    ev.preventDefault(); const id=qs('#proc-id').value||uid(); const name=(qs('#proc-name').value||'').trim(); if(!name||(state.PROC_TMP||[]).length===0) return;
    const payload={id,name,operations:(state.PROC_TMP||[]).map(op=>({name:op.name,time:op.time||0, assignee: op.assignee || null}))};
    const ex=state.processes.find(x=>x.id===id); if(ex) Object.assign(ex,payload); else state.processes.push(payload);
    state.PROC_TMP=[]; save(); ev.target.reset(); renderProcPage();
  });

  function renderTasks(){
    const list=qs('#tasks-list'); if(!list) return; list.innerHTML='';
    const selOrd=qs('#tasks-filter-order'); if(selOrd){ selOrd.innerHTML='<option value="">Wszystkie zlecenia</option>'+ (state.orders||[]).map(o=>`<option value="${o.id}">${o.name}</option>`).join(''); }
    const fOrd=qs('#tasks-filter-order')?.value||''; const fSt=qs('#tasks-filter-status')?.value||'';
    const rows=(state.tasks||[]).filter(t=>(!fOrd||t.orderId===fOrd)&&(!fSt||(t.status||'')===fSt));
    qs('#tasks-count').textContent=String(rows.length);
    
    // Dodaj przycisk do masowego usuwania na górze listy
    const controlsDiv = document.createElement('div');
    controlsDiv.className = 'row';
    controlsDiv.style.justifyContent = 'flex-end';
    controlsDiv.style.marginBottom = '12px';
    controlsDiv.innerHTML = `
      <button class="btn red" id="mass-delete-tasks" ${rows.length ? '' : 'disabled'}>
        Usuń wszystkie wyświetlone zadania (${rows.length})
      </button>
    `;
    list.appendChild(controlsDiv);
    
    // Dodaj obsługę przycisku
    const massDeleteBtn = qs('#mass-delete-tasks');
    if(massDeleteBtn) {
      massDeleteBtn.addEventListener('click', () => {
        if(confirm(`Czy na pewno chcesz usunąć ${rows.length} zadań? Ta operacja jest nieodwracalna.`)) {
          const idsToDelete = rows.map(t => t.id);
          state.tasks = (state.tasks || []).filter(t => !idsToDelete.includes(t.id));
          save();
          renderTasks();
          setInfoText('Usunięto ' + rows.length + ' zadań', 'success');
        }
      });
    }
    // helper for sync badge
    const syncBadge = (tt)=>{ try{ if(tt._syncPending) return `<span class="task-sync-status pending" title="Czekaj na synchronizację">⏳</span>`; if(tt._syncError) return `<span class="task-sync-status error" title="Błąd synchronizacji">⚠️</span>`; if(tt._lastSync) return `<span class="task-sync-status ok" title="Ostatnia synchronizacja: ${new Date(tt._lastSync).toLocaleString()}">✔️</span>`; return `<span class="task-sync-status unknown" title="Brak synchronizacji">—</span>`; }catch(e){return''} };
    rows.forEach(t=>{
      const d=document.createElement('div'); d.className='card';
      const sb = syncBadge(t);
      const startP = t.startPlanned ? new Date(t.startPlanned).toLocaleString() : '-';
      const endP = t.endPlanned ? new Date(t.endPlanned).toLocaleString() : '-';
      const plannedDur = (t.startPlanned && t.endPlanned) ? Math.round((t.endPlanned - t.startPlanned)/60000)+'m' : '-';
      d.innerHTML=`<div class="row" style="justify-content:space-between">
        <div>
          <b>${t.opName||t.name||'(zadanie)'} ${sb}</b> 
          <span class="muted">
            ${(state.orders||[]).find(o=>o.id===t.orderId)?.name||'-'}
            ${t.processName ? ` • Proces: ${t.processName} (${t.opIndex + 1}/${(state.processes.find(p=>p.id===t.processId)?.operations||[]).length})` : ''}
          </span>
          <div class="muted">Status: ${t.status||'todo'} • Plan: ${plannedDur} • Real: ${Math.round(t.elapsedMin||0)}m ${typeof t.slackMs==='number'?('• Slack: '+Math.round(t.slackMs/60000)+'m'):''} ${t.critical?'• CRITICAL':''}</div>
        <div class="muted">StartP: ${startP} • EndP: ${endP}</div>
        <div class="muted">${t.startedBy?('Rozpoczął: '+t.startedBy):''} ${t.closedBy?('Zamknął: '+t.closedBy):''} ${t.startedAt?(' • start: '+(new Date(t.startedAt)).toLocaleTimeString()):''}</div></div>
        <div class="row">
          ${/* start button green when running */''}
          <button class="${t.status==='run'?'btn green':'btn gray'}" data-task-start="${t.id}" ${t.status==='run'?'disabled':''}>Start</button>
          <button class="btn" data-task-pause="${t.id}" ${t.status!=='run'?'disabled':''}>Pauza</button>
          <button class="btn amber" data-task-repeat="${t.id}">Powtórz</button>
          <button class="${t.status==='done'?'btn green':'btn gray'}" data-task-done="${t.id}" ${t.status==='done'?'disabled':''}>Zamknij</button>
          ${t._syncError?`<button class="btn amber" data-task-retry="${t.id}" title="Ponów synchronizację">Retry</button>`:''}
        </div></div>`;
      list.appendChild(d);
    });
    const byW = qs('#tasks-by-worker'); if(byW) byW.innerHTML = '';
    // small HTML escape helper for safe insertion into innerHTML - delegate to appHelpers when available
    function escapeHtml(s){
      try{ if(window.appHelpers && typeof window.appHelpers.escapeHtml === 'function') return window.appHelpers.escapeHtml(s); }catch(_){ }
      if(s == null) return '';
      try{ return window.escapeHtml ? window.escapeHtml(s) : String(s).replace(/[&<>"']/g, function(c){ return {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[c]; }); }catch(_){ return String(s); }
    }
    try{ window.escapeHtml = escapeHtml; }catch(_){ }
  }

  // If an order has no remaining active tasks (todo/run), remove all tasks linked to that order from state.tasks
  function cleanupTasksForOrder(orderId){
    try{
      // respect settings: if autoCleanup explicitly disabled, skip
      if(state.settings && state.settings.autoCleanup === false){ (window.logDev||console.log)('[cleanupTasksForOrder] skipped due to settings.autoCleanup=false for', orderId); return; }
      const tasks = (state.tasks||[]).filter(t=>t.orderId===orderId);
      if(tasks.length===0) return; // nothing to do
      const anyActive = tasks.some(t=> (t.status||'') !== 'done');
      if(!anyActive){
        // remove tasks belonging to this order
        state.tasks = (state.tasks||[]).filter(t=> t.orderId !== orderId);
        save(); try{ renderTasks(); renderMonitor && renderMonitor(); }catch(_){ }
        (window.logDev||console.log)('[cleanupTasksForOrder] removed tasks for order', orderId);
      }
    }catch(e){ (window.logDev||console.log)('[cleanupTasksForOrder] error', e && e.message); }
  }

  function generateTasksByWorker(){
    showReportsProgress(true, 'Przetwarzanie danych pracowników...', 20);
    
    setTimeout(() => {
      const container = qs('#tasks-by-worker'); if(!container) return;
      container.innerHTML = '';
      (window.logDev||console.log)('[generateTasksByWorker] start');
      const map = new Map();
      const empLookup = new Map((state.employees||[]).map(e=>[e.id, e]));
      
      showReportsProgress(true, 'Analizowanie zadań...', 40);
      
      setTimeout(() => {
        showReportsProgress(true, 'Przetwarzanie zadań...', 60);
        
        setTimeout(() => {
          // Pokaż tylko aktywne zadania (te które są w state.tasks)
          (state.tasks||[]).forEach(t=>{
            const order = (state.orders||[]).find(o => o.id === t.orderId);
            // Pokaż zadanie tylko jeśli ma przypisanych pracowników i jest powiązane z aktywnym zleceniem
            if (order) {
              const as = t.assignees || (t.assignee ? [t.assignee] : []);
              if (Array.isArray(as) && as.length) {
                as.forEach(a => {
                  const id = a.id || a;
                  const name = a.name || (empLookup.get(id)||{}).name || id;
                  if (!map.has(id)) {
                    map.set(id, {id, name, tasks: []});
                  }
                  map.get(id).tasks.push({
                    orderId: t.orderId,
                    orderName: order.name,
                    opName: t.opName,
                    process: order.name,
                    time: t.estMin || t.elapsedMin || 0,
                    status: t.status || 'todo'
                  });
                });
              }
            }
          });
          
          showReportsProgress(true, 'Renderowanie wyników...', 80);
          
          setTimeout(() => {
            if(map.size===0){ container.innerHTML = '<div class="muted">Brak przypisań do pracowników (brak assignee). Upewnij się, że procesy mają przypisanych pracowników.</div>'; showReportsProgress(false); return; }
            (window.logDev||console.log)('[generateTasksByWorker] map keys', Array.from(map.keys()), 'size', map.size);
            Array.from(map.values()).sort((a,b)=>a.name.localeCompare(b.name)).forEach(w=>{
              (window.logDev||console.log)('[generateTasksByWorker] worker', w.id, w.name, 'tasks:', JSON.parse(JSON.stringify(w.tasks)));
              const card = document.createElement('div'); card.className='card';
              let listItems = '';
              try{
                listItems = w.tasks.map(t=>{
                  const orderLabel = t.orderId ? (t.orderName ? `${t.orderName} (${t.orderId})` : t.orderId) : (t.process || '-');
                  return `<li><strong>${escapeHtml(orderLabel)}</strong> — ${escapeHtml(t.opName||'(zadanie)')} <span class="muted">• ${escapeHtml(t.process||'')}</span> <span class="pill">${t.time}m</span></li>`;
                }).join('');
              }catch(err){ (window.logDev||console.log)('[generateTasksByWorker] listItems render error', err && err.message); listItems = `<li class="err">Błąd renderowania: ${err && (err.message||err)}</li>`; }
              const ul = `<ul class="emp-tasks-list" style="margin:8px 0;padding-left:18px">${listItems}</ul>`;
              card.innerHTML = `<div class="row" style="justify-content:space-between"><div><b>${w.name}</b><div class="muted">Zadań: ${w.tasks.length}</div></div><div class="row"><button class="btn" data-export-emp="${w.id}">Eksport CSV</button> <button class="btn blue" data-send-emp="${w.id}">Wyślij</button></div></div>${ul}`;
              container.appendChild(card);
              (window.logDev||console.log)('[generateTasksByWorker] appended card innerText', (container && container.innerText)? container.innerText.slice(0,200) : '<empty>');
            });
            container.querySelectorAll('[data-export-emp]').forEach(btn=>btn.addEventListener('click', ()=>{ const id = btn.getAttribute('data-export-emp'); exportCSVForEmployee(id); }));
            container.querySelectorAll('[data-send-emp]').forEach(btn=>btn.addEventListener('click', ()=>{ const id = btn.getAttribute('data-send-emp'); const txt = buildEmployeeText(id); copyToClipboard(txt); // also trigger download
              const a=document.createElement('a'); const blob=new Blob([txt],{type:'text/plain'}); const url=URL.createObjectURL(blob); a.href=url; a.download = `tasks_${id}.txt`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
            }));
            
            showReportsProgress(false);
          }, 100);
        }, 100);
      }, 100);
    }, 50);
  }

  function exportCSVForEmployee(empId){
    const emp = (state.employees||[]).find(e=>e.id===empId) || {id:empId,name:empId};
    const rows = [];
    (state.processes||[]).forEach(proc=>{ (proc.operations||[]).forEach(op=>{ if(op.assignee && op.assignee.id===empId){ rows.push({employee:emp.name, process:proc.name, opName:op.name, time:op.time||0}); } }); });
    (state.tasks||[]).forEach(t=>{ const as = t.assignees || (t.assignee ? [t.assignee] : []); if(Array.isArray(as) && as.some(a=> (a.id||a) === empId)) rows.push({employee:emp.name, process: (state.orders||[]).find(o=>o.id===t.orderId)?.name || t.orderId, opName: t.opName, time: t.estMin||t.elapsedMin||0}); });
    if(rows.length===0){ alert('Brak zadań dla pracownika: '+emp.name); return; }
    const csv = ['employee,process,operation,timeMin'].concat(rows.map(r=>`"${(r.employee||'').replace(/"/g,'""')}","${(r.process||'').replace(/"/g,'""')}","${(r.opName||'').replace(/"/g,'""')}",${r.time||0}`)).join('\n');
    const blob=new Blob([csv],{type:'text/csv'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='tasks_'+(emp.name.replace(/\s+/g,'_'))+'.csv'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  }

  function exportCSVAllByWorker(){
    const map = new Map(); const empLookup = new Map((state.employees||[]).map(e=>[e.id,e]));
    (state.processes||[]).forEach(proc=>{ (proc.operations||[]).forEach(op=>{ if(op.assignee && op.assignee.id){ const id=op.assignee.id; if(!map.has(id)) map.set(id,[]); map.get(id).push({process:proc.name,opName:op.name,time:op.time||0}); } }); });
    (state.tasks||[]).forEach(t=>{ const as = t.assignees || (t.assignee ? [t.assignee] : []); if(Array.isArray(as)) as.forEach(a=>{ const id=a.id||a; if(!map.has(id)) map.set(id,[]); map.get(id).push({process: (state.orders||[]).find(o=>o.id===t.orderId)?.name || t.orderId, opName:t.opName, time:t.estMin||t.elapsedMin||0}); }); });
    if(map.size===0){ alert('Brak przypisań do eksportu.'); return; }
    const rows=[]; map.forEach((tasks,id)=>{ const name=(state.employees||[]).find(e=>e.id===id)?.name || id; tasks.forEach(t=>rows.push({employee:name,process:t.process,opName:t.opName,time:t.time})); });
    const csv = ['employee,process,operation,timeMin'].concat(rows.map(r=>`"${(r.employee||'').replace(/"/g,'""')}","${(r.process||'').replace(/"/g,'""')}","${(r.opName||'').replace(/"/g,'""')}",${r.time||0}`)).join('\n');
    const blob=new Blob([csv],{type:'text/csv'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='tasks_by_employee.csv'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  }

  const tasksGenBtn = qs('#tasks-gen-by-emp'); if(tasksGenBtn){ tasksGenBtn.addEventListener('click', ()=>{ generateTasksByWorker(); }); }
  const tasksExportAllBtn = qs('#tasks-export-csv-by-emp'); if(tasksExportAllBtn){ tasksExportAllBtn.addEventListener('click', ()=>{ exportCSVAllByWorker(); }); }
  const tasksShowByEmpBtn = qs('#tasks-show-by-emp'); if(tasksShowByEmpBtn){ tasksShowByEmpBtn.addEventListener('click', ()=>{
    state.uiShowTasksByEmpTable = !state.uiShowTasksByEmpTable;
    if(state.uiShowTasksByEmpTable){ tasksShowByEmpBtn.textContent = 'Ukryj podział'; generateTasksByWorker(); }
    else { tasksShowByEmpBtn.textContent = 'Pokaż podział'; const byW = qs('#tasks-by-worker'); if(byW) byW.innerHTML = ''; }
  }); }

  function renderEmployees(){ const tb=qs('#emp-tb'); tb.innerHTML=''; (state.employees||[]).forEach(e=>{ const tr=document.createElement('tr'); tr.innerHTML='<td>'+e.name+'</td><td>'+(e.cap||100)+'</td><td>'+(e.hoursPerDay||8)+'</td><td><button class="btn" data-emp-ed="'+e.id+'">Edytuj</button> <button class="btn red" data-emp-del="'+e.id+'">Usuń</button></td>'; tb.appendChild(tr); } ); }

  // Function to restore authentic data
  function restoreAuthenticData() {
    const authenticData = {
      "storage": {
        "mode": "firebase",
        "appId": "doors-demo",
        "userId": "hala-1",
        "fbConfig": {
          "apiKey": "AIzaSyD93UqqsHWoAUBV7g8OVKAnajIfGDX_ZdY",
          "authDomain": "doors-planner.firebaseapp.com",
          "projectId": "doors-planner",
          "storageBucket": "doors-planner.appspot.com",
          "messagingSenderId": "513098608067",
          "appId": "1:513098608067:web:1fe3855b3470ca7ef22176"
        },
        "autoSaveAssign": true,
        "spellcheckEnforce": true
      },
      "employees": [
        {"id": "emp1", "name": "Jan Kowalski", "cap": 100, "hoursPerDay": 8},
        {"id": "emp2", "name": "Anna Nowak", "cap": 90, "hoursPerDay": 8},
        {"id": "emp3", "name": "Piotr Wiśniewski", "cap": 95, "hoursPerDay": 8},
        {"id": "emp4", "name": "Maria Zielińska", "cap": 85, "hoursPerDay": 8}
      ],
      "operationsCatalog": [
        {"id": "mg9t6hiit3at", "no": 1, "name": "Frezowanie na CNC (belki futryny)", "time": 40, "workers": 1, "skills": ["CNC", "belki"], "defaultAssignees": []},
        {"id": "mg9t6hii3w84", "no": 2, "name": "Sklejanie belek (futryna)", "time": 20, "workers": 1, "skills": ["sklejanie", "belki"], "defaultAssignees": []},
        {"id": "mg9t6hiije0t", "no": 3, "name": "Kontrola wymiarów (futryna)", "time": 10, "workers": 1, "skills": ["kontrola"], "defaultAssignees": []},
        {"id": "mg9t6hiinhp6", "no": 4, "name": "Szlifowanie (futryna)", "time": 15, "workers": 1, "skills": ["szlifowanie"], "defaultAssignees": []},
        {"id": "mg9t6hii8h6d", "no": 5, "name": "Szczotkowanie (futryna)", "time": 12, "workers": 1, "skills": ["szczotkowanie"], "defaultAssignees": []},
        {"id": "mg9t6hii22fy", "no": 6, "name": "Malowanie (futryna)", "time": 30, "workers": 1, "skills": ["malowanie"], "defaultAssignees": []},
        {"id": "mg9t6hii8c9m", "no": 7, "name": "Okuwanie (futryna)", "time": 8, "workers": 1, "skills": ["okucia"], "defaultAssignees": []},
        {"id": "mg9t6hii16mh", "no": 8, "name": "Wycięcie belek pod skrzydło", "time": 35, "workers": 1, "skills": ["CNC", "belki"], "defaultAssignees": []},
        {"id": "mg9t6hiibhu3", "no": 9, "name": "Sklejenie belek (skrzydło)", "time": 20, "workers": 1, "skills": ["sklejanie", "belki"], "defaultAssignees": []},
        {"id": "mg9t6hii82z6", "no": 10, "name": "Wycięcie sklejki", "time": 25, "workers": 1, "skills": ["sklejka"], "defaultAssignees": []},
        {"id": "mg9t6hii6g4a", "no": 11, "name": "Przygotowanie forniru", "time": 18, "workers": 1, "skills": ["fornir"], "defaultAssignees": []},
        {"id": "mg9t6hiibgls", "no": 12, "name": "Fornirowanie", "time": 30, "workers": 1, "skills": ["fornirowanie"], "defaultAssignees": []},
        {"id": "mg9t6hii482o", "no": 13, "name": "Przygotowanie rurek pod elektronikę", "time": 12, "workers": 1, "skills": ["elektronika"], "defaultAssignees": []},
        {"id": "mg9t6hiiy42w", "no": 14, "name": "Montaż rurek pod elektronikę", "time": 18, "workers": 1, "skills": ["elektronika"], "defaultAssignees": []},
        {"id": "mg9t6hiil5zr", "no": 15, "name": "Przycięcie poprzeczek", "time": 10, "workers": 1, "skills": ["poprzeczki"], "defaultAssignees": []},
        {"id": "mg9t6hii01mz", "no": 16, "name": "Montaż poprzeczek", "time": 12, "workers": 1, "skills": ["poprzeczki"], "defaultAssignees": []},
        {"id": "mg9t6hii5ucc", "no": 17, "name": "Przycięcie styropianu", "time": 5, "workers": 1, "skills": ["styropian"], "defaultAssignees": []},
        {"id": "mg9t6hiihdry", "no": 18, "name": "Montaż styropianu", "time": 8, "workers": 1, "skills": ["styropian"], "defaultAssignees": []},
        {"id": "mg9t6hii55mz", "no": 19, "name": "Przycięcie naciągu", "time": 6, "workers": 1, "skills": ["naciag"], "defaultAssignees": []},
        {"id": "mg9t6hiiuh2p", "no": 20, "name": "Montaż naciągu", "time": 8, "workers": 1, "skills": ["naciag"], "defaultAssignees": []},
        {"id": "mg9t6hii8dmo", "no": 21, "name": "Sklejanie w prasie", "time": 25, "workers": 1, "skills": ["prasa"], "defaultAssignees": []},
        {"id": "mg9t6hii2y8d", "no": 22, "name": "Frezowanie na CNC (skrzydło)", "time": 40, "workers": 1, "skills": ["CNC"], "defaultAssignees": []},
        {"id": "mg9t6hiisdiv", "no": 23, "name": "Szlifowanie (skrzydło)", "time": 15, "workers": 1, "skills": ["szlifowanie"], "defaultAssignees": []},
        {"id": "mg9t6hiiz9js", "no": 24, "name": "Szczotkowanie (skrzydło)", "time": 12, "workers": 1, "skills": ["szczotkowanie"], "defaultAssignees": []},
        {"id": "mg9t6hiimtpd", "no": 25, "name": "Malowanie (skrzydło)", "time": 30, "workers": 1, "skills": ["malowanie"], "defaultAssignees": []},
        {"id": "mg9t6hii642n", "no": 26, "name": "Okuwanie (skrzydło)", "time": 8, "workers": 1, "skills": ["okucia"], "defaultAssignees": []},
        {"id": "mg9t6hii5mri", "no": 27, "name": "Przygotowanie zestawu do drzwi", "time": 10, "workers": 1, "skills": ["zestaw"], "defaultAssignees": []},
        {"id": "mg9t6hii942t", "no": 28, "name": "Przygotowanie antaby", "time": 8, "workers": 1, "skills": ["antaba"], "defaultAssignees": []},
        {"id": "mg9t6hiihf4q", "no": 29, "name": "Zamówienie szyb", "time": 5, "workers": 1, "skills": ["szyby"], "defaultAssignees": []},
        {"id": "mg9t6hii6goh", "no": 30, "name": "Malowanie szyb", "time": 15, "workers": 1, "skills": ["szyby", "malowanie"], "defaultAssignees": []},
        {"id": "mg9t6hii6fl4", "no": 31, "name": "Klejenie szyb", "time": 20, "workers": 1, "skills": ["szyby", "klejenie"], "defaultAssignees": []},
        {"id": "mg9t6hii96bh", "no": 32, "name": "Polerowanie zamków i wypalenie logo", "time": 12, "workers": 1, "skills": ["zamki", "polerowanie"], "defaultAssignees": []},
        {"id": "mg9t6hiidt0v", "no": 33, "name": "Wymiary szyby (szer, H)", "time": 4, "workers": 1, "skills": ["szyby", "wymiary"], "defaultAssignees": []},
        {"id": "mg9t6hiig5mf", "no": 34, "name": "Wycięcie belek pod futrynę", "time": 10, "workers": 1, "skills": [], "defaultAssignees": []},
        {"id": "mg9t6hii5uvr", "no": 35, "name": "Frezowanie na CNC 40 m", "time": 10, "workers": 1, "skills": [], "defaultAssignees": []},
        {"id": "mg9t6hiilbtt", "no": 36, "name": "Sklejanie belek", "time": 10, "workers": 1, "skills": [], "defaultAssignees": []},
        {"id": "mg9t6hijxejj", "no": 37, "name": "Kontrola wymiarów", "time": 10, "workers": 1, "skills": [], "defaultAssignees": []},
        {"id": "mg9t6hijmycx", "no": 38, "name": "Szlifowanie", "time": 10, "workers": 1, "skills": [], "defaultAssignees": []},
        {"id": "mg9t6hijmp8a", "no": 39, "name": "Szczotkowanie", "time": 10, "workers": 1, "skills": [], "defaultAssignees": []},
        {"id": "mg9t6hijkvs2", "no": 40, "name": "Malowanie", "time": 10, "workers": 1, "skills": [], "defaultAssignees": []},
        {"id": "mg9t6hijdgql", "no": 41, "name": "Okuwanie", "time": 10, "workers": 1, "skills": [], "defaultAssignees": []},
        {"id": "mg9t6hijx585", "no": 42, "name": "Sklejenie belek", "time": 10, "workers": 1, "skills": [], "defaultAssignees": []},
        {"id": "mg9t6hijwq00", "no": 43, "name": "Przygotowanie forniru zgodnie z zamówieniem", "time": 10, "workers": 1, "skills": [], "defaultAssignees": []},
        {"id": "mg9t6hijh68k", "no": 44, "name": "Frezowanie na CNC", "time": 10, "workers": 1, "skills": [], "defaultAssignees": []}
      ],
      "processes": [
        {"id": "mg9t6hiieyao", "name": "Proces: Futryna", "operations": [{"name": "Frezowanie na CNC (belki futryny)", "time": 40}, {"name": "Sklejanie belek (futryna)", "time": 20}, {"name": "Kontrola wymiarów (futryna)", "time": 10}, {"name": "Szlifowanie (futryna)", "time": 15}, {"name": "Szczotkowanie (futryna)", "time": 12}, {"name": "Malowanie (futryna)", "time": 30}, {"name": "Okuwanie (futryna)", "time": 8}]},
        {"id": "mg9t6hiiffge", "name": "Proces: Skrzydło", "operations": [{"name": "Wycięcie belek pod skrzydło", "time": 35}, {"name": "Sklejenie belek (skrzydło)", "time": 20}, {"name": "Wycięcie sklejki", "time": 25}, {"name": "Fornirowanie", "time": 30}, {"name": "Frezowanie na CNC (skrzydło)", "time": 40}, {"name": "Szlifowanie (skrzydło)", "time": 15}, {"name": "Malowanie (skrzydło)", "time": 30}, {"name": "Okuwanie (skrzydło)", "time": 8}]},
        {"id": "mg9t6hiiuztd", "name": "Proces: Drzwi kompletne", "operations": [{"name": "Frezowanie na CNC (belki futryny)", "time": 40}, {"name": "Sklejanie belek (futryna)", "time": 20}, {"name": "Wycięcie belek pod skrzydło", "time": 35}, {"name": "Sklejenie belek (skrzydło)", "time": 20}, {"name": "Sklejanie w prasie", "time": 25}, {"name": "Fornirowanie", "time": 30}, {"name": "Malowanie (skrzydło)", "time": 30}, {"name": "Okuwanie (skrzydło)", "time": 8}]}
      ],
      "orders": [],
      "tasks": [
        {"id": "task1", "orderId": "order1", "opName": "Przygotowanie surowców", "status": "todo", "elapsedMin": 0, "estMin": 120, "assignees": [{"id": "emp1"}]},
        {"id": "task2", "orderId": "order1", "opName": "Cięcie drewna", "status": "run", "elapsedMin": 45, "estMin": 90, "assignees": [{"id": "emp2"}]},
        {"id": "task3", "orderId": "order1", "opName": "Szlifowanie", "status": "todo", "elapsedMin": 0, "estMin": 60, "assignees": [{"id": "emp3"}]},
        {"id": "task4", "orderId": "order2", "opName": "Montaż futryny", "status": "todo", "elapsedMin": 0, "estMin": 180, "assignees": [{"id": "emp1"}, {"id": "emp4"}]},
        {"id": "task5", "orderId": "order2", "opName": "Malowanie", "status": "todo", "elapsedMin": 0, "estMin": 150, "assignees": [{"id": "emp2"}]},
        {"id": "task6", "orderId": "order3", "opName": "Wykończenie", "status": "done", "elapsedMin": 200, "estMin": 200, "assignees": [{"id": "emp3"}]}
      ],
      "after": [],
      "PROC_TMP": [],
      "page": "gantt",
      "_timers": {},
      "uiShowTasksByEmpTable": false,
      "settings": {"autoCleanup": true}
    };

    // Restore the data
    Object.assign(state, authenticData);
    localStorage.setItem(storeKey, JSON.stringify(state));

    // Refresh all views
    renderEmployees();
    renderOps();
    renderProcPage();
    renderOrderPage();
    renderTasks();
    renderGantt();
    renderCapacityAnalysis();

    alert('✅ Przywrócono autentyczne dane!\n\nTwoje dane zostały odzyskane z backupu.');
  }

  function renderGantt(){
    const container = qs('#gantt-container');
    if(!container) {
      console.error('Gantt container not found');
      return;
    }

    console.log('Rendering Gantt chart...');

    // Ensure container is visible for width calculations
    const wasHidden = container.closest('.hidden');
    if(wasHidden) {
      container.style.visibility = 'hidden';
      container.style.position = 'absolute';
      container.style.display = 'block';
    }

    const viewMode = qs('#gantt-view').value || 'week';
    // Znajdź najwcześniejszą datę zadania
    const now = new Date();
    let minDate = now;
    (state.tasks||[]).forEach(t => {
      if(t.startPlanned && t.startPlanned < minDate.getTime()) {
        minDate = new Date(t.startPlanned);
      }
    });
    // Zaokrąglij do początku tygodnia (niedziela)
    const startDate = new Date(minDate);
    startDate.setDate(startDate.getDate() - startDate.getDay());
    startDate.setHours(0,0,0,0);
    console.log('Gantt dates - now:', now.toISOString(), 'minDate:', minDate.toISOString(), 'startDate:', startDate.toISOString());
    console.log('Gantt startDate:', startDate.toISOString().slice(0,10), 'now:', now.toISOString().slice(0,10), 'now.getDay():', now.getDay());

    // Generate timeline header
    const timelineEl = qs('#gantt-timeline');
    timelineEl.innerHTML = '';

    const daysCount = viewMode === 'week' ? 7 : 30;
    for(let i = 0; i < daysCount; i++){
      const date = new Date(startDate);
      date.setDate(startDate.getDate() + i);
      const dayEl = document.createElement('div');
      dayEl.className = 'gantt-time-slot';
      dayEl.textContent = date.toLocaleDateString('pl-PL', {weekday: 'short', day: 'numeric'});
      if(date.toDateString() === now.toDateString()){
        dayEl.style.background = 'rgba(239, 68, 68, 0.1)';
        dayEl.style.borderRight = '2px solid #ef4444';
      }
      timelineEl.appendChild(dayEl);
    }

    // Generate resource rows
    const bodyEl = qs('#gantt-body');
    bodyEl.innerHTML = '';

    // Re-add dependencies SVG layer if not exists
    let svg = qs('#gantt-dependencies');
    if (!svg) {
      svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.id = 'gantt-dependencies';
      svg.className = 'gantt-dependency';
      svg.style.cssText = 'position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1;';
      bodyEl.appendChild(svg);
    } else {
      // Clear existing dependencies
      svg.innerHTML = '';
    }

    // Get container width for calculations
    const containerWidth = container.offsetWidth || 1000; // Fallback width
    const timelineWidth = containerWidth - 200;

    console.log('Container width:', containerWidth, 'Timeline width:', timelineWidth);

    // Migracja / uzupełnienie pól z nowego generatora (jeśli jeszcze nie zrobiona)
    (state.tasks||[]).forEach(t=>{
      if(typeof t.status === 'undefined') t.status='todo';
      if(!t.opName) t.opName = t.name || t.operationId || 'Zadanie';
      if(typeof t.estMin === 'undefined') t.estMin = t.duration || 0;
      if(!Array.isArray(t.assignees)) t.assignees = [];
    });

    // Nie przeliczaj automatycznie w widoku Gantt

  console.log('[gantt] state.tasks total=', (state.tasks||[]).length);
  // Group tasks by employee (tylko te które mają przypisania)
    const tasksByEmployee = new Map();
    const allTasks = (state.tasks || []).slice();
    allTasks.forEach(task => {
      const assignees = task.assignees || (task.assignee ? [task.assignee] : []);
      if(assignees && assignees.length){
        assignees.forEach(assignee => {
          const empId = assignee.id || assignee;
            if(!tasksByEmployee.has(empId)) tasksByEmployee.set(empId, []);
            tasksByEmployee.get(empId).push(task);
        });
      }
    });

    const unassigned = allTasks.filter(t=>{
      const a = t.assignees || (t.assignee?[t.assignee]:[]);
      return !a || a.length===0;
    });
    console.log('[gantt] employees=', (state.employees||[]).length, 'withAssignedRows=', tasksByEmployee.size, 'unassigned=', unassigned.length);
    if(!(state.employees||[]).length && unassigned.length){
      // Fallback: sztuczny pracownik aby zobaczyć zadania
      console.warn('[gantt] Brak pracowników – renderuję wszystkie jako (Niezaplanowane)');
    }

    // Add rows for each employee
    (state.employees || []).forEach(employee => {
      const rowEl = document.createElement('div');
      rowEl.className = 'gantt-row';

      const resourceCell = document.createElement('div');
      resourceCell.className = 'gantt-resource-cell';
      resourceCell.textContent = employee.name;
      rowEl.appendChild(resourceCell);

      const taskCell = document.createElement('div');
      taskCell.className = 'gantt-task-cell';
      taskCell.setAttribute('data-employee-id', employee.id);

      // Add tasks for this employee - time-based positioning
      const employeeTasks = tasksByEmployee.get(employee.id) || [];
      console.log('Employee', employee.name, 'has', employeeTasks.length, 'tasks');

      const slotWidth = 146; // Approximate width per day slot
      let renderedCount = 0;
      employeeTasks.forEach((task, taskIndex) => {
        if(!task.startPlanned) {
          console.log('Task without startPlanned:', task.id, task.opName);
          return; // Skip if no start time
        }
        renderedCount++;
        const taskEl = document.createElement('div');
        taskEl.className = `gantt-task ${task.status || 'todo'}`;
        taskEl.setAttribute('data-task-id', task.id);
        taskEl.setAttribute('data-task-id', task.id);

        // Smart text formatting for task names
        let displayName = task.opName || 'Zadanie';
        let fontSize = '11px';
        let taskWidth = 120;

        // Adjust based on text length
        if (displayName.length > 15) {
          displayName = displayName.substring(0, 12) + '...';
          fontSize = '10px';
          taskWidth = 140;
        } else if (displayName.length > 10) {
          taskWidth = 130;
        }

        taskEl.textContent = displayName;
        taskEl.style.fontSize = fontSize;
        taskEl.style.width = taskWidth + 'px';
        taskEl.style.position = 'absolute';

        // Calculate position based on start date
        const taskDate = new Date(task.startPlanned);
        const daysDiff = Math.floor((taskDate - startDate) / (24 * 3600 * 1000));
        const leftPos = daysDiff * slotWidth + 10;
        taskEl.style.left = leftPos + 'px';

        console.log('Task:', displayName, 'start:', taskDate.toISOString().slice(0,10), 'startDate:', startDate.toISOString().slice(0,10), 'daysDiff:', daysDiff, 'leftPos:', leftPos);

        // Enhanced tooltip with full name
        taskEl.title = `${task.opName || 'Zadanie'}\nStatus: ${task.status || 'todo'}\nCzas: ${task.estMin || 60}min\nPracownik: ${employee.name}`;

        taskCell.appendChild(taskEl);
      });
      console.log('Rendered', renderedCount, 'tasks for', employee.name);

      rowEl.appendChild(taskCell);
      bodyEl.appendChild(rowEl);
    });

    // Row for unassigned tasks
  if(unassigned.length){
      const rowEl = document.createElement('div');
      rowEl.className = 'gantt-row';
      const resourceCell = document.createElement('div');
      resourceCell.className = 'gantt-resource-cell';
      resourceCell.textContent = '(Niezaplanowane)';
      rowEl.appendChild(resourceCell);
      const taskCell = document.createElement('div');
      taskCell.className = 'gantt-task-cell';
      const slotWidth = 146;
      let renderedUnassigned = 0;
      unassigned.slice(0,250).forEach(task=>{
        if(!task.startPlanned) {
          console.log('Unassigned task without startPlanned:', task.id, task.opName);
          return;
        }
        renderedUnassigned++;
        const taskEl = document.createElement('div');
        taskEl.className = `gantt-task ${task.status || 'todo'} unassigned`;
        taskEl.setAttribute('data-task-id', task.id);
        const displayName = (task.opName || task.name || 'Zadanie').slice(0,18);
        const dur = task.estMin || task.duration || 0;
        // Proporcja szerokości: min 60px +  (dur/ (8*60)) * 160px * 0.8
        const dayWidth = 160; const base = 60; const scale = Math.max(0.2, Math.min(0.8, (dur/(8*60)) ));
        const taskWidth = Math.round(base + scale*dayWidth);
        taskEl.textContent = displayName;
        // Calculate position based on start date
        const taskDate = new Date(task.startPlanned);
        const daysDiff = Math.floor((taskDate - startDate) / (24 * 3600 * 1000));
        const leftPos = daysDiff * slotWidth + 10;
        taskEl.style.left = leftPos + 'px';
        taskEl.style.width = taskWidth + 'px';
        taskEl.style.position = 'absolute';
        taskEl.title = `${task.opName||task.name||'Zadanie'}\nStatus: ${task.status||'-'}\nCzas: ${dur} min`;
        console.log('Unassigned task:', displayName, 'start:', taskDate.toISOString().slice(0,10), 'daysDiff:', daysDiff, 'leftPos:', leftPos);
        taskCell.appendChild(taskEl);
      });
      console.log('Rendered', renderedUnassigned, 'unassigned tasks');
      if(unassigned.length>250){
        const more = document.createElement('div');
        more.style.cssText='position:absolute;left:'+(renderedUnassigned * 50 + 10)+'px;font-size:11px;color:#94a3b8;padding:2px';
        more.textContent = '+'+(unassigned.length-250)+' ...';
        taskCell.appendChild(more);
      }
      rowEl.appendChild(taskCell);
      bodyEl.appendChild(rowEl);
    }

    // Add current time indicator
    const currentTimeEl = document.createElement('div');
    currentTimeEl.className = 'gantt-current-time';
    // Position relative to the timeline, not including the resource column
    // Since tasks start at position 10px within the task cell, we need to account for that
    const currentTimePosition = ((now.getHours() * 60 + now.getMinutes()) / (24 * 60)) * timelineWidth;
    currentTimeEl.style.left = (200 + 10 + currentTimePosition) + 'px'; // 200px for resource column + 10px for task start position
    container.appendChild(currentTimeEl);

    // Restore visibility if it was hidden
    if(wasHidden) {
      container.style.visibility = '';
      container.style.position = '';
      container.style.display = '';
    }

    if(!(state.employees||[]).length && !unassigned.length){
      bodyEl.innerHTML = '<div style="padding:12px;color:#94a3b8;font-size:13px">Brak pracowników i brak zadań do wyświetlenia.</div>';
    }
    console.log('Gantt chart rendered');

    // Initialize drag & drop functionality
    initGanttDragDrop();

    // Initialize visualization state
    if (typeof window.ganttShowDependencies === 'undefined') {
      window.ganttShowDependencies = false;
      window.ganttShowCriticalPath = false;
    }

    // Update button states
    updateGanttButtons();

    // Render dependencies if enabled
    if (window.ganttShowDependencies) {
      renderDependencies();
    }
  }

  // Make functions available globally for event handlers
  window.renderGantt = renderGantt;
  window.autoAssignEmployeesToTasks = autoAssignEmployeesToTasks;

  function generateGanttTestData(){
    // Generate some test data for Gantt chart demonstration (without overwriting existing data)
    console.log('Dodaję dane testowe dla harmonogramu...');

    // Add test employees if none exist
    if((state.employees || []).length === 0){
      state.employees = [
        {id: 'emp1', name: 'Jan Kowalski'},
        {id: 'emp2', name: 'Anna Nowak'},
        {id: 'emp3', name: 'Piotr Wiśniewski'},
        {id: 'emp4', name: 'Maria Zielińska'}
      ];
    }

    // Add test orders if none exist
    if((state.orders || []).length === 0){
      state.orders = [
        {id: 'order_test_1', name: 'Drzwi wejściowe dąb', client: 'Firma ABC', model: 'Dąb Classic', quantity: 5, startDate: '2025-10-01', endDate: '2025-10-15', processId: 'proc1'},
        {id: 'order_test_2', name: 'Drzwi wewnętrzne sosna', client: 'Dom prywatny', model: 'Sosna Light', quantity: 3, startDate: '2025-09-20', endDate: '2025-10-05', processId: 'proc2'},
        {id: 'order_test_3', name: 'Drzwi balkonowe', client: 'Blok mieszkalny', model: 'Balkon Plus', quantity: 8, startDate: '2025-10-01', endDate: '2025-10-20', processId: 'proc1'}
      ];
    }

    // Add test processes if none exist
    if((state.processes || []).length === 0){
      state.processes = [
        {id: 'proc1', name: 'Proces standardowy', operations: [
          {name: 'Frezowanie na CNC', assignee: {id: 'emp1', name: 'Jan Kowalski'}},
          {name: 'Malowanie', assignee: {id: 'emp2', name: 'Anna Nowak'}},
          {name: 'Okuwanie', assignee: {id: 'emp4', name: 'Maria Zielińska'}}
        ]},
        {id: 'proc2', name: 'Proces uproszczony', operations: [
          {name: 'Szlifowanie', assignee: {id: 'emp3', name: 'Piotr Wiśniewski'}},
          {name: 'Przygotowanie powierzchni do malowania z dodatkowymi zabiegami', assignee: {id: 'emp1', name: 'Jan Kowalski'}}
        ]}
      ];
    }

    // Add test tasks (always add, don't overwrite)
    const testTasks = [
      {id: 'task_test_1', orderId: 'order_test_1', opName: 'Frezowanie na CNC (test)', status: 'run', elapsedMin: 30, estMin: 60, assignees: [{id: 'emp1', name: 'Jan Kowalski'}]},
      {id: 'task_test_2', orderId: 'order_test_1', opName: 'Malowanie (test)', status: 'todo', elapsedMin: 0, estMin: 45, assignees: [{id: 'emp2', name: 'Anna Nowak'}]},
      {id: 'task_test_3', orderId: 'order_test_2', opName: 'Szlifowanie (test)', status: 'done', elapsedMin: 25, estMin: 25, assignees: [{id: 'emp3', name: 'Piotr Wiśniewski'}]},
      {id: 'task_test_4', orderId: 'order_test_2', opName: 'Okuwanie (test)', status: 'run', elapsedMin: 15, estMin: 30, assignees: [{id: 'emp4', name: 'Maria Zielińska'}]},
      {id: 'task_test_5', orderId: 'order_test_3', opName: 'Przygotowanie powierzchni do malowania z dodatkowymi zabiegami', status: 'todo', elapsedMin: 0, estMin: 90, assignees: [{id: 'emp1', name: 'Jan Kowalski'}]}
    ];

    // Add test tasks only if they don't already exist
    testTasks.forEach(testTask => {
      if(!(state.tasks || []).some(t => t.id === testTask.id)){
        state.tasks = state.tasks || [];
        state.tasks.push(testTask);
      }
    });

    save();
    renderGantt();
    console.log('Dodano dane testowe dla harmonogramu! Oryginalne dane zostały zachowane.');
  }

  // Function to auto-assign employees to existing tasks based on processes
  function autoAssignEmployeesToTasks(){
    console.log('Auto-assigning employees to existing tasks...');
    let updatedCount = 0;

    (state.tasks || []).forEach(task => {
      // Skip if task already has assignees
      if(task.assignees && task.assignees.length > 0) return;

      // Find the order and its process
      const order = (state.orders || []).find(o => o.id === task.orderId);
      if(!order || !order.processId) return;

      const process = (state.processes || []).find(p => p.id === order.processId);
      if(!process) return;

      // Find the operation in the process
      const operation = (process.operations || []).find(op => op.name === task.opName);
      if(!operation) return;

      // Assign employee from operation
      let assignees = [];
      if(operation.assignee){
        assignees = [operation.assignee];
      } else {
        // Try to find default assignees from catalog
        const catalogOp = (state.operationsCatalog || []).find(co => co.name === operation.name);
        if(catalogOp && catalogOp.defaultAssignees && catalogOp.defaultAssignees.length > 0){
          assignees = catalogOp.defaultAssignees;
        }
      }

      if(assignees.length > 0){
        task.assignees = assignees;
        updatedCount++;
        console.log(`Assigned ${assignees.map(a => a.name || a.id).join(', ')} to task ${task.opName}`);
      }
    });

    if(updatedCount > 0){
      save();
      console.log(`Auto-assigned employees to ${updatedCount} tasks`);
    } else {
      console.log('No tasks needed auto-assignment');
    }

    renderGantt();
  }

  function renderCapacityAnalysis(){
    const period = qs('#capacity-period').value || 'week';

    // Calculate resource utilization
    const resourceUtilization = calculateResourceUtilization(period);
    renderResourceUtilization(resourceUtilization);

    // Calculate bottlenecks
    const bottlenecks = calculateBottlenecks();
    renderBottlenecks(bottlenecks);

    // Calculate efficiency metrics
    const efficiency = calculateEfficiencyMetrics(period);
    renderEfficiencyMetrics(efficiency);

    // Calculate optimization suggestions
    const optimization = calculateOptimizationSuggestions();
    renderOptimizationSuggestions(optimization);
  }

  function calculateResourceUtilization(period){
    const employees = state.employees || [];
    const tasks = state.tasks || [];
    const utilization = [];

    employees.forEach(emp => {
      const empTasks = tasks.filter(t => t.assignees && t.assignees.some(a => a.id === emp.id));
      const totalTime = empTasks.reduce((sum, t) => sum + (t.estMin || 0), 0);
      const availableTime = period === 'day' ? emp.hoursPerDay * 60 : period === 'week' ? emp.hoursPerDay * 60 * 7 : emp.hoursPerDay * 60 * 30;
      const utilizationPercent = availableTime > 0 ? Math.round((totalTime / availableTime) * 100) : 0;

      utilization.push({
        employee: emp.name,
        totalTasks: empTasks.length,
        totalTime: totalTime,
        availableTime: availableTime,
        utilization: utilizationPercent,
        status: utilizationPercent > 100 ? 'overloaded' : utilizationPercent > 80 ? 'high' : utilizationPercent > 50 ? 'normal' : 'low'
      });
    });

    return utilization;
  }

  function renderResourceUtilization(utilization){
    const container = qs('#capacity-resources');
    container.innerHTML = '';

    if(utilization.length === 0){
      container.innerHTML = '<div class="empty">Brak danych do analizy</div>';
      return;
    }

    utilization.forEach(item => {
      const div = document.createElement('div');
      div.className = 'capacity-item';
      div.innerHTML = `
        <div class="capacity-employee">${item.employee}</div>
        <div class="capacity-metrics">
          <div>Zadań: ${item.totalTasks}</div>
          <div>Czas: ${Math.round(item.totalTime / 60 * 10) / 10}h / ${Math.round(item.availableTime / 60 * 10) / 10}h</div>
          <div class="capacity-bar">
            <div class="capacity-fill ${item.status}" style="width: ${Math.min(item.utilization, 100)}%"></div>
            <span>${item.utilization}%</span>
          </div>
        </div>
      `;
      container.appendChild(div);
    });
  }

  function calculateOptimizationSuggestions(){
    const employees = state.employees || [];
    const tasks = state.tasks || [];
    const suggestions = [];

    // Calculate current workload for each employee
    const workloads = employees.map(emp => {
      const empTasks = tasks.filter(t => t.assignees && t.assignees.some(a => a.id === emp.id));
      const totalTime = empTasks.reduce((sum, t) => sum + (t.estMin || 0), 0);
      const availableTime = emp.hoursPerDay * 60 * 7; // Weekly available time
      const utilization = availableTime > 0 ? (totalTime / availableTime) * 100 : 0;

      return {
        employee: emp,
        tasks: empTasks,
        totalTime,
        availableTime,
        utilization,
        status: utilization > 100 ? 'overloaded' : utilization > 80 ? 'high' : utilization > 50 ? 'normal' : 'low'
      };
    });

    // Find overloaded employees
    const overloaded = workloads.filter(w => w.status === 'overloaded');
    if(overloaded.length > 0){
      suggestions.push({
        type: 'overload',
        priority: 'high',
        title: 'Przeładowani pracownicy',
        description: `${overloaded.map(w => w.employee.name).join(', ')} mają obciążenie >100%. Rozważ przełożenie zadań.`,
        actions: overloaded.map(w => ({
          employee: w.employee.name,
          tasksToMove: w.tasks.filter(t => t.status === 'todo').slice(0, 2)
        }))
      });
    }

    // Find underutilized employees
    const underutilized = workloads.filter(w => w.status === 'low');
    if(underutilized.length > 0){
      suggestions.push({
        type: 'underload',
        priority: 'medium',
        title: 'Niedowykorzystani pracownicy',
        description: `${underutilized.map(w => w.employee.name).join(', ')} mają obciążenie <50%. Można im przypisać więcej zadań.`,
        actions: underutilized.map(w => ({
          employee: w.employee.name,
          availableCapacity: Math.round(w.availableTime - w.totalTime)
        }))
      });
    }

    // Find skill mismatches
    const skillMismatches = [];
    tasks.forEach(task => {
      if(task.assignees && task.assignees.length > 0){
        const operation = (state.operationsCatalog || []).find(op => op.name === task.opName);
        if(operation && operation.skills && operation.skills.length > 0){
          task.assignees.forEach(assignee => {
            // For now, assume all employees can do all tasks
            // In a real system, we'd check employee skills
          });
        }
      }
    });

    // Suggest task redistribution
    const highWorkload = workloads.filter(w => w.utilization > 80);
    const lowWorkload = workloads.filter(w => w.utilization < 60);

    if(highWorkload.length > 0 && lowWorkload.length > 0){
      suggestions.push({
        type: 'redistribution',
        priority: 'medium',
        title: 'Przeniesienie zadań',
        description: `Rozważ przeniesienie zadań z ${highWorkload.map(w => w.employee.name).join(', ')} do ${lowWorkload.map(w => w.employee.name).join(', ')}`,
        actions: []
      });
    }

    // Suggest parallel processing for bottlenecks
    const bottlenecks = calculateBottlenecks();
    if(bottlenecks.length > 0){
      suggestions.push({
        type: 'parallel',
        priority: 'high',
        title: 'Przetwarzanie równoległe',
        description: `Operacje ${bottlenecks.map(b => b.operation).join(', ')} są wąskimi gardłami. Rozważ zatrudnienie dodatkowych pracowników.`,
        actions: bottlenecks.map(b => ({
          operation: b.operation,
          currentWorkers: b.countRun + b.countTodo,
          suggestedWorkers: Math.min(b.countRun + b.countTodo + 1, 3)
        }))
      });
    }

    return suggestions;
  }

  function renderOptimizationSuggestions(suggestions){
    const container = qs('#capacity-optimization');
    container.innerHTML = '';

    if(suggestions.length === 0){
      container.innerHTML = '<div class="empty">Brak sugestii optymalizacji - obciążenie jest zrównoważone! 🎉</div>';
      return;
    }

    suggestions.forEach(suggestion => {
      const div = document.createElement('div');
      div.className = `card ${suggestion.priority === 'high' ? 'err' : suggestion.priority === 'medium' ? 'warn' : ''}`;
      div.style.marginBottom = '8px';

      let actionsHtml = '';
      if(suggestion.actions && suggestion.actions.length > 0){
        actionsHtml = '<div style="margin-top: 8px;"><strong>Sugerowane działania:</strong><ul style="margin: 4px 0; padding-left: 20px;">';
        suggestion.actions.forEach(action => {
          if(action.tasksToMove){
            actionsHtml += `<li>Przenieś zadania: ${action.tasksToMove.map(t => t.opName).join(', ')} od ${action.employee}</li>`;
          } else if(action.availableCapacity){
            actionsHtml += `<li>${action.employee} ma dostępną pojemność: ${Math.round(action.availableCapacity/60)}h</li>`;
          } else if(action.suggestedWorkers){
            actionsHtml += `<li>${action.operation}: zwiększ liczbę pracowników do ${action.suggestedWorkers}</li>`;
          }
        });
        actionsHtml += '</ul></div>';
      }

      div.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: flex-start;">
          <div>
            <strong>${suggestion.title}</strong>
            <div style="margin-top: 4px; color: #94a3b8;">${suggestion.description}</div>
            ${actionsHtml}
          </div>
          <div style="font-size: 12px; color: ${suggestion.priority === 'high' ? '#ef4444' : suggestion.priority === 'medium' ? '#f59e0b' : '#10b981'}; font-weight: bold;">
            ${suggestion.priority === 'high' ? 'WYSOKI' : suggestion.priority === 'medium' ? 'ŚREDNI' : 'NISKI'}
          </div>
        </div>
      `;

      container.appendChild(div);
    });
  }

  function calculateBottlenecks(){
    const bottlenecks = [];
    const operations = state.operations || [];
    const tasks = state.tasks || [];

    operations.forEach(op => {
      const opTasks = tasks.filter(t => t.opName === op.name);
      const totalTime = opTasks.reduce((sum, t) => sum + (t.estMin || 0), 0);
      const workerCount = op.workers || 1;
      const availableTime = workerCount * 8 * 60; // 8 hours per worker per day

      if(totalTime > availableTime * 1.2){ // 20% over capacity
        bottlenecks.push({
          operation: op.name,
          totalTime: totalTime,
          availableTime: availableTime,
          overload: Math.round((totalTime / availableTime - 1) * 100)
        });
      }
    });

    return bottlenecks.sort((a, b) => b.overload - a.overload);
  }

  function renderBottlenecks(bottlenecks){
    const container = qs('#capacity-bottlenecks');
    container.innerHTML = '';

    if(bottlenecks.length === 0){
      container.innerHTML = '<div class="empty">Brak wąskich gardeł</div>';
      return;
    }

    bottlenecks.forEach(item => {
      const div = document.createElement('div');
      div.className = 'bottleneck-item';
      div.innerHTML = `
        <div class="bottleneck-name">${item.operation}</div>
        <div class="bottleneck-metrics">
          <div>Przeciążenie: ${item.overload}%</div>
          <div>Czas: ${Math.round(item.totalTime / 60 * 10) / 10}h / ${Math.round(item.availableTime / 60 * 10) / 10}h</div>
        </div>
      `;
      container.appendChild(div);
    });
  }

  function calculateEfficiencyMetrics(period){
    const tasks = state.tasks || [];
    const totalTasks = tasks.length;
    const completedTasks = tasks.filter(t => t.status === 'done').length;
    const runningTasks = tasks.filter(t => t.status === 'run').length;
    const todoTasks = tasks.filter(t => t.status === 'todo').length;

    const totalEstimatedTime = tasks.reduce((sum, t) => sum + (t.estMin || 0), 0);
    const totalActualTime = tasks.reduce((sum, t) => sum + (t.elapsedMin || 0), 0);

    const efficiency = totalEstimatedTime > 0 ? Math.round((totalActualTime / totalEstimatedTime) * 100) : 0;

    return {
      totalTasks,
      completedTasks,
      runningTasks,
      todoTasks,
      totalEstimatedTime,
      totalActualTime,
      efficiency: efficiency > 0 ? efficiency : 0,
      completionRate: totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0
    };
  }

  function renderEfficiencyMetrics(efficiency){
    const container = qs('#capacity-efficiency');
    container.innerHTML = '';

    const metrics = [
      {label: 'Razem zadań', value: efficiency.totalTasks},
      {label: 'Ukończonych', value: `${efficiency.completedTasks} (${efficiency.completionRate}%)`},
      {label: 'W trakcie', value: efficiency.runningTasks},
      {label: 'Do wykonania', value: efficiency.todoTasks},
      {label: 'Szacowany czas', value: `${Math.round(efficiency.totalEstimatedTime / 60 * 10) / 10}h`},
      {label: 'Rzeczywisty czas', value: `${Math.round(efficiency.totalActualTime / 60 * 10) / 10}h`},
      {label: 'Efektywność', value: `${efficiency.efficiency}%`}
    ];

    metrics.forEach(metric => {
      const div = document.createElement('div');
      div.className = 'efficiency-metric';
      div.innerHTML = `
        <span class="metric-label">${metric.label}:</span>
        <span class="metric-value">${metric.value}</span>
      `;
      container.appendChild(div);
    });
  }

  function exportCapacityAnalysis(){
    const period = qs('#capacity-period').value || 'week';
    const utilization = calculateResourceUtilization(period);
    const bottlenecks = calculateBottlenecks();
    const efficiency = calculateEfficiencyMetrics(period);

    let csv = 'Analiza Przepustowości Produkcji\n';
    csv += `Okres: ${period === 'day' ? 'Dzień' : period === 'week' ? 'Tydzień' : 'Miesiąc'}\n\n`;

    csv += 'Wykorzystanie Zasobów\n';
    csv += 'Pracownik,Zadań,Czas szacowany,Czas dostępny,Wykorzystanie\n';
    utilization.forEach(item => {
      csv += `${item.employee},${item.totalTasks},${Math.round(item.totalTime / 60 * 10) / 10},${Math.round(item.availableTime / 60 * 10) / 10},${item.utilization}%\n`;
    });

    csv += '\nWąskie Gardła\n';
    csv += 'Operacja,Czas całkowity,Czas dostępny,Przeciążenie\n';
    bottlenecks.forEach(item => {
      csv += `${item.operation},${Math.round(item.totalTime / 60 * 10) / 10},${Math.round(item.availableTime / 60 * 10) / 10},${item.overload}%\n`;
    });

    csv += '\nEfektywność Produkcji\n';
    csv += `Razem zadań,${efficiency.totalTasks}\n`;
    csv += `Ukończonych,${efficiency.completedTasks} (${efficiency.completionRate}%)\n`;
    csv += `W trakcie,${efficiency.runningTasks}\n`;
    csv += `Do wykonania,${efficiency.todoTasks}\n`;
    csv += `Szacowany czas,${Math.round(efficiency.totalEstimatedTime / 60 * 10) / 10}h\n`;
    csv += `Rzeczywisty czas,${Math.round(efficiency.totalActualTime / 60 * 10) / 10}h\n`;
    csv += `Efektywność,${efficiency.efficiency}%\n`;

    const blob = new Blob([csv], {type: 'text/csv;charset=utf-8;'});
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `analiza-przepustowosci-${new Date().toISOString().slice(0, 10)}.csv`;
    link.click();
  }

  // === BACKUP SYSTEM ===

  // Backup storage using localStorage with versioning
  const BACKUP_STORAGE_KEY = 'production_planner_backups';
  const MAX_BACKUPS_DEFAULT = 10;

  // Initialize backup system
  function initBackupSystem() {
    if (!localStorage.getItem(BACKUP_STORAGE_KEY)) {
      localStorage.setItem(BACKUP_STORAGE_KEY, JSON.stringify([]));
    }
    renderBackupList();
    updateBackupStats();
  }

  // Create a new backup
  function createBackup(name = null) {
    try {
      const backupName = name || `Backup ${new Date().toLocaleString('pl-PL')}`;
      const backupData = {
        id: uid(),
        name: backupName,
        timestamp: Date.now(),
        version: '1.0',
        data: JSON.parse(JSON.stringify(state)), // Deep copy
        metadata: {
          employeesCount: (state.employees || []).length,
          operationsCount: (state.operationsCatalog || []).length,
          processesCount: (state.processes || []).length,
          ordersCount: (state.orders || []).length,
          tasksCount: (state.tasks || []).length,
          size: JSON.stringify(state).length
        }
      };

      // Compress if enabled
      if (qs('#backup-compress') && qs('#backup-compress').checked) {
        // Simple compression using LZString if available, otherwise just store as is
        try {
          if (window.LZString) {
            backupData.compressed = true;
            backupData.data = window.LZString.compressToUTF16(JSON.stringify(state));
          }
        } catch (e) {
          console.warn('Compression failed, storing uncompressed:', e);
        }
      }

      const backups = getBackups();
      backups.unshift(backupData); // Add to beginning

      // Apply cleanup policy
      const maxBackups = parseInt(qs('#backup-max-count').value) || MAX_BACKUPS_DEFAULT;
      if (backups.length > maxBackups) {
        backups.splice(maxBackups);
      }

      localStorage.setItem(BACKUP_STORAGE_KEY, JSON.stringify(backups));
      renderBackupList();
      updateBackupStats();

      console.log('Backup created:', backupName);
      return backupData.id;
    } catch (e) {
      console.error('Failed to create backup:', e);
      alert('Błąd podczas tworzenia backupu: ' + e.message);
      return null;
    }
  }

  // Get all backups
  function getBackups() {
    try {
      return JSON.parse(localStorage.getItem(BACKUP_STORAGE_KEY) || '[]');
    } catch (e) {
      console.error('Failed to load backups:', e);
      return [];
    }
  }

  // Restore from backup
  function restoreFromBackup(backupId) {
    try {
      const backups = getBackups();
      const backup = backups.find(b => b.id === backupId);

      if (!backup) {
        alert('Backup nie został znaleziony!');
        return false;
      }

      // Confirm restoration
      if (!confirm(`Czy na pewno chcesz przywrócić dane z backupu "${backup.name}"?\n\nTo działanie nadpisze wszystkie bieżące dane!`)) {
        return false;
      }

      let backupData = backup.data;

      // Decompress if needed
      if (backup.compressed && window.LZString) {
        try {
          backupData = JSON.parse(window.LZString.decompressFromUTF16(backupData));
        } catch (e) {
          console.error('Failed to decompress backup:', e);
          alert('Błąd podczas dekompresji backupu!');
          return false;
        }
      }

      // Restore data
      Object.assign(state, backupData);
      save();

      // Refresh all views
      renderEmployees();
      renderOps();
      renderProcPage();
      renderOrderPage();
      renderTasks();
      renderGantt();
      renderCapacityAnalysis();
      renderASPage();
      renderDash(window.state || state);

      console.log('Restored from backup:', backup.name);
      alert(`✅ Dane zostały przywrócone z backupu "${backup.name}"!`);

      return true;
    } catch (e) {
      console.error('Failed to restore backup:', e);
      alert('Błąd podczas przywracania backupu: ' + e.message);
      return false;
    }
  }

  // Delete backup
  function deleteBackup(backupId) {
    try {
      const backups = getBackups();
      const index = backups.findIndex(b => b.id === backupId);

      if (index === -1) {
        alert('Backup nie został znaleziony!');
        return false;
      }

      const backup = backups[index];
      if (!confirm(`Czy na pewno chcesz usunąć backup "${backup.name}"?`)) {
        return false;
      }

      backups.splice(index, 1);
      localStorage.setItem(BACKUP_STORAGE_KEY, JSON.stringify(backups));
      renderBackupList();
      updateBackupStats();

      console.log('Backup deleted:', backup.name);
      return true;
    } catch (e) {
      console.error('Failed to delete backup:', e);
      alert('Błąd podczas usuwania backupu: ' + e.message);
      return false;
    }
  }

  // Export backup to file
  function exportBackup(backupId) {
    try {
      const backups = getBackups();
      const backup = backups.find(b => b.id === backupId);

      if (!backup) {
        alert('Backup nie został znaleziony!');
        return;
      }

      const exportData = {
        exportedAt: new Date().toISOString(),
        app: 'Production Planner',
        version: '1.0',
        backup: backup
      };

      const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `backup_${backup.name.replace(/[^a-zA-Z0-9]/g, '_')}_${new Date(backup.timestamp).toISOString().slice(0, 10)}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      console.log('Backup exported:', backup.name);
    } catch (e) {
      console.error('Failed to export backup:', e);
      alert('Błąd podczas eksportu backupu: ' + e.message);
    }
  }

  // Import backup from file
  function importBackupFromFile(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);

          // Validate backup format
          if (!data.backup || !data.backup.id || !data.backup.data) {
            throw new Error('Nieprawidłowy format pliku backupu');
          }

          const backup = data.backup;
          const backups = getBackups();

          // Check if backup with same ID already exists
          if (backups.some(b => b.id === backup.id)) {
            if (!confirm('Backup o tym samym ID już istnieje. Czy chcesz go nadpisać?')) {
              resolve(false);
              return;
            }
            // Remove existing backup
            const index = backups.findIndex(b => b.id === backup.id);
            backups.splice(index, 1);
          }

          // Add new backup
          backups.unshift(backup);
          localStorage.setItem(BACKUP_STORAGE_KEY, JSON.stringify(backups));
          renderBackupList();
          updateBackupStats();

          alert(`Backup "${backup.name}" został zaimportowany!`);
          console.log('Backup imported:', backup.name);
          resolve(true);
        } catch (e) {
          console.error('Failed to import backup:', e);
          alert('Błąd podczas importu backupu: ' + e.message);
          resolve(false);
        }
      };
      reader.onerror = () => reject(new Error('Failed to read file'));
      reader.readAsText(file);
    });
  }

  // Render backup list
  function renderBackupList() {
    const container = qs('#backup-list');
    if (!container) return;

    const backups = getBackups();

    if (backups.length === 0) {
      container.innerHTML = '<div class="muted">Brak dostępnych backupów. Utwórz pierwszy backup.</div>';
      return;
    }

    const html = backups.map(backup => {
      const date = new Date(backup.timestamp).toLocaleString('pl-PL');
      const size = backup.metadata ? `${Math.round(backup.metadata.size / 1024)} KB` : 'N/A';

      return `
        <div class="backup-item card" style="margin-bottom: 8px;">
          <div class="backup-header" style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
            <div>
              <strong>${backup.name}</strong>
              <div class="muted" style="font-size: 12px;">${date}</div>
            </div>
            <div style="font-size: 12px; color: #94a3b8;">
              ${size} ${backup.compressed ? '🗜️' : ''}
            </div>
          </div>

          <div class="backup-meta" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(80px, 1fr)); gap: 8px; margin-bottom: 8px; font-size: 12px;">
            <div>👥 ${backup.metadata?.employeesCount || 0}</div>
            <div>🔧 ${backup.metadata?.operationsCount || 0}</div>
            <div>📋 ${backup.metadata?.processesCount || 0}</div>
            <div>📦 ${backup.metadata?.ordersCount || 0}</div>
            <div>✅ ${backup.metadata?.tasksCount || 0}</div>
          </div>

          <div class="backup-actions" style="display: flex; gap: 6px; flex-wrap: wrap;">
            <button class="btn" onclick="restoreFromBackup('${backup.id}')" title="Przywróć dane z tego backupu">
              🔄 Przywróć
            </button>
            <button class="btn" onclick="exportBackup('${backup.id}')" title="Eksportuj backup do pliku">
              💾 Eksport
            </button>
            <button class="btn red" onclick="deleteBackup('${backup.id}')" title="Usuń backup">
              🗑️ Usuń
            </button>
          </div>
        </div>
      `;
    }).join('');

    container.innerHTML = html;
  }

  // Update backup statistics
  function updateBackupStats() {
    const backups = getBackups();

    // Update counts
    qs('#backup-count').textContent = backups.length;

    // Update latest backup
    if (backups.length > 0) {
      const latest = new Date(backups[0].timestamp);
      qs('#backup-latest').textContent = latest.toLocaleString('pl-PL');
    } else {
      qs('#backup-latest').textContent = '-';
    }

    // Calculate total size
    const totalSize = backups.reduce((sum, b) => sum + (b.metadata?.size || 0), 0);
    qs('#backup-size').textContent = `${Math.round(totalSize / 1024)} KB`;
  }

  // Auto-backup functionality
  function setupAutoBackup() {
    // Create backup before major operations
    const originalSave = window.save;
    window.save = function() {
      // Create auto-backup if enabled and it's been more than 1 hour since last backup
      const lastBackup = localStorage.getItem('last_auto_backup');
      const now = Date.now();

      if (qs('#backup-auto-cleanup') && qs('#backup-auto-cleanup').checked) {
        if (!lastBackup || (now - parseInt(lastBackup)) > 3600000) { // 1 hour
          createBackup(`Auto-backup ${new Date().toLocaleString('pl-PL')}`);
          localStorage.setItem('last_auto_backup', now.toString());
        }
      }

      return originalSave.apply(this, arguments);
    };
  }

  // Save backup settings
  function saveBackupSettings() {
    const settings = {
      includeSettings: qs('#backup-include-settings').checked,
      includeLogs: qs('#backup-include-logs').checked,
      compress: qs('#backup-compress').checked,
      autoCleanup: qs('#backup-auto-cleanup').checked,
      maxCount: parseInt(qs('#backup-max-count').value) || MAX_BACKUPS_DEFAULT
    };

    localStorage.setItem('backup_settings', JSON.stringify(settings));
    console.log('Backup settings saved');
  }

  // Load backup settings
  function loadBackupSettings() {
    try {
      const settings = JSON.parse(localStorage.getItem('backup_settings') || '{}');

      if (qs('#backup-include-settings')) qs('#backup-include-settings').checked = settings.includeSettings !== false;
      if (qs('#backup-include-logs')) qs('#backup-include-logs').checked = settings.includeLogs !== false;
      if (qs('#backup-compress')) qs('#backup-compress').checked = settings.compress !== false;
      if (qs('#backup-auto-cleanup')) qs('#backup-auto-cleanup').checked = settings.autoCleanup === true;
      if (qs('#backup-max-count')) qs('#backup-max-count').value = settings.maxCount || MAX_BACKUPS_DEFAULT;
    } catch (e) {
      console.warn('Failed to load backup settings:', e);
    }
  }

  // Initialize backup system when page loads
  // Initialize Gantt controls event listeners
  function initGanttControls() {
    // Event listeners for Gantt controls
    const ganttRefreshBtn = qs('#gantt-refresh');
    if(ganttRefreshBtn){ ganttRefreshBtn.addEventListener('click', () => renderGantt()); }
    const ganttReplanAll = qs('#gantt-replan-all');
    if(ganttReplanAll){
      ganttReplanAll.addEventListener('click', ()=>{
        console.log('[replan] window.scheduleCore exists:', !!window.scheduleCore);
        if(!window.scheduleCore) return;
        if(typeof updateScheduleConfigFromUI==='function') updateScheduleConfigFromUI();
        if(!confirm('Przeliczyć wszystkie zadania od nowa? Spowoduje to reset ich start/end.')) return;
        (window.logDev||console.log)('[replan] starting global replan');
        try{
          window.scheduleCore.generateSchedule(state,{force:true});
          save(); renderGantt(); renderOrderPage();
          (window.logDev||console.log)('[replan] global completed');
        }catch(e){ console.error('[replan] error', e); }
      });
    }

    const ganttAutoAssignBtn = qs('#gantt-auto-assign');
    if(ganttAutoAssignBtn){ ganttAutoAssignBtn.addEventListener('click', () => autoAssignEmployeesToTasks()); }

    const ganttGenerateBtn = qs('#gantt-generate-test');
    if(ganttGenerateBtn){ ganttGenerateBtn.addEventListener('click', () => generateGanttTestData()); }

    const ganttViewSelect = qs('#gantt-view');
    if(ganttViewSelect){ ganttViewSelect.addEventListener('change', () => renderGantt()); }

    const ganttShowDependenciesBtn = qs('#gantt-show-dependencies');
    if(ganttShowDependenciesBtn){ ganttShowDependenciesBtn.addEventListener('click', () => toggleDependencies()); }

    const ganttCreateDependencyBtn = qs('#gantt-create-dependency');
    if(ganttCreateDependencyBtn){ ganttCreateDependencyBtn.addEventListener('click', () => toggleDependencyCreation()); }

    const ganttManageDependenciesBtn = qs('#gantt-manage-dependencies');
    if(ganttManageDependenciesBtn){ ganttManageDependenciesBtn.addEventListener('click', () => showDependencyManager()); }

    const ganttShowCriticalPathBtn = qs('#gantt-show-critical-path');
    if(ganttShowCriticalPathBtn){ ganttShowCriticalPathBtn.addEventListener('click', () => toggleCriticalPath()); }

    // Capacity Analysis event handlers
    const capacityRefreshBtn = qs('#capacity-refresh');
    if(capacityRefreshBtn){ capacityRefreshBtn.addEventListener('click', () => renderCapacityAnalysis()); }

    const capacityPeriodSelect = qs('#capacity-period');
    if(capacityPeriodSelect){ capacityPeriodSelect.addEventListener('change', () => renderCapacityAnalysis()); }

    const capacityExportBtn = qs('#capacity-export');
    if(capacityExportBtn){ capacityExportBtn.addEventListener('click', () => exportCapacityAnalysis()); }

    qs('#emp-add').addEventListener('click',()=>{
      const name = prompt('Imię i nazwisko');
      if (!name || !name.trim()) return;

      const trimmedName = name.trim();
      if (trimmedName.length < 2) {
        alert('Imię i nazwisko musi mieć co najmniej 2 znaki');
        return;
      }

      state.employees.push({id:uid(),name:trimmedName,cap:100,hoursPerDay:8});
      save();
      renderEmployees();
    });
  }

  document.addEventListener('DOMContentLoaded', function() {
    initBackupSystem();
    loadBackupSettings();
    setupAutoBackup();

    // Initialize Gantt controls event listeners
    initGanttControls();
  });

  // Event listeners for backup UI
  qs('#backup-create').addEventListener('click', () => {
    const name = prompt('Nazwa backupu (opcjonalnie):');
    if (name === null) return; // Cancelled

    const backupId = createBackup(name.trim() || null);
    if (backupId) {
      alert('Backup został utworzony pomyślnie!');
    }
  });

  qs('#backup-refresh').addEventListener('click', () => {
    renderBackupList();
    updateBackupStats();
  });

  qs('#backup-cleanup').addEventListener('click', () => {
    const removed = cleanupOldBackups();
    if (removed > 0) {
      alert(`Wyczyszczono ${removed} starych backupów!`);
    } else {
      alert('Brak starych backupów do wyczyszczenia.');
    }
  });

  const backupImportEl = qs('#backup-import');
  if (backupImportEl) {
    backupImportEl.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;

      try {
        await importBackupFromFile(file);
      } catch (error) {
        console.error('Import failed:', error);
        alert('Błąd podczas importu: ' + error.message);
      }

      // Reset input
      e.target.value = '';
    });
  }

  // Cleanup old backups
  function cleanupOldBackups() {
    try {
      const backups = getBackups();
      const maxCount = parseInt(qs('#backup-max-count').value) || MAX_BACKUPS_DEFAULT;

      if (backups.length <= maxCount) {
        console.log('No cleanup needed');
        return 0;
      }

      const removed = backups.splice(maxCount);
      localStorage.setItem(BACKUP_STORAGE_KEY, JSON.stringify(backups));
      renderBackupList();
      updateBackupStats();

      console.log(`Cleaned up ${removed.length} old backups`);
      return removed.length;
    } catch (e) {
      console.error('Failed to cleanup backups:', e);
      return 0;
    }
  }

  function showReportsProgress(show = true, text = 'Generowanie raportu...', percent = 0){
    const progressEl = qs('#reports-progress');
    const textEl = qs('#reports-progress-text');
    const percentEl = qs('#reports-progress-percent');
    const barEl = qs('#reports-progress-bar');
    
    if(show){
      progressEl.classList.remove('hidden');
      textEl.textContent = text;
      percentEl.textContent = percent + '%';
      barEl.style.width = percent + '%';
    } else {
      progressEl.classList.add('hidden');
    }
  }

  function renderReports(){
    showReportsProgress(true, 'Przygotowywanie danych...', 10);
    
    setTimeout(() => {
      showReportsProgress(true, 'Filtrowanie danych...', 30);
      
      setTimeout(() => {
        showReportsProgress(true, 'Obliczanie statystyk...', 60);
        
        setTimeout(() => {
          showReportsProgress(true, 'Generowanie wykresów...', 80);
          
          setTimeout(() => {
            showReportsProgress(true, 'Finalizowanie...', 100);
            
            setTimeout(() => {
              // Tutaj wykonaj rzeczywistą logikę
              const period = qs('#report-period').value || 'month';
              const now = new Date();
              let startDate, endDate;

              // Oblicz zakres dat na podstawie wybranego okresu
              switch(period){
                case 'week':
                  startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                  endDate = now;
                  break;
                case 'month':
                  startDate = new Date(now.getFullYear(), now.getMonth(), 1);
                  endDate = new Date(now.getFullYear(), now.getMonth() + 1, 0);
                  break;
                case 'quarter':
                  const quarterStart = Math.floor(now.getMonth() / 3) * 3;
                  startDate = new Date(now.getFullYear(), quarterStart, 1);
                  endDate = new Date(now.getFullYear(), quarterStart + 3, 0);
                  break;
                case 'year':
                  startDate = new Date(now.getFullYear(), 0, 1);
                  endDate = new Date(now.getFullYear(), 11, 31);
                  break;
              }

              // Filtruj dane dla wybranego okresu
              const filteredTasks = state.tasks.filter(task => {
                if(!task.createdAt) return true; // zadania bez daty traktuj jako aktualne
                const taskDate = new Date(task.createdAt);
                return taskDate >= startDate && taskDate <= endDate;
              });

              const filteredOrders = state.orders.filter(order => {
                if(!order.startDate) return true;
                const orderDate = new Date(order.startDate);
                return orderDate >= startDate && orderDate <= endDate;
              });

              // Generuj statystyki
              generateReportStats(filteredTasks, filteredOrders, period);
              generateEmployeePerformance(filteredTasks, period);
              generateCostReport(filteredTasks, period);
              generateDetailedStats(filteredTasks, filteredOrders, period);
              
              showReportsProgress(false);
            }, 200);
          }, 300);
        }, 300);
      }, 300);
    }, 200);
  }

  function generateReportStats(tasks, orders, period){
    const totalOrders = orders.length;
    const completedTasks = tasks.filter(t => t.status === 'done').length;
    const totalTasks = tasks.length;
    const totalEstimatedTime = tasks.reduce((sum, t) => sum + (t.estMin || 0), 0);
    const totalActualTime = tasks.reduce((sum, t) => sum + (t.elapsedMin || 0), 0);
    const efficiency = totalEstimatedTime > 0 ? Math.round((totalActualTime / totalEstimatedTime) * 100) : 0;

    qs('#stat-total-orders').textContent = totalOrders;
    qs('#stat-completed-tasks').textContent = completedTasks;
    qs('#stat-efficiency').textContent = `${efficiency}%`;
  }

  function generateEmployeePerformance(tasks, period){
    const container = qs('#report-employee-performance');
    const employees = state.employees || [];

    if(employees.length === 0){
      container.innerHTML = '<div class="empty">Brak danych o pracownikach</div>';
      return;
    }

    // Oblicz wydajność dla każdego pracownika
    const performance = employees.map(emp => {
      const empTasks = tasks.filter(t => t.assignees && t.assignees.some(a => a.id === emp.id));
      const completedTasks = empTasks.filter(t => t.status === 'done').length;
      const totalTasks = empTasks.length;
      const totalTime = empTasks.reduce((sum, t) => sum + (t.elapsedMin || 0), 0);
      const efficiency = totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0;

      return {
        name: emp.name,
        completedTasks,
        totalTasks,
        totalTime: Math.round(totalTime / 60 * 10) / 10, // w godzinach
        efficiency
      };
    }).sort((a, b) => b.efficiency - a.efficiency);

    // Generuj HTML
    let html = '<div style="display:flex;flex-direction:column;gap:8px">';
    performance.forEach(emp => {
      const barWidth = Math.min(emp.efficiency, 100);
      html += `
        <div style="display:flex;align-items:center;gap:12px">
          <div style="width:120px;font-weight:500">${emp.name}</div>
          <div style="flex:1;background:#e5e7eb;border-radius:4px;height:20px;overflow:hidden">
            <div style="width:${barWidth}%;height:100%;background:${emp.efficiency >= 80 ? 'var(--ok)' : emp.efficiency >= 60 ? 'var(--warn)' : 'var(--err)'};transition:width 0.3s"></div>
          </div>
          <div style="width:80px;text-align:right;font-size:12px;color:#94a3b8">${emp.efficiency}%</div>
          <div style="width:100px;text-align:right;font-size:12px;color:#94a3b8">${emp.completedTasks}/${emp.totalTasks} zadań</div>
        </div>
      `;
    });
    html += '</div>';

    container.innerHTML = html;
  }

  function generateCostReport(tasks, period){
    const container = qs('#report-costs');

    // Proste obliczenia kosztów (można rozszerzyć o rzeczywiste stawki)
    const hourlyRate = 25; // zł/h - przykładowa stawka
    const totalHours = tasks.reduce((sum, t) => sum + (t.elapsedMin || 0), 0) / 60;
    const totalCost = Math.round(totalHours * hourlyRate);

    const completedTasks = tasks.filter(t => t.status === 'done').length;
    const costPerTask = completedTasks > 0 ? Math.round(totalCost / completedTasks) : 0;

    container.innerHTML = `
      <div class="grid3">
        <div class="card" style="text-align:center">
          <div style="font-size:20px;font-weight:bold;color:var(--acc)">${Math.round(totalHours)}h</div>
          <div style="color:var(--text-secondary)">Całkowity czas pracy</div>
        </div>
        <div class="card" style="text-align:center">
          <div style="font-size:20px;font-weight:bold;color:var(--ok)">${totalCost} zł</div>
          <div style="color:var(--text-secondary)">Całkowity koszt</div>
        </div>
        <div class="card" style="text-align:center">
          <div style="font-size:20px;font-weight:bold;color:var(--warn)">${costPerTask} zł</div>
          <div style="color:var(--text-secondary)">Średni koszt zadania</div>
        </div>
      </div>
    `;
  }

  function generateDetailedStats(tasks, orders, period){
    const container = qs('#report-details');

    // Grupuj zadania według statusu
    const statusStats = {
      todo: tasks.filter(t => t.status === 'todo').length,
      run: tasks.filter(t => t.status === 'run').length,
      done: tasks.filter(t => t.status === 'done').length
    };

    // Oblicz średnie czasy
    const completedTasks = tasks.filter(t => t.status === 'done' && t.elapsedMin > 0);
    const avgCompletionTime = completedTasks.length > 0
      ? Math.round(completedTasks.reduce((sum, t) => sum + t.elapsedMin, 0) / completedTasks.length / 60 * 10) / 10
      : 0;

    const html = `
      <table>
        <thead>
          <tr>
            <th>Metryka</th>
            <th>Wartość</th>
            <th>Opis</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Całkowita liczba zleceń</td>
            <td>${orders.length}</td>
            <td>Zlecenia w wybranym okresie</td>
          </tr>
          <tr>
            <td>Zadania do wykonania</td>
            <td>${statusStats.todo}</td>
            <td>Zadania oczekujące</td>
          </tr>
          <tr>
            <td>Zadania w trakcie</td>
            <td>${statusStats.run}</td>
            <td>Zadania aktualnie wykonywane</td>
          </tr>
          <tr>
            <td>Zadania ukończone</td>
            <td>${statusStats.done}</td>
            <td>Zadania zakończone</td>
          </tr>
          <tr>
            <td>Średni czas wykonania</td>
            <td>${avgCompletionTime}h</td>
            <td>Średni czas na ukończone zadanie</td>
          </tr>
          <tr>
            <td>Łączny szacowany czas</td>
            <td>${Math.round(tasks.reduce((sum, t) => sum + (t.estMin || 0), 0) / 60)}h</td>
            <td>Całkowity planowany czas pracy</td>
          </tr>
        </tbody>
      </table>
    `;

    container.innerHTML = html;
  }

  function exportReportToPDF(){
    showReportsProgress(true, 'Przygotowywanie danych do eksportu...', 20);
    
    setTimeout(() => {
      showReportsProgress(true, 'Generowanie zawartości PDF...', 60);
      
      setTimeout(() => {
        showReportsProgress(true, 'Otwieranie okna drukowania...', 90);
        
        setTimeout(() => {
          // Prosta implementacja eksportu - otwórz w nowym oknie i użyj drukowania do PDF
          const reportWindow = window.open('', '_blank');
          const reportContent = qs('#reports-content').innerHTML;
          
          const html = `<html>
            <head>
              <title>Raport produkcyjny - ${new Date().toLocaleDateString('pl-PL')}</title>
              <style>
                body { font-family: Arial, sans-serif; margin: 20px; }
                .card { border: 1px solid #ddd; padding: 16px; margin-bottom: 16px; border-radius: 8px; }
                h4 { margin-top: 0; color: #333; }
                table { width: 100%; border-collapse: collapse; margin-top: 16px; }
                th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
                th { background-color: #f5f5f5; }
                .grid3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; }
                .card { text-align: center; }
                @media print { body { margin: 0; } }
              </style>
              <style>
              /* === High contrast warning callout === */
              .callout-warn{background:#fef3c7;border:1px solid #f59e0b;color:#1f2937;}
              .callout-warn h4{margin-top:0;color:#92400e;}
              .callout-warn strong{color:#92400e;}
              .callout-warn.high-contrast{background:#1e293b;border-color:#fbbf24;color:#f8fafc;}
              .callout-warn.high-contrast h4{color:#fbbf24;}
              .callout-warn.high-contrast strong{color:#fbbf24;}
              .callout-warn.high-contrast a, .callout-warn.high-contrast code{color:#fde68a;}
              #high-contrast-toggle-wrapper{margin:8px 0 16px;}
              #high-contrast-toggle-wrapper label{display:flex;align-items:center;gap:6px;font-size:13px;color:#cbd5e1;cursor:pointer;}
              </style>
            </head>
            <body>
              <h2>Raport produkcyjny</h2>
              <p>Okres: ${qs('#report-period').value} | Data wygenerowania: ${new Date().toLocaleString('pl-PL')}</p>
              ${reportContent}
            </body>
          </html>`;
          
          reportWindow.document.write(html);
          
          reportWindow.document.close();
          reportWindow.print();
          
          showReportsProgress(false);
        }, 300);
      }, 300);
    }, 200);
  }
  
  function renderASPage(){
  const sel=qs('#as-order'); if(sel){ sel.innerHTML=''; (state.orders||[]).forEach(o=>{ const opt=document.createElement('option'); opt.value=o.id; opt.textContent=(o.name?(''+o.name):o.id); sel.appendChild(opt); });
      // when order selection changes, copy phone/placecode automatically
      sel.addEventListener('change',()=>{
        const oid = sel.value; const ord = (state.orders||[]).find(x=>x.id===oid) || {};
        if(ord){ if(qs('#as-order-phone')) qs('#as-order-phone').value = ord.phone || ord.orderPhone || ''; if(qs('#as-order-placecode')) qs('#as-order-placecode').value = ord.postalCode || ord.post || ''; }
      });
    }
    const host=qs('#as-list'); if(!host) return; host.innerHTML='';
    (state.after||[]).slice().reverse().forEach(a=>{
      const d=document.createElement('div'); d.className='card';
      const orderObj = (state.orders||[]).find(o=>o.id===a.order) || {};
      const placeCode = orderObj.placeCode || orderObj.placecode || a.postalCode || '';
      const phone = a.phone || orderObj.phone || '';
      const address = a.address || orderObj.address || '';
      d.innerHTML=`<div class="row" style="justify-content:space-between"><div><b>${a.type}</b> • ${a.status} • ${orderObj.name||a.order||''}
      <div class="muted">Montaż: ${a.installDate||'-'} • wyjazd: ${a.departTime||'-'} • wizyta: ${a.visitTime||'-'}</div>
      <div class="muted">Adres: ${address || '-'} • Kod miejsca: ${placeCode || '-'} • Telefon: ${phone || '-'}</div>
      <div class="muted">${a.desc||''}</div></div><div><button class="btn" data-as-ed="${a.id}">Edytuj</button> <button class="btn red" data-as-del="${a.id}">Usuń</button></div></div>`;
      host.appendChild(d);
    });
  }
  qs('#as-form').addEventListener('submit',(ev)=>{
    ev.preventDefault(); const id=qs('#as-id').value||uid(); const type=qs('#as-type').value; const order=qs('#as-order').value||''; const status=qs('#as-status').value; const desc=qs('#as-desc').value||''; const install=qs('#as-install').value||''; const depart=qs('#as-go').value||''; const visit=qs('#as-visit').value||'';
    // copy phone/placecode from selected order if present
    const orderObj = (state.orders||[]).find(o=>o.id===order) || {};
    const asPhone = qs('#as-order-phone')?qs('#as-order-phone').value:(orderObj.phone||orderObj.orderPhone||'');
    const asPlace = qs('#as-order-placecode')?qs('#as-order-placecode').value:(orderObj.placeCode||orderObj.placecode||'');
    const ex=state.after.find(x=>x.id===id); const payload={id,type,order,status,desc,installDate:install,departTime:depart,visitTime:visit,phone:asPhone,postalCode:asPlace};
    if(ex) Object.assign(ex,payload); else state.after.push(payload);
    // optional immediate save after AS save
    maybeAutoSave('as-save');
    save(); ev.target.reset(); renderASPage();
  });

  function renderMRPPage(){
    const list = qs('#mrp-list');
    if (!list) return;
    list.innerHTML = '';
    const mrp = new Map();

    (state.orders || []).forEach(order => {
      if (order.processId && order.quantity > 0) {
        const process = state.processes.find(p => p.id === order.processId);
        if (process) {
          (process.operations || []).forEach(procOp => {
            const opCatEntry = state.operationsCatalog.find(op => op.name === procOp.name);
            if (opCatEntry && opCatEntry.skills) {
              opCatEntry.skills.forEach(skill => {
                const currentQty = mrp.get(skill) || 0;
                mrp.set(skill, currentQty + order.quantity);
              });
            }
          });
        }
      }

      function buildEmployeeText(empId){
        const emp = (state.employees||[]).find(e=>e.id===empId) || {id:empId,name:empId};
        const lines = [];
        lines.push(`${emp.name} — Zadania`);
        lines.push(`Data: ${new Date().toLocaleDateString()}`);
        lines.push('');
        const tasks = [];
        (state.processes||[]).forEach(proc=>{ (proc.operations||[]).forEach(op=>{ if(op.assignee && (op.assignee.id||op.assignee)===empId){ tasks.push({title:op.name,ctx:proc.name,time:op.time||0}); } }); });
        (state.tasks||[]).forEach(t=>{ const as = t.assignees || (t.assignee ? [t.assignee] : []); if(Array.isArray(as) && as.some(a=> (a.id||a)===empId)){ tasks.push({title:t.opName,ctx:(state.orders||[]).find(o=>o.id===t.orderId)?.name||t.orderId,time:t.estMin||t.elapsedMin||0}); } });
        if(tasks.length===0){ lines.push('Brak przypisanych zadań.'); }
        else{ tasks.forEach((tk,i)=>{ lines.push(`${i+1}. ${tk.title} — ${tk.ctx} — ${tk.time}m`); }); }
        lines.push(''); lines.push('Powodzenia!');
        return lines.join('\n');
      }

      function copyToClipboard(text){ if(navigator.clipboard && navigator.clipboard.writeText){ navigator.clipboard.writeText(text).catch(()=>{ const ta=document.createElement('textarea'); ta.value=text; document.body.appendChild(ta); ta.select(); document.execCommand('copy'); ta.remove(); }); } else { const ta=document.createElement('textarea'); ta.value=text; document.body.appendChild(ta); ta.select(); document.execCommand('copy'); ta.remove(); } }
    });

    if (mrp.size === 0) {
      list.innerHTML = '<div class="muted">Brak komponentów do zamówienia. Sprawdź, czy zlecenia mają przypisany proces i operacje zawierają komponenty.</div>';
      return;
    }

    const mrpItems = Array.from(mrp.entries()).sort((a, b) => a[0].localeCompare(b[0]));
    const tableHtml = `
      <div class="table">
        <table>
          <thead><tr><th>Komponent</th><th>Ilość</th></tr></thead>
          <tbody>
            ${mrpItems.map(([item, qty]) => `<tr><td>${item}</td><td>${qty}</td></tr>`).join('')}
          </tbody>
        </table>
      </div>
    `;
    list.innerHTML = tableHtml;
  }

  // Monitoring: show simple metrics and detect candidate bottlenecks
  function renderMonitor(){
    const host = qs('#p-monitor'); if(!host) return;
    host.innerHTML = '';
  const header = document.createElement('div'); header.className='row'; header.style.justifyContent='space-between';
  const title = document.createElement('div'); title.innerHTML = '<h3>Monitoring postępów</h3>'; header.appendChild(title);
  const ctrl = document.createElement('div'); ctrl.className='row';
  const refreshBtn = document.createElement('button'); refreshBtn.className='btn'; refreshBtn.textContent='Odśwież'; refreshBtn.addEventListener('click', ()=>{ renderMonitor(); });
  const exportBtn = document.createElement('button'); exportBtn.className='btn'; exportBtn.textContent='Eksport CSV'; exportBtn.style.marginLeft='6px';
  exportBtn.addEventListener('click', ()=>{ exportMonitorCSV(); });
  const filterInput = document.createElement('input'); filterInput.id='monitor-filter-input'; filterInput.placeholder='Filtruj operacje...'; filterInput.style.width='220px'; filterInput.style.marginLeft='8px';
  filterInput.value = qs('#monitor-filter-input')? qs('#monitor-filter-input').value : '';
  filterInput.addEventListener('input', ()=>{ renderMonitor(); });
  ctrl.appendChild(filterInput); ctrl.appendChild(refreshBtn); ctrl.appendChild(exportBtn);
  header.appendChild(ctrl);
  host.appendChild(header);

    const totalOrders = (state.orders||[]).length;
    const totalTasks = (state.tasks||[]).length;
    const running = (state.tasks||[]).filter(t=>t.status==='run').length;
    const todo = (state.tasks||[]).filter(t=>!t.status || t.status==='todo').length;

    const metrics = document.createElement('div'); metrics.className='grid3'; metrics.style.marginTop='8px';
    metrics.innerHTML = `<div class="card"><div><b>Zlecenia</b></div><div class="pill">${totalOrders}</div></div><div class="card"><div><b>Zadania</b></div><div class="pill">${totalTasks}</div></div><div class="card"><div><b>W toku / oczekujące</b></div><div class="muted">run: ${running} • todo: ${todo}</div></div>`;
    host.appendChild(metrics);

    const opStats = new Map();
    (state.operationsCatalog||[]).forEach(op=>{ opStats.set(op.name, { name: op.name, id: op.id, countTodo:0, countRun:0, totalEst:0, totalElapsed:0, avgElapsed:0 }); });
    (state.tasks||[]).forEach(t=>{
      const key = t.opName || '(unknown)';
      if(!opStats.has(key)) opStats.set(key, { name:key, id:null, countTodo:0, countRun:0, totalEst:0, totalElapsed:0, avgElapsed:0 });
      const s = opStats.get(key);
      if(t.status==='run') s.countRun++; else s.countTodo++;
      s.totalEst += (t.estMin||0);
      s.totalElapsed += (t.elapsedMin||0);
    });
    opStats.forEach(s=>{ const totalCount = s.countRun + s.countTodo; s.avgElapsed = totalCount? Math.round(s.totalElapsed/Math.max(1,totalCount)) : 0; });
    const statArr = Array.from(opStats.values()).filter(s=> (s.countRun + s.countTodo) > 0 );
    statArr.sort((a,b)=> (b.countRun + b.countTodo) - (a.countRun + a.countTodo) || b.avgElapsed - a.avgElapsed);
  const filterVal = (qs('#monitor-filter-input') && qs('#monitor-filter-input').value) ? (qs('#monitor-filter-input').value||'').toLowerCase() : '';
  const filtered = filterVal ? statArr.filter(s=> (s.name||'').toLowerCase().indexOf(filterVal)!==-1) : statArr;
  const top = filtered.slice(0,10);
    const tableWrap = document.createElement('div'); tableWrap.className='table'; tableWrap.style.marginTop='12px';
    const tbl = document.createElement('table'); tbl.innerHTML = `<thead><tr><th>Operacja</th><th>W kolejce</th><th>W toku</th><th>Est. sum</th><th>Śr. elapsed [m]</th></tr></thead><tbody></tbody>`;
    const tb = tbl.querySelector('tbody');
    top.forEach(s=>{ const tr=document.createElement('tr'); tr.innerHTML = `<td>${s.name}</td><td>${s.countTodo}</td><td>${s.countRun}</td><td>${s.totalEst}</td><td>${s.avgElapsed}</td>`; tb.appendChild(tr); });
    tableWrap.appendChild(tbl);
    host.appendChild(tableWrap);
    tableWrap.appendChild(tbl);
    host.appendChild(tableWrap);

    const sugg = document.createElement('div'); sugg.style.marginTop='10px';
    const threshold = (state.storage && state.storage.monitorThreshold) ? Number(state.storage.monitorThreshold) : 5;
    const heavy = statArr.filter(s=> (s.countTodo + s.countRun) >= threshold );
    if(heavy.length){
      sugg.innerHTML = `<div class="card err"><b>Potencjalne wąskie gardła:</b><div style="margin-top:6px">${heavy.map(s=>`${s.name} — ${s.countTodo + s.countRun} zadań`).join('<br>')}</div></div>`;
    } else {
      sugg.innerHTML = `<div class="card"><div class="muted">Brak wyraźnych wąskich gardeł (brak operacji z ≥${threshold} zadaniami).</div></div>`;
    }
    host.appendChild(sugg);

    // export CSV helper captures current heavy list
    function exportMonitorCSV(){
      const rows = heavy.map(s=>({operation:s.name, count: s.countTodo + s.countRun, totalEst: s.totalEst, avgElapsed: s.avgElapsed}));
      if(rows.length===0){ alert('Brak wąskich gardeł do eksportu.'); return; }
      const csv = ['operation,count,totalEst,avgElapsed'].concat(rows.map(r=>`"${(r.operation||'').replace(/"/g,'""')}",${r.count},${r.totalEst},${r.avgElapsed}`)).join('\n');
      const blob = new Blob([csv], {type:'text/csv'});
      const url = URL.createObjectURL(blob);
      const pad = n=>String(n).padStart(2,'0');
      const d = new Date();
      const ts = `${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
      const th = state.storage && state.storage.monitorThreshold ? state.storage.monitorThreshold : 'x';
      const filename = `monitor_bottlenecks_${ts}_th${th}.csv`;
      const a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); a.remove();
      try{
        const existing = qs('#monitor-export-toast'); if(existing) existing.remove();
  const t = document.createElement('div'); t.id = 'monitor-export-toast'; t.className = 'card'; t.style.position='fixed'; t.style.right='12px'; t.style.top='80px'; t.style.zIndex='99999'; t.style.padding='8px 12px';
  t.innerHTML = `<div style="display:flex;gap:8px;align-items:center"><div>Eksport monitoringu utworzony:</div><div style="font-weight:700">${filename}</div><button id="monitor-export-copy" class="btn" style="margin-left:8px">Kopiuj nazwę</button></div>`;
  t.setAttribute('data-filename', filename);
  document.body.appendChild(t);
  try{ const copyBtn = qs('#monitor-export-copy'); if(copyBtn){ copyBtn.addEventListener('click', async ()=>{ try{ await navigator.clipboard.writeText(filename); copyBtn.textContent='Skopiowano'; setTimeout(()=>copyBtn.textContent='Kopiuj nazwę',1000); }catch(_){ try{ const ta=document.createElement('textarea'); ta.value = filename; document.body.appendChild(ta); ta.select(); document.execCommand('copy'); ta.remove(); copyBtn.textContent='Skopiowano'; setTimeout(()=>copyBtn.textContent='Kopiuj nazwę',1000); }catch(__){} } }); } }catch(_){ }
  setTimeout(()=>{ const el = qs('#monitor-export-toast'); if(el) el.remove(); }, 3500);
      }catch(_){ }
      setTimeout(()=>{ try{ URL.revokeObjectURL(url); }catch(_){ } }, 2000);
    }

    // alerts banner
    if((state.storage && state.storage.monitorAlertsEnabled) !== false && heavy.length){
      const banner = document.createElement('div'); banner.className='card err'; banner.style.marginTop='8px'; banner.innerHTML = `<b>ALERT:</b> Zidentyfikowano ${heavy.length} operacji przekraczających threshold (${state.storage.monitorThreshold||5}).`;
      host.appendChild(banner);
    }

    // clickable rows: clicking shows detail list for that operation
    tb.querySelectorAll('tr').forEach((tr, idx)=>{
      tr.style.cursor = 'pointer';
      tr.addEventListener('click', ()=>{
        const existing = qs('#monitor-op-detail'); if(existing) existing.remove();
        const op = top[idx];
        const detail = document.createElement('div'); detail.id = 'monitor-op-detail'; detail.className = 'card'; detail.style.marginTop = '8px';
        const tasks = (state.tasks||[]).filter(t=> (t.opName||'') === op.name );
        if(tasks.length===0){ detail.innerHTML = `<div class="muted">Brak konkretnych zadań dla operacji: ${op.name}</div>`; }
        else{
          detail.innerHTML = `<div><b>Szczegóły: ${op.name}</b> • zadań: ${tasks.length}</div><div style="margin-top:8px">` + tasks.map(t=>`<div>${t.opName} • ${ (state.orders||[]).find(o=>o.id===t.orderId)?.name || t.orderId } • status: ${t.status||'todo'} • est:${t.estMin||0}m • elapsed:${Math.round(t.elapsedMin||0)}m</div>`).join('') + '</div>';
        }
        host.appendChild(detail);
      });
    });
  }

  async function loadScript(src){
    return new Promise((res,rej)=>{
      console.log('Ładowanie skryptu:', src);
      const s=document.createElement('script');
      s.src=src;
      s.onload=()=>{ console.log('Skrypt załadowany:', src); res(); };
      s.onerror=(e)=>{ console.error('Błąd ładowania skryptu:', src, e); rej(new Error('Load fail '+src)); };
      document.head.appendChild(s);
    });
  }
  async function ensureFirebase(){
    if(window.firebase&&firebase.apps&&firebase.apps.length){return true;}
    try{
      const cfg=state.storage.fbConfig||{}; if(!cfg.apiKey) throw new Error('Brak config');
      
      // Sprawdź czy jesteśmy na localhost - jeśli tak, ostrzeż o potencjalnych problemach
      const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
      if(isLocalhost && window.location.protocol !== 'https:'){
        console.warn('Firebase może nie działać poprawnie na HTTP localhost. Rozważ użycie HTTPS lub trybu offline.');
        // Na localhost automatycznie przełącz na localStorage dla lepszego UX
        if(state.storage.mode === 'firebase'){
          console.log('Wykryto localhost - automatycznie przełączam na localStorage dla lepszego działania');
          state.storage.mode = 'localStorage';
          qs('#set-mode').value = 'localStorage';
          save();
          updateConnectionStatus();
          return false;
        }
      }
      
      await loadScript('https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js');
      await loadScript('https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js');
      await loadScript('https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js');
      if(!firebase.apps.length){firebase.initializeApp(cfg);}
      return true;
    }catch(e){
      console.warn('Firebase load/init error:',e.message);
      qs('#set-info').textContent='⚠️ Firebase niedostępny - przełączono na tryb offline (localStorage)';
      
      // Automatycznie przełącz na localStorage gdy Firebase nie działa
      if(state.storage.mode === 'firebase'){
        state.storage.mode = 'localStorage';
        qs('#set-mode').value = 'localStorage';
        save();
        updateConnectionStatus();
        console.log('Automatycznie przełączono na tryb localStorage');
      }
      
      return false;
    }
  }
  function fbRoot(){return firebase.firestore().collection('planner').doc(state.storage.appId).collection('users').doc(state.storage.userId);}
  async function saveToDB(){
    if(state.storage.mode!=='firebase'){qs('#set-info').textContent='Tryb localStorage (offline)';return;}
    const ok=await ensureFirebase(); if(!ok){return;}
    try {
      const db=firebase.firestore(); const batch=db.batch(); const r=fbRoot();
      const up=(name,arr)=> (arr||[]).forEach(x=>{if(!x.id) x.id=uid(); batch.set(r.collection(name).doc(x.id), JSON.parse(JSON.stringify(x)), {merge:true});});
      up('employees',state.employees); up('operationsCatalog',state.operationsCatalog); up('processes',state.processes);
      up('orders',state.orders); up('tasks',state.tasks); up('after',state.after);
      await batch.commit();
      qs('#set-info').textContent='✅ Zapisano kolekcje do DB.';
    } catch(e) {
      qs('#set-info').textContent='❌ Błąd zapisu do DB: '+e.message;
    }
  }
  // Save single task document to Firestore (merge)
  async function _saveTaskToDB_once(taskId){
    const ok = await ensureFirebase(); if(!ok) throw new Error('Firebase not ready');
    const t = (state.tasks||[]).find(x=>x.id===taskId); if(!t) throw new Error('task not found');
    const payload = JSON.parse(JSON.stringify(t));
    await fbRoot().collection('tasks').doc(taskId).set(payload, { merge: true });
  }

  async function saveTaskToDB(taskId, opts){
    if(!taskId) return;
    if(state.storage.mode !== 'firebase') return;
    const attempts = (opts && opts.attempts) || 3;
    const base = (opts && opts.baseDelayMs) || 500;
    const t = (state.tasks||[]).find(x=>x.id===taskId);
    if(!t) return;
    t._syncPending = true; t._syncError = false; save(); try{ renderTasks(); }catch(_){ }
    let lastErr = null;
    for(let i=0;i<attempts;i++){
      try{ await _saveTaskToDB_once(taskId); t._syncPending = false; t._lastSync = Date.now(); t._syncError = false; save(); try{ renderTasks(); }catch(_){ } (window.logDev||console.log)('[saveTaskToDB] saved', taskId, 'attempt', i+1); return; }
      catch(e){ lastErr = e; (window.logDev||console.warn)('saveTaskToDB attempt failed', i+1, e && e.message); if(i < attempts - 1){ const delay = base * Math.pow(2, i); await new Promise(r=>setTimeout(r, delay)); } }
    }
    try{ t._syncPending = false; t._syncError = true; save(); try{ renderTasks(); }catch(_){ } }catch(_){ }
    console.warn('saveTaskToDB all attempts failed', lastErr && lastErr.message);
    throw lastErr;
  }

  // Subscribe to tasks collection updates from Firestore and merge into local state
  async function subscribeToTaskUpdates(){
    if(state.storage.mode !== 'firebase') return;
    let isInitialLoad = true;
    try{
      const ok = await ensureFirebase(); if(!ok) return;
      if(window._tasksUnsub) try{ window._tasksUnsub(); }catch(_){ }
      const col = fbRoot().collection('tasks');
      window._tasksUnsub = col.onSnapshot(snapshot=>{
        try{
          snapshot.docChanges().forEach(ch=>{
            const data = Object.assign({id: ch.doc.id}, ch.doc.data());
            if(ch.type === 'added' || ch.type === 'modified'){
              const idx = (state.tasks||[]).findIndex(t=>t.id === data.id);
              if(idx >= 0){ state.tasks[idx] = Object.assign({}, state.tasks[idx], data); }
              else if(!isInitialLoad || ch.type === 'modified') { state.tasks = state.tasks || []; state.tasks.push(data); }
            } else if(ch.type === 'removed'){
              state.tasks = (state.tasks||[]).filter(t=>t.id !== data.id);
            }
          });
          isInitialLoad = false;
          snapshot.docs.forEach(d=>{
            const id = d.id; const idx = (state.tasks||[]).findIndex(t=>t.id===id);
            if(idx>=0){ state.tasks[idx]._lastSync = Date.now(); state.tasks[idx]._syncPending = false; state.tasks[idx]._syncError = false; }
          });
          save(); try{ renderTasks(); renderMonitor && renderMonitor(); }catch(_){ }
        }catch(e){ console.warn('subscribeToTaskUpdates snapshot error', e && e.message); }
      }, err=>{ console.warn('tasks onSnapshot error', err && err.message); });
      (window.logDev||console.log)('[subscribeToTaskUpdates] subscribed');
    }catch(e){ console.warn('subscribeToTaskUpdates error', e && e.message); }
  }

  (async function autoSubscribeIfNeeded(){ try{ if(state.storage && state.storage.mode==='firebase' && state.storage.autoLoadFromDB){ await subscribeToTaskUpdates(); } }catch(e){ console.warn('autoSubscribeIfNeeded err', e && e.message); } })();
  async function loadFromDB(){
    if(state.storage.mode!=='firebase'){qs('#set-info').textContent='Tryb localStorage (offline)';return;}
    const ok=await ensureFirebase(); if(!ok){return;}
    try {
      const r=fbRoot();
      const getAll=async(name)=>(await r.collection(name).get()).docs.map(d=>({id:d.id,...d.data()}));
      const [employees,operationsCatalog,processes,orders,tasks,after]=await Promise.all([
        getAll('employees'),getAll('operationsCatalog'),getAll('processes'),getAll('orders'),getAll('tasks'),getAll('after')
      ]);
      Object.assign(state,{employees,operationsCatalog,processes,orders,tasks,after});
      save();
      qs('#set-info').textContent='✅ Wczytano dane z DB.';
      if(state.page==='order') renderOrderPage(); if(state.page==='tasks') renderTasks(); if(state.page==='opcat') renderOps();
  if(state.page==='proc') renderProcPage(); if(state.page==='emp') renderEmployees(); if(state.page==='as') renderASPage(); renderDash(); renderGantt();
    } catch(e) {
      qs('#set-info').textContent='❌ Błąd wczytywania z DB: '+e.message;
    }
  }
  qs('#set-test').addEventListener('click',async()=>{
    try{
  state.storage.mode=qs('#set-mode').value; state.storage.appId=qs('#set-appid').value.trim(); state.storage.userId=qs('#set-userid').value.trim();
  if(typeof updateScheduleConfigFromUI === 'function'){ updateScheduleConfigFromUI(); }
  try{ if(window.scheduleCore){ window.scheduleCore.generateSchedule(state); } }catch(e){ console.warn('regen schedule', e.message); }
  renderGantt();
      try{state.storage.fbConfig=JSON.parse(qs('#set-fb').value||'{}');}catch(e){qs('#set-info').textContent='Błędny JSON';return;}
      save(); updateConnectionStatus(); if(state.storage.mode!=='firebase'){qs('#set-info').textContent='Tryb localStorage (offline)';return;}
      const ok=await ensureFirebase(); if(!ok) throw new Error('Firebase init failed');
      const cred=await firebase.auth().signInAnonymously(); qs('#set-info').textContent='✅ Połączono. UID: '+(cred.user&&cred.user.uid);
    }catch(e){qs('#set-info').textContent='❌ Błąd: '+e.message;}
  });
  qs('#set-save').addEventListener('click',saveToDB);
  qs('#set-load').addEventListener('click',loadFromDB);

  // Export/import tasks and assignments
  function exportTasks(){
    const payload = { exportedAt: new Date().toISOString(), tasks: state.tasks || [], assignments: (state.tasks||[]).map(t=>({id:t.id,assignees:t.assignees||[]})) };
    const blob=new Blob([JSON.stringify(payload,null,2)],{type:'application/json'});
    const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='tasks_export_'+(new Date().toISOString().slice(0,10))+'.json'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  }
  async function importTasksFromFile(file){
    try{
      const text = await file.text(); const obj = JSON.parse(text);
      if(!obj || !Array.isArray(obj.tasks)) { alert('Nieprawidłowy plik'); return; }
      // Merge: replace tasks, but preserve employees and orders mapping
      state.tasks = obj.tasks.map(t=>({id:t.id||uid(), orderId:t.orderId||'', opName:t.opName||'', status:t.status||'todo', elapsedMin:t.elapsedMin||0, estMin:t.estMin||0, assignees:t.assignees||[]}));
      save(); renderTasks(); maybeAutoSave('import-tasks');
      alert('Zaimportowano zadania: '+state.tasks.length);
    }catch(e){ alert('Błąd importu: '+e.message); }
  }
  qs('#export-tasks').addEventListener('click',exportTasks);
  qs('#import-tasks').addEventListener('click',()=>qs('#import-tasks-file').click());
  qs('#import-tasks-file').addEventListener('change',(ev)=>{ const f=ev.target.files&&ev.target.files[0]; if(f) importTasksFromFile(f); });
  qs('#restore-click-delegation').addEventListener('click', () => {
    window.restoreNormalClickDelegation();
    alert('Przywrócono normalną obsługę kliknięć! Spróbuj teraz kliknąć w inne przyciski.');
  });
  qs('#capacity-refresh').addEventListener('click', () => renderCapacityAnalysis());
  qs('#capacity-optimize').addEventListener('click', () => {
    const suggestions = calculateOptimizationSuggestions();
    if(suggestions.length === 0){
      alert('Obciążenie jest już zoptymalizowane! 🎉');
    } else {
      alert(`Znaleziono ${suggestions.length} sugestii optymalizacji. Sprawdź sekcję "Sugestie optymalizacji obciążenia".`);
      renderOptimizationSuggestions(suggestions);
    }
  });
  qs('#capacity-export').addEventListener('click', () => {
    const utilization = calculateResourceUtilization(qs('#capacity-period').value || 'week');
    if(utilization.length === 0){ alert('Brak danych do eksportu.'); return; }
    const csv = ['employee,totalTasks,totalTimeH,availableTimeH,utilizationPercent,status'].concat(
      utilization.map(u => `"${u.employee}","${u.totalTasks}","${(u.totalTime/60).toFixed(1)}","${(u.availableTime/60).toFixed(1)}","${u.utilization}","${u.status}"`)
    ).join('\n');
    const blob = new Blob([csv], {type:'text/csv'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'capacity_analysis_' + new Date().toISOString().slice(0,10) + '.csv';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  });
  qs('#restore-authentic-data').addEventListener('click', () => {
    if (confirm('Czy na pewno chcesz przywrócić autentyczne dane? To nadpisze wszystkie obecne dane w aplikacji.')) {
      restoreAuthenticData();
    }
  });

  // Reports event handlers
  const reportGenerateTestBtn = qs('#report-generate-test');
  if(reportGenerateTestBtn){ 
    reportGenerateTestBtn.addEventListener('click', () => {
      generateGanttTestData(); // Używa istniejącej funkcji
      renderReports();
    });
  }
  
  const reportGenerateBtn = qs('#report-generate');
  if(reportGenerateBtn){ 
    reportGenerateBtn.addEventListener('click', () => {
      renderReports();
    });
  }
  
  const reportExportBtn = qs('#report-export');
  if(reportExportBtn){ 
    reportExportBtn.addEventListener('click', () => {
      exportReportToPDF();
    });
  }

  nav(state.page||'dash'); renderDash(); renderGantt();
})();

  // After initial render, optionally auto-load data from Firebase when configured
  (async function autoLoadIfNeeded(){
    try{
      if(state.storage.mode==='firebase' && state.storage.autoLoadFromDB){
        window.logDev && window.logDev('[auto-load] Wczytywanie danych z Firebase...'); busy(true);
        await loadFromDB();
        window.logDev && window.logDev('[auto-load] Wczytano dane z Firebase.');
      }
    }catch(e){ window.logDev && window.logDev('[auto-load] Błąd:', e && e.message); }
    finally{ busy(false); }
  })();
  console.log('build v5.0');

  // Check if backup functions are available before assigning
  if (typeof createBackup !== 'undefined') {
    // Make backup functions globally available
    window.createBackup = createBackup;
    window.restoreFromBackup = restoreFromBackup;
    window.deleteBackup = deleteBackup;
    window.exportBackup = exportBackup;
    window.importBackupFromFile = importBackupFromFile;
    window.cleanupOldBackups = cleanupOldBackups;
  } else {
    console.warn('Backup functions not available - skipping assignment');
  }

  // === ADVANCED GANTT FEATURES ===

  // Global state for Gantt visualization
  window.ganttShowDependencies = false;
  window.ganttShowCriticalPath = false;
  window.ganttCreatingDependency = false;
  window.ganttDependencyFrom = null;

  // Initialize drag & drop functionality for Gantt tasks
  function initGanttDragDrop() {
    const container = qs('#gantt-container');
    if (!container) return;

    let draggedTask = null;
    let dragOffset = { x: 0, y: 0 };
    let dropZone = null;

    // Add drag event listeners to all tasks
    document.querySelectorAll('.gantt-task').forEach(taskEl => {
      taskEl.draggable = true;
      taskEl.addEventListener('dragstart', handleDragStart);
      taskEl.addEventListener('dragend', handleDragEnd);
      taskEl.addEventListener('click', handleTaskClick);
    });

    // Add drop zones to task cells
    document.querySelectorAll('.gantt-task-cell').forEach(cell => {
      cell.addEventListener('dragover', handleDragOver);
      cell.addEventListener('drop', handleDrop);
      cell.addEventListener('dragleave', handleDragLeave);
    });

    function handleDragStart(e) {
      draggedTask = e.target;
      draggedTask.classList.add('dragging');

      // Calculate offset for smooth dragging
      const rect = draggedTask.getBoundingClientRect();
      dragOffset.x = e.clientX - rect.left;
      dragOffset.y = e.clientY - rect.top;

      // Create drop zone indicator
      createDropZone(e.clientX, e.clientY);
    }

    function handleDragEnd(e) {
      if (draggedTask) {
        draggedTask.classList.remove('dragging');
      }

      // Remove drop zone
      if (dropZone) {
        dropZone.remove();
        dropZone = null;
      }

      draggedTask = null;
    }

    function handleDragOver(e) {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';

      if (dropZone) {
        updateDropZone(e.clientX, e.clientY);
      }
    }

    function handleDrop(e) {
      e.preventDefault();

      if (!draggedTask || !dropZone) return;

      const taskId = draggedTask.dataset.taskId;
      const newDate = calculateDropDate(e.clientX);

      if (newDate && taskId) {
        updateTaskDate(taskId, newDate);
        renderGantt();
      }
    }

    function handleTaskClick(e) {
      // Prevent click when dragging
      if (draggedTask) return;

      const taskId = e.currentTarget.getAttribute('data-task-id');
      if (taskId) {
        handleTaskClickForDependency(taskId);
      }
    }

    function handleDragLeave(e) {
      // Optional: handle drag leave effects
      // This function is required by the event listener but may be empty
    }

    function createDropZone(x, y) {
      dropZone = document.createElement('div');
      dropZone.className = 'gantt-drop-zone';
      dropZone.style.width = draggedTask.offsetWidth + 'px';
      dropZone.style.height = draggedTask.offsetHeight + 'px';
      document.body.appendChild(dropZone);
      updateDropZone(x, y);
    }

    function updateDropZone(x, y) {
      if (!dropZone) return;

      const rect = container.getBoundingClientRect();
      const relativeX = x - rect.left - dragOffset.x;
      const relativeY = y - rect.top - dragOffset.y;

      dropZone.style.left = (rect.left + relativeX) + 'px';
      dropZone.style.top = (rect.top + relativeY) + 'px';

      // Validate drop position
      const isValid = isValidDropPosition(relativeX, relativeY);
      dropZone.className = 'gantt-drop-zone ' + (isValid ? 'valid' : 'invalid');
    }

    function calculateDropDate(clientX) {
      const timeline = qs('#gantt-timeline');
      const container = qs('#gantt-container');
      const rect = container.getBoundingClientRect();
      const timelineRect = timeline.getBoundingClientRect();

      // Calculate relative position in timeline
      const relativeX = clientX - timelineRect.left;
      const timelineWidth = timelineRect.width;

      if (relativeX < 0 || relativeX > timelineWidth) return null;

      // Get timeline start date
      const viewMode = qs('#gantt-view').value || 'week';
      const daysCount = viewMode === 'week' ? 7 : 30;
      const slotWidth = timelineWidth / daysCount;

      // Calculate which day was clicked
      const dayIndex = Math.floor(relativeX / slotWidth);
      const startDate = getGanttStartDate();

      const newDate = new Date(startDate);
      newDate.setDate(startDate.getDate() + dayIndex);

      return newDate.getTime();
    }

    function isValidDropPosition(x, y) {
      // Basic validation - ensure within container bounds
      const container = qs('#gantt-container');
      const rect = container.getBoundingClientRect();
      return x >= 200 && x <= rect.width - 100 && y >= 0 && y <= rect.height;
    }

    function updateTaskDate(taskId, newTimestamp) {
      const task = (state.tasks || []).find(t => t.id === taskId);
      if (!task) return;

      // Update task start date
      task.startPlanned = newTimestamp;

      // Recalculate end date based on duration
      const durationMs = (task.estMin || 60) * 60 * 1000; // Convert minutes to milliseconds
      task.endPlanned = newTimestamp + durationMs;

      save();
      console.log('Task date updated:', taskId, new Date(newTimestamp).toLocaleDateString('pl-PL'));
    }

    function getGanttStartDate() {
      let minDate = new Date();
      (state.tasks || []).forEach(t => {
        if (t.startPlanned && t.startPlanned < minDate.getTime()) {
          minDate = new Date(t.startPlanned);
        }
      });

      const startDate = new Date(minDate);
      startDate.setDate(startDate.getDate() - startDate.getDay());
      startDate.setHours(0, 0, 0, 0);
      return startDate;
    }
  }

  // Update Gantt button states
  function updateGanttButtons() {
    const depBtn = qs('#gantt-show-dependencies');
    const createDepBtn = qs('#gantt-create-dependency');
    const critBtn = qs('#gantt-show-critical-path');

    if (depBtn) {
      depBtn.classList.toggle('primary', window.ganttShowDependencies);
    }
    if (createDepBtn) {
      createDepBtn.classList.toggle('primary', window.ganttCreatingDependency);
    }
    if (critBtn) {
      critBtn.classList.toggle('primary', window.ganttShowCriticalPath);
    }
  }

  // Toggle dependencies visualization
  function toggleDependencies() {
    window.ganttShowDependencies = !window.ganttShowDependencies;
    updateGanttButtons();

    if (window.ganttShowDependencies) {
      renderDependencies();
    } else {
      clearDependencies();
    }
  }

  // Toggle critical path visualization
  function toggleCriticalPath() {
    window.ganttShowCriticalPath = !window.ganttShowCriticalPath;
    updateGanttButtons();

    if (window.ganttShowCriticalPath) {
      calculateAndShowCriticalPath();
    } else {
      clearCriticalPath();
    }
  }

  // Toggle dependency creation mode
  function toggleDependencyCreation() {
    window.ganttCreatingDependency = !window.ganttCreatingDependency;
    window.ganttDependencyFrom = null;
    updateGanttButtons();

    if (window.ganttCreatingDependency) {
      alert('Tryb tworzenia zależności włączony. Kliknij na pierwsze zadanie, a następnie na zadanie docelowe.');
    } else {
      alert('Tryb tworzenia zależności wyłączony.');
    }
  }

  // Handle task click for dependency creation
  function handleTaskClickForDependency(taskId) {
    if (!window.ganttCreatingDependency) return;

    if (!window.ganttDependencyFrom) {
      // First task selected
      window.ganttDependencyFrom = taskId;
      const taskEl = document.querySelector(`[data-task-id="${taskId}"]`);
      if (taskEl) {
        taskEl.classList.add('dependency-from');
      }
      alert('Wybrano pierwsze zadanie. Teraz kliknij na zadanie docelowe.');
    } else if (window.ganttDependencyFrom === taskId) {
      // Same task clicked - cancel
      const taskEl = document.querySelector(`[data-task-id="${taskId}"]`);
      if (taskEl) {
        taskEl.classList.remove('dependency-from');
      }
      window.ganttDependencyFrom = null;
      alert('Anulowano wybór. Kliknij ponownie na pierwsze zadanie.');
    } else {
      // Second task selected - create dependency
      createManualDependency(window.ganttDependencyFrom, taskId);

      // Reset state
      const fromEl = document.querySelector(`[data-task-id="${window.ganttDependencyFrom}"]`);
      if (fromEl) {
        fromEl.classList.remove('dependency-from');
      }
      window.ganttDependencyFrom = null;
      window.ganttCreatingDependency = false;
      updateGanttButtons();
    }
  }

  // Create manual dependency between two tasks
  function createManualDependency(fromTaskId, toTaskId) {
    if (!state.taskDependencies) {
      state.taskDependencies = [];
    }

    // Check if dependency already exists
    const existing = state.taskDependencies.find(dep =>
      dep.from === fromTaskId && dep.to === toTaskId
    );

    if (existing) {
      alert('Ta zależność już istnieje!');
      return;
    }

    // Add new dependency
    state.taskDependencies.push({
      id: uid(),
      from: fromTaskId,
      to: toTaskId,
      type: 'finish-to-start',
      manual: true
    });

    save();
    renderGantt();
    if (window.ganttShowDependencies) {
      renderDependencies();
    }
    alert('Zależność została utworzona!');
  }

  // Delete manual dependency
  function deleteManualDependency(dependencyId) {
    if (!state.taskDependencies) return;

    const index = state.taskDependencies.findIndex(dep => dep.id === dependencyId);
    if (index !== -1) {
      state.taskDependencies.splice(index, 1);
      save();
      renderGantt();
      if (window.ganttShowDependencies) {
        renderDependencies();
      }
    }
  }

  // Show dependency management dialog
  function showDependencyManager() {
    const dependencies = state.taskDependencies || [];
    const tasks = state.tasks || [];

    let html = '<div style="max-height: 400px; overflow-y: auto;">';
    html += '<h4>Ręczne zależności między zadaniami</h4>';

    if (dependencies.length === 0) {
      html += '<p>Brak ręcznych zależności. Użyj przycisku "Utwórz zależność" aby dodać pierwszą.</p>';
    } else {
      html += '<div style="display: grid; gap: 8px;">';
      dependencies.forEach(dep => {
        const fromTask = tasks.find(t => t.id === dep.from);
        const toTask = tasks.find(t => t.id === dep.to);

        const fromName = fromTask ? (fromTask.opName || fromTask.name || 'Zadanie') : 'Nieznane';
        const toName = toTask ? (toTask.opName || toTask.name || 'Zadanie') : 'Nieznane';

        html += `
          <div style="display: flex; align-items: center; justify-content: space-between; padding: 8px; border: 1px solid var(--b); border-radius: 4px;">
            <div>
              <strong>${fromName}</strong> → <strong>${toName}</strong>
              <div style="font-size: 12px; color: var(--text-secondary);">${dep.type}</div>
            </div>
            <button class="btn red tiny" onclick="deleteManualDependency('${dep.id}')" title="Usuń zależność">🗑️</button>
          </div>
        `;
      });
      html += '</div>';
    }

    html += '</div>';

    // Show modal dialog
    showModal('Zarządzanie zależnościami', html, [
      { text: 'Zamknij', action: () => {} }
    ]);
  }

  // Render task dependencies
  function renderDependencies() {
    const svg = qs('#gantt-dependencies');
    if (!svg) {
      console.log('SVG gantt-dependencies not found');
      return;
    }

    // Clear existing dependencies
    svg.innerHTML = '';

    const tasks = state.tasks || [];
    const dependencies = calculateTaskDependencies(tasks);
    
    console.log('Dependencies found:', dependencies.length);
    console.log('Tasks with startPlanned:', tasks.filter(t => t.startPlanned).length);

    dependencies.forEach(dep => {
      const fromTask = tasks.find(t => t.id === dep.from);
      const toTask = tasks.find(t => t.id === dep.to);

      if (fromTask && toTask && fromTask.startPlanned && toTask.startPlanned) {
        console.log('Drawing dependency from', fromTask.id, 'to', toTask.id);
        drawDependencyLine(svg, fromTask, toTask, dep.type, dep.manual);
      } else {
        console.log('Skipping dependency - missing tasks or startPlanned:', {
          fromTask: !!fromTask,
          toTask: !!toTask,
          fromStartPlanned: fromTask?.startPlanned,
          toStartPlanned: toTask?.startPlanned
        });
      }
    });
  }

  // Calculate task dependencies based on process order and manual dependencies
  function calculateTaskDependencies(tasks) {
    const dependencies = [];

    // Add automatic dependencies based on process order
    const tasksByOrder = {};
    tasks.forEach(task => {
      if (!tasksByOrder[task.orderId]) {
        tasksByOrder[task.orderId] = [];
      }
      tasksByOrder[task.orderId].push(task);
    });

    // For each order, create dependencies based on process operations
    Object.values(tasksByOrder).forEach(orderTasks => {
      // Sort tasks by their position in the process
      orderTasks.sort((a, b) => {
        const orderA = a.opIndex || 0;
        const orderB = b.opIndex || 0;
        return orderA - orderB;
      });

      // Create finish-to-start dependencies
      for (let i = 0; i < orderTasks.length - 1; i++) {
        dependencies.push({
          from: orderTasks[i].id,
          to: orderTasks[i + 1].id,
          type: 'finish-to-start',
          manual: false
        });
      }
    });

    // Add manual dependencies
    if (state.taskDependencies) {
      state.taskDependencies.forEach(dep => {
        dependencies.push({
          from: dep.from,
          to: dep.to,
          type: dep.type || 'finish-to-start',
          manual: true,
          id: dep.id
        });
      });
    }

    return dependencies;
  }

  // Draw dependency line between two tasks
  function drawDependencyLine(svg, fromTask, toTask, type, isManual = false) {
    console.log('drawDependencyLine called for:', fromTask.id, '->', toTask.id);
    
    const ganttContainer = qs('#gantt-container');
    const ganttBody = qs('#gantt-body');
    if (!ganttContainer || !ganttBody) {
      console.log('Gantt containers not found');
      return;
    }

    // Get task elements
    const fromEl = document.querySelector(`[data-task-id="${fromTask.id}"]`);
    const toEl = document.querySelector(`[data-task-id="${toTask.id}"]`);

    if (!fromEl || !toEl) {
      console.log('Task elements not found:', {
        fromEl: !!fromEl,
        toEl: !!toEl,
        fromTaskId: fromTask.id,
        toTaskId: toTask.id
      });
      return;
    }

    // Get the parent task cells (which contain positioning)
    const fromCell = fromEl.closest('.gantt-task-cell');
    const toCell = toEl.closest('.gantt-task-cell');
    
    if (!fromCell || !toCell) {
      console.log('Task cells not found:', {
        fromCell: !!fromCell,
        toCell: !!toCell
      });
      return;
    }

    // Calculate positions using offsetLeft/offsetTop relative to gantt body
    const fromX = fromCell.offsetLeft + fromEl.offsetLeft + fromEl.offsetWidth;
    const fromY = fromCell.offsetTop + fromEl.offsetTop + (fromEl.offsetHeight / 2);
    const toX = toCell.offsetLeft + toEl.offsetLeft;
    const toY = toCell.offsetTop + toEl.offsetTop + (toEl.offsetHeight / 2);

    console.log('Calculated positions:', {
      fromX, fromY, toX, toY
    });

    // Set SVG size to match gantt body
    svg.setAttribute('width', ganttBody.scrollWidth);
    svg.setAttribute('height', ganttBody.scrollHeight);
    svg.style.width = ganttBody.scrollWidth + 'px';
    svg.style.height = ganttBody.scrollHeight + 'px';

    // Create SVG path
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.className = `gantt-dependency-line ${isManual ? 'manual' : ''}`;
    path.setAttribute('stroke', isManual ? '#3b82f6' : '#94a3b8');
    path.setAttribute('stroke-width', isManual ? '3' : '2');
    path.setAttribute('fill', 'none');
    path.setAttribute('stroke-linecap', 'round');

    // Calculate path - use simple elbow connection
    const deltaX = toX - fromX;
    const deltaY = toY - fromY;
    
    let d;
    if (Math.abs(deltaY) < 5) {
      // Same row - direct horizontal line
      d = `M ${fromX} ${fromY} L ${toX} ${toY}`;
    } else if (deltaX > 20) {
      // Forward dependency - elbow connection
      const midX = fromX + Math.max(20, deltaX / 2);
      d = `M ${fromX} ${fromY} L ${midX} ${fromY} L ${midX} ${toY} L ${toX} ${toY}`;
    } else {
      // Backward dependency - curved connection
      const controlX1 = fromX + 40;
      const controlY1 = fromY;
      const controlX2 = toX - 40;
      const controlY2 = toY;
      d = `M ${fromX} ${fromY} C ${controlX1} ${controlY1}, ${controlX2} ${controlY2}, ${toX} ${toY}`;
    }
    
    console.log('SVG path:', d);
    path.setAttribute('d', d);
    svg.appendChild(path);

    // Add arrow
    const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
    arrow.className = `gantt-dependency-arrow ${isManual ? 'manual' : ''}`;
    
    // Arrow pointing to the target task
    const arrowSize = 8;
    let arrowPoints;
    
    if (Math.abs(deltaY) < 5) {
      // Horizontal arrow
      arrowPoints = `${toX-arrowSize},${toY-arrowSize/2} ${toX},${toY} ${toX-arrowSize},${toY+arrowSize/2}`;
    } else {
      // Vertical component exists
      if (deltaX > 20) {
        // Forward dependency - horizontal arrow
        arrowPoints = `${toX-arrowSize},${toY-arrowSize/2} ${toX},${toY} ${toX-arrowSize},${toY+arrowSize/2}`;
      } else {
        // Backward dependency - curved arrow
        const angle = Math.atan2(deltaY, -40); // Direction from control point
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const p1x = toX - arrowSize * cos - (arrowSize/2) * sin;
        const p1y = toY - arrowSize * sin + (arrowSize/2) * cos;
        const p2x = toX - arrowSize * cos + (arrowSize/2) * sin;
        const p2y = toY - arrowSize * sin - (arrowSize/2) * cos;
        arrowPoints = `${p1x},${p1y} ${toX},${toY} ${p2x},${p2y}`;
      }
    }
    
    console.log('Arrow points:', arrowPoints);
    arrow.setAttribute('points', arrowPoints);
    arrow.setAttribute('fill', isManual ? '#3b82f6' : '#94a3b8');
    svg.appendChild(arrow);
    
    console.log('Dependency line added to SVG');
  }

  // Clear dependencies visualization
  function clearDependencies() {
    const svg = qs('#gantt-dependencies');
    if (svg) {
      svg.innerHTML = '';
    }
  }

  // Calculate and show critical path
  function calculateAndShowCriticalPath() {
    const tasks = state.tasks || [];
    const criticalTasks = calculateCriticalPath(tasks);

    // Highlight critical tasks
    criticalTasks.forEach(taskId => {
      const taskEl = document.querySelector(`[data-task-id="${taskId}"]`);
      if (taskEl) {
        taskEl.classList.add('critical-path');
      }
    });

    // Show float indicators for non-critical tasks
    tasks.forEach(task => {
      if (!criticalTasks.includes(task.id)) {
        const float = calculateTaskFloat(task, tasks);
        showFloatIndicator(task, float);
      }
    });
  }

  // Calculate critical path using CPM (Critical Path Method)
  function calculateCriticalPath(tasks) {
    if (!tasks || tasks.length === 0) return [];

    // Create task map for easy lookup
    const taskMap = {};
    tasks.forEach(task => {
      taskMap[task.id] = {
        ...task,
        predecessors: [],
        successors: [],
        earlyStart: 0,
        earlyFinish: 0,
        lateStart: Infinity,
        lateFinish: Infinity
      };
    });

    // Build dependency graph
    const dependencies = calculateTaskDependencies(tasks);
    dependencies.forEach(dep => {
      if (taskMap[dep.from] && taskMap[dep.to]) {
        taskMap[dep.from].successors.push(dep.to);
        taskMap[dep.to].predecessors.push(dep.from);
      }
    });

    // Forward pass - calculate early start/finish
    const visited = new Set();
    function forwardPass(taskId) {
      if (visited.has(taskId)) return;
      visited.add(taskId);

      const task = taskMap[taskId];
      const duration = task.estMin || 60; // minutes

      // Process predecessors first
      task.predecessors.forEach(predId => {
        forwardPass(predId);
        const pred = taskMap[predId];
        task.earlyStart = Math.max(task.earlyStart, pred.earlyFinish);
      });

      task.earlyFinish = task.earlyStart + duration;
    }

    // Start from tasks with no predecessors
    Object.values(taskMap).forEach(task => {
      if (task.predecessors.length === 0) {
        forwardPass(task.id);
      }
    });

    // Backward pass - calculate late start/finish
    const reverseVisited = new Set();
    function backwardPass(taskId) {
      if (reverseVisited.has(taskId)) return;
      reverseVisited.add(taskId);

      const task = taskMap[taskId];

      // If no successors, late finish equals early finish
      if (task.successors.length === 0) {
        task.lateFinish = task.earlyFinish;
      } else {
        // Process successors first
        task.successors.forEach(succId => {
          backwardPass(succId);
          const succ = taskMap[succId];
          task.lateFinish = Math.min(task.lateFinish, succ.lateStart);
        });
      }

      task.lateStart = task.lateFinish - (task.estMin || 60);
    }

    // Start from tasks with no successors
    Object.values(taskMap).forEach(task => {
      if (task.successors.length === 0) {
        backwardPass(task.id);
      }
    });

    // Find critical path (tasks with zero float)
    const criticalPath = [];
    Object.values(taskMap).forEach(task => {
      const float = task.lateFinish - task.earlyFinish;
      if (Math.abs(float) < 1) { // Consider float < 1 minute as critical
        criticalPath.push(task.id);
      }
    });

    console.log('Critical path calculated:', criticalPath.length, 'tasks');
    return criticalPath;
  }

  // Calculate float for a task
  function calculateTaskFloat(task, allTasks) {
    // Simplified float calculation
    const duration = task.estMin || 60;
    const successors = findTaskSuccessors(task, allTasks);

    if (successors.length === 0) {
      return 0; // End task has no float
    }

    // Calculate minimum slack to successors
    let minSlack = Infinity;
    successors.forEach(succ => {
      const succStart = succ.startPlanned || Date.now();
      const taskEnd = (task.startPlanned || Date.now()) + (duration * 60 * 1000);
      const slack = succStart - taskEnd;
      minSlack = Math.min(minSlack, slack);
    });

    return minSlack > 0 ? Math.round(minSlack / (60 * 1000)) : 0; // Convert to minutes
  }

  // Find successor tasks
  function findTaskSuccessors(task, allTasks) {
    const successors = [];
    const dependencies = calculateTaskDependencies(allTasks);

    dependencies.forEach(dep => {
      if (dep.from === task.id) {
        const succTask = allTasks.find(t => t.id === dep.to);
        if (succTask) {
          successors.push(succTask);
        }
      }
    });

    return successors;
  }

  // Show float indicator for task
  function showFloatIndicator(task, floatMinutes) {
    const taskEl = document.querySelector(`[data-task-id="${task.id}"]`);
    if (!taskEl) return;

    // Remove existing indicator
    const existing = taskEl.querySelector('.gantt-float-indicator');
    if (existing) existing.remove();

    const indicator = document.createElement('div');
    indicator.className = 'gantt-float-indicator';

    if (floatMinutes > 60) {
      indicator.classList.add('positive');
      indicator.textContent = `+${Math.round(floatMinutes / 60)}h`;
    } else if (floatMinutes > 0) {
      indicator.classList.add('positive');
      indicator.textContent = `+${floatMinutes}m`;
    } else if (floatMinutes === 0) {
      indicator.classList.add('zero');
      indicator.textContent = '0';
    } else {
      indicator.classList.add('negative');
      indicator.textContent = `${floatMinutes}m`;
    }

    taskEl.appendChild(indicator);
  }

  // Clear critical path visualization
  function clearCriticalPath() {
    // Remove critical path highlighting
    document.querySelectorAll('.gantt-task.critical-path').forEach(el => {
      el.classList.remove('critical-path');
    });

    // Remove float indicators
    document.querySelectorAll('.gantt-float-indicator').forEach(el => {
      el.remove();
    });
  }

  // Make advanced Gantt functions globally available
  window.toggleDependencies = toggleDependencies;
  window.toggleCriticalPath = toggleCriticalPath;
  window.renderDependencies = renderDependencies;
  window.calculateAndShowCriticalPath = calculateAndShowCriticalPath;
  window.deleteManualDependency = deleteManualDependency;

  // Add scroll listener to update dependencies when gantt is scrolled
  function initGanttScrollListener() {
    const ganttBody = qs('#gantt-body');
    if (ganttBody) {
      ganttBody.addEventListener('scroll', () => {
        if (window.ganttShowDependencies) {
          // Debounce the rendering to avoid too many updates
          if (window.ganttScrollTimeout) {
            clearTimeout(window.ganttScrollTimeout);
          }
          window.ganttScrollTimeout = setTimeout(() => {
            renderDependencies();
          }, 100);
        }
      });
    }
  }

  // Initialize scroll listener when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initGanttScrollListener);
  } else {
    initGanttScrollListener();
  }

  // Simple modal dialog function
  function showModal(title, content, buttons = []) {

    // Create modal elements
    const modal = document.createElement('div');
    modal.id = 'custom-modal';
    modal.style.cssText = `
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.5); z-index: 10000; display: flex;
      align-items: center; justify-content: center;
    `;

    const modalContent = document.createElement('div');
    modalContent.style.cssText = `
      background: var(--panel); border-radius: 8px; padding: 20px;
      max-width: 600px; max-height: 80vh; overflow-y: auto;
      box-shadow: 0 10px 25px rgba(0,0,0,0.3);
    `;

    const titleEl = document.createElement('h3');
    titleEl.textContent = title;
    titleEl.style.marginTop = '0';

    const contentEl = document.createElement('div');
    contentEl.innerHTML = content;

    const buttonsEl = document.createElement('div');
    buttonsEl.style.cssText = 'display: flex; gap: 8px; justify-content: flex-end; margin-top: 20px;';

    buttons.forEach(btn => {
      const buttonEl = document.createElement('button');
      buttonEl.className = 'btn';
      buttonEl.textContent = btn.text;
      buttonEl.addEventListener('click', () => {
        if (btn.action) btn.action();
        modal.remove();
      });
      buttonsEl.appendChild(buttonEl);
    });

    modalContent.appendChild(titleEl);
    modalContent.appendChild(contentEl);
    modalContent.appendChild(buttonsEl);
    modal.appendChild(modalContent);

    // Close on background click
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        modal.remove();
      }
    });

    document.body.appendChild(modal);
  }

  // Enable/disable browser spellcheck and set language (pl) for user-editable fields
  (function(){
  try{
    const queryFields = () => Array.from(document.querySelectorAll('input:not([type="hidden"]), textarea, [contenteditable]'));

    const enableSpellAndLang = () => {
      queryFields().forEach(el=>{
        try{ el.setAttribute('spellcheck','true'); }catch(_){/* ignore */}
        try{ el.setAttribute('lang','pl'); }catch(_){/* ignore */}
      });
    };

    const disableSpellAndLang = () => {
      Array.from(document.querySelectorAll('input, textarea, [contenteditable]')).forEach(el=>{
        try{ el.removeAttribute('spellcheck'); }catch(_){/* ignore */}
        try{ if(el.getAttribute('lang') === 'pl') el.removeAttribute('lang'); }catch(_){/* ignore */}
      });
    };

    const obsCb = (mutationsList) => {
      try{
        if(!!state.storage.spellcheckEnforce) enableSpellAndLang(); else disableSpellAndLang();
      }catch(_){/* ignore */}
    };

    const obs = new MutationObserver(obsCb);
    obs.observe(document.body, { childList:true, subtree:true });

    if(!!state.storage.spellcheckEnforce) enableSpellAndLang(); else disableSpellAndLang();
  }catch(e){console.warn('spellcheck/lang init error', e);} 
})();

// === MAGAZYN ===
console.log('🔥 WAREHOUSE SECTION STARTED 🔥');
alert('WAREHOUSE CODE EXECUTING!');

// Prosty magazyn - funkcyjne podejście
window.simpleWarehouse = {
  items: [
    {
      id: 'wh_001',
      name: 'Płyta MDF 18mm',
      category: 'materialy',
      quantity: 25,
      unit: 'szt',
      minQuantity: 10,
      price: 89.50,
      supplier: 'Producent A',
      location: 'Regał A1',
      description: 'Płyta MDF do produkcji drzwi'
    },
    {
      id: 'wh_002', 
      name: 'Zawiasy 3D',
      category: 'okucia',
      quantity: 150,
      unit: 'szt',
      minQuantity: 50,
      price: 12.30,
      supplier: 'Okucia Sp. z o.o.',
      location: 'Regał B2',
      description: 'Zawiasy regulowane 3D do drzwi'
    },
    {
      id: 'wh_003',
      name: 'Lakier bezbarwny',
      category: 'farby',
      quantity: 8,
      unit: 'l',
      minQuantity: 15,
      price: 45.80,
      supplier: 'Farby Premium',
      location: 'Magazyn farb',
      description: 'Lakier poliuretanowy bezbarwny'
    }
  ],

  render: function() {
    console.log('Simple warehouse render called');
    const listEl = document.getElementById('wh-list');
    if (!listEl) {
      console.error('wh-list element not found');
      return;
    }

    const filteredItems = this.getFilteredItems();
    console.log('Filtered items:', filteredItems.length);

    if (filteredItems.length === 0) {
      listEl.innerHTML = '<div style="text-align:center;padding:40px;color:#999">Brak pozycji spełniających kryteria.</div>';
      this.updateStats();
      return;
    }

    listEl.innerHTML = filteredItems.map(item => this.renderItem(item)).join('');
    this.updateStats();
    console.log('Simple warehouse rendered successfully');
  },

  getFilteredItems: function() {
    const search = document.getElementById('wh-search')?.value.toLowerCase() || '';
    const category = document.getElementById('wh-category-filter')?.value || '';
    const status = document.getElementById('wh-status-filter')?.value || '';

    return this.items.filter(item => {
      const matchesSearch = item.name.toLowerCase().includes(search) || 
                           item.description.toLowerCase().includes(search);
      const matchesCategory = !category || item.category === category;
      
      let matchesStatus = true;
      if (status === 'dostepny') matchesStatus = item.quantity > item.minQuantity;
      else if (status === 'niski') matchesStatus = item.quantity <= item.minQuantity && item.quantity > 0;
      else if (status === 'brak') matchesStatus = item.quantity === 0;

      return matchesSearch && matchesCategory && matchesStatus;
    });
  },

  renderItem: function(item) {
    const statusClass = item.quantity === 0 ? 'red' : 
                       item.quantity <= item.minQuantity ? 'orange' : 'green';
    
    const statusText = item.quantity === 0 ? 'BRAK' :
                      item.quantity <= item.minQuantity ? 'NISKI STAN' : 'DOSTĘPNY';

    return `
      <div class="card" style="margin-bottom:8px;border-left:4px solid ${statusClass === 'red' ? '#dc3545' : statusClass === 'orange' ? '#ffc107' : '#28a745'}">
        <div class="row" style="justify-content:space-between;align-items:center">
          <div style="flex:1">
            <div style="font-weight:bold;font-size:16px">${item.name}</div>
            <div style="color:#666;font-size:14px;margin:4px 0">${item.description}</div>
            <div class="row" style="gap:16px;font-size:12px;color:#888">
              <span>📦 ${item.location}</span>
              <span>🏢 ${item.supplier}</span>
              <span>🏷️ ${this.getCategoryName(item.category)}</span>
            </div>
          </div>
          <div style="text-align:center;min-width:120px">
            <div style="font-size:20px;font-weight:bold;color:${statusClass === 'red' ? '#dc3545' : statusClass === 'orange' ? '#ffc107' : '#28a745'}">
              ${item.quantity} ${item.unit}
            </div>
            <div style="font-size:10px;color:#666">min: ${item.minQuantity} ${item.unit}</div>
            <div style="font-size:12px;color:${statusClass === 'red' ? '#dc3545' : statusClass === 'orange' ? '#ffc107' : '#28a745'};font-weight:bold">
              ${statusText}
            </div>
          </div>
          <div style="text-align:right;min-width:100px">
            <div style="font-size:16px;font-weight:bold">${item.price.toFixed(2)} zł</div>
            <div style="font-size:12px;color:#666">za ${item.unit}</div>
            <div style="font-size:14px;color:#888">${(item.quantity * item.price).toFixed(2)} zł</div>
          </div>
          <div class="row" style="gap:4px;margin-left:16px">
            <button class="btn small" onclick="editWarehouseItem('${item.id}')">✏️</button>
            <button class="btn small blue" onclick="adjustWarehouseQuantity('${item.id}')">📊</button>
            <button class="btn small red" onclick="deleteWarehouseItem('${item.id}')">🗑️</button>
          </div>
        </div>
      </div>
    `;
  },

  getCategoryName: function(category) {
    const categories = {
      'materialy': 'Materiały',
      'okucia': 'Okucia', 
      'farby': 'Farby i lakiery',
      'narzedzia': 'Narzędzia',
      'inne': 'Inne'
    };
    return categories[category] || category;
  },

  updateStats: function() {
    const total = this.items.length;
    const low = this.items.filter(item => item.quantity <= item.minQuantity && item.quantity > 0).length;
    const empty = this.items.filter(item => item.quantity === 0).length;
    const value = this.items.reduce((sum, item) => sum + (item.quantity * item.price), 0);

    document.getElementById('wh-stat-total').textContent = total;
    document.getElementById('wh-stat-low').textContent = low;
    document.getElementById('wh-stat-empty').textContent = empty;
    document.getElementById('wh-stat-value').textContent = `${value.toFixed(2)} zł`;
  },

  showAddItemModal: function() {
    const modal = document.createElement('div');
    modal.style.cssText = `
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.5); z-index: 10000; display: flex;
      align-items: center; justify-content: center;
    `;
    
    modal.innerHTML = `
      <div style="background: white; padding: 20px; border-radius: 10px; max-width: 500px; width: 90%;">
        <h3>Dodaj nową pozycję magazynową</h3>
        <form id="add-item-form">
          <div style="margin-bottom: 10px;">
            <label>Nazwa: <input type="text" name="name" required style="width: 100%; padding: 5px;"></label>
          </div>
          <div style="margin-bottom: 10px;">
            <label>Kategoria: 
              <select name="category" style="width: 100%; padding: 5px;">
                <option value="materialy">Materiały</option>
                <option value="okucia">Okucia</option>
                <option value="farby">Farby i lakiery</option>
                <option value="narzedzia">Narzędzia</option>
                <option value="inne">Inne</option>
              </select>
            </label>
          </div>
          <div style="margin-bottom: 10px;">
            <label>Ilość: <input type="number" name="quantity" min="0" step="0.01" required style="width: 100%; padding: 5px;"></label>
          </div>
          <div style="margin-bottom: 10px;">
            <label>Jednostka: <input type="text" name="unit" value="szt" required style="width: 100%; padding: 5px;"></label>
          </div>
          <div style="margin-bottom: 10px;">
            <label>Stan minimalny: <input type="number" name="minQuantity" min="0" step="0.01" required style="width: 100%; padding: 5px;"></label>
          </div>
          <div style="margin-bottom: 10px;">
            <label>Cena: <input type="number" name="price" min="0" step="0.01" required style="width: 100%; padding: 5px;"></label>
          </div>
          <div style="margin-bottom: 10px;">
            <label>Dostawca: <input type="text" name="supplier" style="width: 100%; padding: 5px;"></label>
          </div>
          <div style="margin-bottom: 10px;">
            <label>Lokalizacja: <input type="text" name="location" style="width: 100%; padding: 5px;"></label>
          </div>
          <div style="margin-bottom: 10px;">
            <label>Opis: <textarea name="description" style="width: 100%; padding: 5px; height: 60px;"></textarea>
          </div>
          <div style="text-align: right;">
            <button type="button" onclick="this.closest('div').parentElement.remove()">Anuluj</button>
            <button type="submit">Dodaj</button>
          </div>
        </form>
      </div>
    `;
    
    document.body.appendChild(modal);
    
    const form = modal.querySelector('#add-item-form');
    form.addEventListener('submit', (e) => {
      e.preventDefault();
      const formData = new FormData(form);
      const newItem = {
        id: 'wh_' + Date.now(),
        name: formData.get('name'),
        category: formData.get('category'),
        quantity: parseFloat(formData.get('quantity')),
        unit: formData.get('unit'),
        minQuantity: parseFloat(formData.get('minQuantity')),
        price: parseFloat(formData.get('price')),
        supplier: formData.get('supplier') || '',
        location: formData.get('location') || '',
        description: formData.get('description') || ''
      };
      
      this.items.push(newItem);
      this.render();
      modal.remove();
    });
  },

  editItem: function(id) {
    alert('Funkcja edycji pozycji: ' + id);
  },

  adjustQuantity: function(id) {
    alert('Funkcja korekty stanu: ' + id);
  },

  deleteItem: function(id) {
    if (confirm('Czy na pewno chcesz usunąć tę pozycję?')) {
      this.items = this.items.filter(item => item.id !== id);
      this.render();
    }
  },

  exportData: function() {
    alert('Funkcja eksportu - w wersji uproszczonej');
  }
};

console.log('Simple warehouse created:', window.simpleWarehouse);

// Funkcja do konfiguracji przycisków magazynu
function setupWarehouseButtons() {
  console.log('=== WAREHOUSE BUTTONS SETUP ===');
  console.log('simpleWarehouse available:', !!window.simpleWarehouse);
  
  const addBtn = document.getElementById('btn-add-warehouse');
  const refreshBtn = document.getElementById('btn-refresh-warehouse');
  const exportBtn = document.getElementById('btn-export-warehouse');
  
  console.log('Found buttons:', {
    addBtn: !!addBtn,
    refreshBtn: !!refreshBtn,
    exportBtn: !!exportBtn
  });
  
  if (addBtn) {
    console.log('Setting up add button');
    // Usuń poprzednie listenery
    addBtn.onclick = null;
    addBtn.addEventListener('click', (e) => {
      console.log('🔥 ADD BUTTON CLICKED!');
      // Nie blokujemy propagacji jeśli delegacja jest włączona
      if (window.disableGlobalClickDelegation) {
        e.preventDefault();
        e.stopPropagation();
      }
      if (window.simpleWarehouse) {
        console.log('Calling showAddItemModal');
        window.simpleWarehouse.showAddItemModal();
      } else {
        console.error('simpleWarehouse not available');
        alert('System magazynowy nie jest dostępny');
      }
    });
    console.log('✅ Add button configured');
  } else {
    console.error('❌ Add button not found!');
  }
  
  if (refreshBtn) {
    console.log('Setting up refresh button');
    refreshBtn.onclick = null;
    refreshBtn.addEventListener('click', (e) => {
      console.log('🔥 REFRESH BUTTON CLICKED!');
      // Nie blokujemy propagacji jeśli delegacja jest włączona
      if (window.disableGlobalClickDelegation) {
        e.preventDefault();
        e.stopPropagation();
      }
      if (window.simpleWarehouse) {
        console.log('Calling render');
        window.simpleWarehouse.render();
      } else {
        console.error('simpleWarehouse not available');
        alert('System magazynowy nie jest dostępny');
      }
    });
    console.log('✅ Refresh button configured');
  } else {
    console.error('❌ Refresh button not found!');
  }
  
  if (exportBtn) {
    console.log('Setting up export button');
    exportBtn.onclick = null;
    exportBtn.addEventListener('click', (e) => {
      console.log('🔥 EXPORT BUTTON CLICKED!');
      // Nie blokujemy propagacji jeśli delegacja jest włączona
      if (window.disableGlobalClickDelegation) {
        e.preventDefault();
        e.stopPropagation();
      }
      if (window.simpleWarehouse) {
        console.log('Calling exportData');
        window.simpleWarehouse.exportData();
      } else {
        console.error('simpleWarehouse not available');
        alert('System magazynowy nie jest dostępny');
      }
    });
    console.log('✅ Export button configured');
  } else {
    console.error('❌ Export button not found!');
  }

  // Konfiguracja filtrów
  const searchInput = document.getElementById('wh-search');
  const categoryFilter = document.getElementById('wh-category-filter');
  const statusFilter = document.getElementById('wh-status-filter');

  console.log('Setting up filters:', {
    searchInput: !!searchInput,
    categoryFilter: !!categoryFilter,
    statusFilter: !!statusFilter
  });

  if (searchInput) {
    searchInput.addEventListener('input', () => {
      console.log('Search input changed');
      filterWarehouse();
    });
  }

  if (categoryFilter) {
    categoryFilter.addEventListener('change', () => {
      console.log('Category filter changed');
      filterWarehouse();
    });
  }

  if (statusFilter) {
    statusFilter.addEventListener('change', () => {
      console.log('Status filter changed');
      filterWarehouse();
    });
  }

  console.log('✅ Filters configured');
}

// Próbuj skonfigurować przyciski natychmiast
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', setupWarehouseButtons);
} else {
  setupWarehouseButtons();
}

// Backup - skonfiguruj ponownie po 1 sekundzie
setTimeout(setupWarehouseButtons, 1000);

// Automatyczne renderowanie magazynu
setTimeout(() => {
  if (window.simpleWarehouse) {
    console.log('Magazyn: Automatyczne renderowanie listy pozycji');
    window.simpleWarehouse.render();
  }
}, 1500);

// Jednorazowa inicjalizacja przy wejściu na zakładkę magazynu
let __warehouseInitialized = false;
function initWarehouse(){
  if(__warehouseInitialized){
    // Przywracamy normalną delegację kliknięć przy powrocie
    window.restoreNormalClickDelegation();
    // odśwież widok przy powrocie
    if(window.simpleWarehouse){
      try { window.simpleWarehouse.render(); } catch(e){ console.warn('[warehouse] re-render error', e); }
    }
    return;
  }
  console.log('[warehouse] initializing...');
  // Przywracamy normalną delegację kliknięć przy pierwszej inicjalizacji
  window.restoreNormalClickDelegation();
  // upewnij się że sekcja jest widoczna (usuwamy ewentualnie hidden dopiero po listenerach)
  const section = document.getElementById('p-wh');
  if(section) section.classList.remove('hidden');
  // konfiguracja przycisków
  try { setupWarehouseButtons(); } catch(e){ console.warn('[warehouse] setup buttons error', e); }
  // pierwsze renderowanie
  if(window.simpleWarehouse){
    try { window.simpleWarehouse.render(); } catch(e){ console.warn('[warehouse] first render error', e); }
  } else {
    console.warn('[warehouse] simpleWarehouse not yet ready, retry in 500ms');
    setTimeout(()=>{
      if(window.simpleWarehouse){
        try { window.simpleWarehouse.render(); } catch(e){ console.warn('[warehouse] delayed render error', e); }
      }
    },500);
  }
  __warehouseInitialized = true;
  console.log('[warehouse] initialized');
}

// Globalne funkcje pomocnicze dla przycisków
function showAddItemModal() {
  console.log('showAddItemModal called');
  console.log('window.simpleWarehouse exists:', !!window.simpleWarehouse);
  console.log('window.simpleWarehouse type:', typeof window.simpleWarehouse);
  
  if (window.simpleWarehouse) {
    window.simpleWarehouse.showAddItemModal();
  } else {
    console.error('simpleWarehouse not found');
    // Próba lazy loading
    setTimeout(() => {
      if (window.simpleWarehouse) {
        console.log('simpleWarehouse found after timeout');
        window.simpleWarehouse.showAddItemModal();
      } else {
        console.error('simpleWarehouse still not found after timeout');
      }
    }, 100);
  }
}

function renderWarehouse() {
  console.log('renderWarehouse called');
  console.log('window.simpleWarehouse exists:', !!window.simpleWarehouse);
  
  if (window.simpleWarehouse) {
    window.simpleWarehouse.render();
  } else {
    console.error('simpleWarehouse not found');
    // Próba lazy loading
    setTimeout(() => {
      if (window.simpleWarehouse) {
        console.log('simpleWarehouse found after timeout');
        window.simpleWarehouse.render();
      } else {
        console.error('simpleWarehouse still not found after timeout');
      }
    }, 100);
  }
}

function exportWarehouseData() {
  console.log('exportWarehouseData called');
  
  if (window.simpleWarehouse) {
    window.simpleWarehouse.exportData();
  } else {
    console.error('simpleWarehouse not found');
  }
}

function editWarehouseItem(id) {
  console.log('editWarehouseItem called for:', id);
  
  if (window.simpleWarehouse) {
    window.simpleWarehouse.editItem(id);
  } else {
    console.error('simpleWarehouse not found');
  }
}

function adjustWarehouseQuantity(id) {
  console.log('adjustWarehouseQuantity called for:', id);
  
  if (window.simpleWarehouse) {
    window.simpleWarehouse.adjustQuantity(id);
  } else {
    console.error('simpleWarehouse not found');
  }
}

function deleteWarehouseItem(id) {
  console.log('deleteWarehouseItem called for:', id);
  
  if (window.simpleWarehouse) {
    window.simpleWarehouse.deleteItem(id);
  } else {
    console.error('simpleWarehouse not found');
  }
}

function filterWarehouse() {
  console.log('filterWarehouse called');
  
  if (window.simpleWarehouse) {
    window.simpleWarehouse.render();
  } else {
    console.error('simpleWarehouse not found');
  }
}

function filterWarehouse() {
  console.log('filterWarehouse called');
  
  if (window.simpleWarehouse) {
    window.simpleWarehouse.render();
  } else {
    console.error('simpleWarehouse not found');
  }
}
// Renderowanie magazynu gdy sekcja jest aktywna
document.addEventListener('DOMContentLoaded', () => {
  console.log('DOM Content Loaded - setting up warehouse observers');
  
  // Sprawdź, czy magazyn jest dostępny
  console.log('Checking simpleWarehouse availability...');
  console.log('typeof simpleWarehouse:', typeof window.simpleWarehouse);
  
  // Natychmiastowe renderowanie jeśli sekcja magazynu jest aktywna
  setTimeout(() => {
    const whSection = document.getElementById('p-wh');
    console.log('Checking warehouse section:', whSection, 'hidden:', whSection?.classList.contains('hidden'));
    if (whSection && !whSection.classList.contains('hidden')) {
      console.log('Warehouse section is visible, rendering...');
      if (window.simpleWarehouse) {
        window.simpleWarehouse.render();
      } else {
        console.log('simpleWarehouse not available yet');
      }
    }
  }, 100);

  // Observer dla przyszłych zmian
  const observer = new MutationObserver(() => {
    const whSection = document.getElementById('p-wh');
    if (whSection && !whSection.classList.contains('hidden')) {
      console.log('Warehouse section became visible, rendering...');
      if (window.simpleWarehouse) {
        window.simpleWarehouse.render();
      }
    }
  });
  
  observer.observe(document.body, { childList: true, subtree: true, attributes: true });
});
</script>
</body>
</html>


