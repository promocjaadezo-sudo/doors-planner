<!DOCTYPE html>
<!-- MOJE OZNAKOWANIE: To jest mój własny kod projektu "Planner Produkcji Drzwi" - wersja użytkownika KOMPUTER. Nie kopiuj z zewnętrznych źródeł. -->
<html lang="pl">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0, post-check=0, pre-check=0"/>
<meta http-equiv="Pragma" content="no-cache"/>
<meta http-equiv="Expires" content="0"/>
<meta name="last-modified" content="2025-10-05"/>
<title>Planner Produkcji Drzwi — v5.6.27 (2025-10-05 14:00)</title>
<style>
:root{--bg:#0f172a;--panel:#1f2937;--muted:#94a3b8;--b:#374151;--acc:#2563eb;--ok:#16a34a;--warn:#d97706;--err:#dc2626;--text:#ffffff;--text-secondary:#ffffff}
*{box-sizing:border-box}body{margin:0;font-family:system-ui,Arial,sans-serif;background:var(--bg);color:#ffffff;line-height:1.5}
header{position:sticky;top:0;z-index:60;background:rgba(15,23,42,.95);backdrop-filter:saturate(180%) blur(6px);border-bottom:1px solid #1e293b}
h3{color:#ffffff;font-size:18px;font-weight:700;margin:0 0 12px 0;text-shadow:0 1px 3px rgba(0,0,0,0.7)}
h4{color:#ffffff;font-size:16px;font-weight:700;margin:8px 0;text-shadow:0 1px 2px rgba(0,0,0,0.6)}
.wrap{max-width:1280px;margin:0 auto;padding:16px}
.row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
.card{background:var(--panel);border-radius:14px;padding:14px;box-shadow:0 6px 18px rgba(0,0,0,.35);margin:0 0 12px;border:1px solid rgba(255,255,255,0.1)}
.btn{border:0;border-radius:10px;padding:8px 12px;background:#334155;color:#ffffff;cursor:pointer;border:1px solid rgba(255,255,255,0.1);font-weight:600;text-shadow:0 1px 2px rgba(0,0,0,0.5)}
.btn.gray{background:#475569;color:#ffffff;border:1px solid rgba(255,255,255,0.15)}
.btn.primary{background:var(--acc);color:#fff;border:1px solid rgba(59,130,246,0.5)}.btn.red{background:var(--err);border:1px solid rgba(220,38,38,0.5)}.btn.green{background:var(--ok);border:1px solid rgba(22,163,74,0.5)}.btn.amber{background:var(--warn);border:1px solid rgba(217,119,6,0.5)}.btn.blue{background:#3b82f6;border:1px solid rgba(59,130,246,0.5)}.btn.small{padding:4px 8px;font-size:12px}
.hidden{display:none!important}
input,select,textarea{background:#111827;color:#e5e7eb;border:1px solid var(--b);border-radius:10px;padding:8px 10px;width:100%;transition:border-color 0.2s}
input:focus,select:focus,textarea:focus{border-color:var(--acc);outline:none;box-shadow:0 0 0 2px rgba(37,99,235,0.2)}
label{font-size:12px;color:#ffffff;font-weight:500}.list{display:flex;flex-direction:column;gap:8px}.muted{color:#ffffff;font-size:12px}
#set-info{color:#ffffff !important;font-weight:600 !important;font-size:14px !important;background:#1a2332 !important;padding:4px 8px !important;border-radius:4px !important;border:1px solid #334155 !important;display:block !important;min-height:20px !important;}
.grid2{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:10px}
.grid3{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:10px}
.table{overflow:auto; max-height:55vh} table{width:100%;border-collapse:collapse;border:1px solid rgba(255,255,255,0.1);border-radius:8px;overflow:hidden}
th,td{border-bottom:1px solid #2b3a59;padding:8px;text-align:left;background:#1f2937} th{background:#111827;position:sticky;top:0;border-bottom:2px solid var(--acc);font-weight:700;color:#ffffff;text-shadow:0 1px 2px rgba(0,0,0,0.6)}
.pill{display:inline-block;background:#0b1222;border:1px solid #2b3a59;border-radius:999px;padding:2px 8px;font-size:11px;color:#ffffff;font-weight:500}
.oktxt{color:#ffffff}.err{color:#ffffff}

/* Deadline Alerts Styles */
.deadline-alert { padding: 12px; border-radius: 6px; border-left: 4px solid; margin-bottom: 8px; display: flex; align-items: flex-start; gap: 10px; font-size: 14px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
.deadline-alert.warning { background: rgba(245, 158, 11, 0.15); border-left-color: #f59e0b; color: #92400e; border: 1px solid rgba(245, 158, 11, 0.3); }
.deadline-alert.danger { background: rgba(239, 68, 68, 0.15); border-left-color: #ef4444; color: #991b1b; border: 1px solid rgba(239, 68, 68, 0.3); }
.deadline-alert.overdue { background: rgba(220, 38, 38, 0.15); border-left-color: #dc2626; color: #7f1d1d; border: 1px solid rgba(220, 38, 38, 0.3); animation: pulse 2s infinite; }
.deadline-alert .alert-icon { font-size: 18px; flex-shrink: 0; }
.deadline-alert .alert-content { flex: 1; }
.deadline-alert .alert-message { font-weight: 700; margin-bottom: 4px; color: inherit; text-shadow: 0 1px 2px rgba(0,0,0,0.3); }
.deadline-alert .alert-date { font-size: 12px; opacity: 0.9; font-weight: 500; }
.no-alerts { color: #ffffff; font-style: italic; padding: 16px; text-align: center; background: rgba(255,255,255,0.05); border-radius: 6px; border: 1px solid rgba(255,255,255,0.1); }
@keyframes pulse { 0%, 100% { opacity: 1; box-shadow: 0 2px 4px rgba(0,0,0,0.1); } 50% { opacity: 0.8; box-shadow: 0 2px 8px rgba(0,0,0,0.2); } }

/* Validation error styles */
.validation-error { background: var(--err); color: white; border: 1px solid #b91c1c; animation: fadeIn 0.3s ease-in; }
.validation-error h4 { margin: 0 0 8px 0; color: #ffffff; }
.validation-error ul { margin: 0; padding-left: 20px; }
.validation-error li { margin-bottom: 4px; }
@keyframes fadeIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }

/* Search styles */
.search-results { position: absolute; top: 100%; left: 0; right: 0; background: var(--panel); border: 1px solid var(--b); border-radius: 8px; max-height: 400px; overflow-y: auto; z-index: 1000; box-shadow: 0 8px 25px rgba(0,0,0,.5); }
.search-result-item { padding: 12px; border-bottom: 1px solid var(--b); cursor: pointer; transition: background 0.2s; }
.search-result-item:hover { background: rgba(255,255,255,0.05); }
.search-result-item:last-child { border-bottom: none; }
.search-result-category { font-size: 11px; color: var(--acc); text-transform: uppercase; margin-bottom: 4px; }
.search-result-title { font-weight: 600; color: #ffffff; margin-bottom: 2px; }
.search-result-details { font-size: 12px; color: #ffffff; }
.search-no-results { padding: 20px; text-align: center; color: #ffffff; }

/* Gantt Chart styles */
.gantt-container { border: 1px solid var(--b); border-radius: 8px; overflow: hidden; max-height: 70vh; background: var(--panel); }
.gantt-header { display: flex; background: #1f2937; border-bottom: 1px solid var(--b); position: sticky; top: 0; z-index: 10; }
.gantt-resource-column { width: 200px; padding: 12px; font-weight: 600; color: #ffffff; border-right: 1px solid var(--b); background: #111827; }
.gantt-timeline { flex: 1; display: flex; position: relative; }
.gantt-time-slot { flex: 1; padding: 8px 4px; text-align: center; font-size: 11px; color: #ffffff; border-right: 1px solid rgba(148, 163, 184, 0.2); min-width: 60px; }
.gantt-body { max-height: calc(70vh - 50px); overflow-y: auto; }
.gantt-row { display: flex; border-bottom: 1px solid rgba(148, 163, 184, 0.1); }
.gantt-row:hover { background: rgba(255,255,255,0.02); }
.gantt-resource-cell { width: 200px; padding: 12px; border-right: 1px solid var(--b); background: #111827; color: #ffffff; font-weight: 500; }
.gantt-task-cell { flex: 1; position: relative; min-height: 50px; }
.gantt-task { position: absolute; height: 30px; background: var(--acc); border-radius: 4px; cursor: pointer; display: flex; align-items: center; padding: 0 8px; font-size: 11px; color: white; box-shadow: 0 2px 4px rgba(0,0,0,0.2); border: 2px solid transparent; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; min-width: 80px; max-width: 200px; transition: all 0.2s; }
.gantt-task:hover { border-color: #60a5fa; transform: translateY(-1px); }
.gantt-task.selected { border: 3px solid #fbbf24 !important; box-shadow: 0 0 12px rgba(251, 191, 36, 0.6), 0 2px 4px rgba(0,0,0,0.2) !important; transform: scale(1.05); z-index: 10; }
.gantt-task.todo { background: #f59e0b; }
.gantt-task.run { background: #3b82f6; }
.gantt-task.done { background: #10b981; }
.gantt-task.overdue { background: #ef4444; box-shadow: 0 0 8px rgba(239, 68, 68, 0.5); }
.gantt-current-time { position: absolute; top: 0; width: 2px; background: #ef4444; z-index: 10; pointer-events: none; }
.gantt-current-time::after { content: ''; position: absolute; top: -4px; left: -4px; width: 10px; height: 10px; background: #ef4444; border-radius: 50%; }

/* Drag & Drop styles */
.gantt-task.dragging { opacity: 0.5; transform: rotate(5deg); z-index: 1000; }
.gantt-task.drag-over { border-color: #10b981; background: rgba(16, 185, 129, 0.2); }
.gantt-drop-zone { position: absolute; height: 30px; background: rgba(16, 185, 129, 0.1); border: 2px dashed #10b981; border-radius: 4px; pointer-events: none; z-index: 999; }
.gantt-drop-zone.valid { background: rgba(16, 185, 129, 0.2); border-color: #10b981; }
.gantt-drop-zone.invalid { background: rgba(239, 68, 68, 0.1); border-color: #ef4444; }

/* Dependencies visualization */
.gantt-dependency { position: absolute; pointer-events: none; z-index: 10; overflow: visible; }
.gantt-dependency-line { stroke: #3b82f6; stroke-width: 3; fill: none; stroke-linecap: round; stroke-linejoin: round; }
.gantt-dependency-arrow { fill: #3b82f6; stroke: #3b82f6; stroke-width: 2; }
.gantt-dependency.manual { stroke: #10b981; stroke-width: 4; }
.gantt-dependency-arrow.manual { fill: #10b981; stroke: #10b981; }

/* Dependency creation mode */
.gantt-task.dependency-from { border-color: #3b82f6 !important; box-shadow: 0 0 8px rgba(59, 130, 246, 0.6) !important; }
.gantt-task.dependency-target { border-color: #10b981 !important; box-shadow: 0 0 8px rgba(16, 185, 129, 0.6) !important; }

/* Critical path highlighting */
.gantt-task.critical-path { background: linear-gradient(45deg, #ef4444, #dc2626); border: 2px solid #b91c1c; box-shadow: 0 0 8px rgba(239, 68, 68, 0.6); }
.gantt-dependency.critical { stroke: #ef4444; stroke-width: 3; }
.gantt-dependency-arrow.critical { fill: #ef4444; stroke: #ef4444; }

/* Float indicators */
.gantt-float-indicator { position: absolute; top: -20px; right: 2px; font-size: 10px; color: #ffffff; background: rgba(15, 23, 42, 0.8); padding: 2px 4px; border-radius: 2px; white-space: nowrap; }
.gantt-float-indicator.positive { color: #10b981; }
.gantt-float-indicator.zero { color: #ef4444; font-weight: bold; }
.gantt-float-indicator.negative { color: #f59e0b; }

/* Capacity Analysis Styles */
.capacity-item { display: flex; justify-content: space-between; align-items: center; padding: 12px; border: 1px solid var(--b); border-radius: 6px; margin-bottom: 8px; background: var(--panel); }
.capacity-employee { font-weight: 600; color: var(--text); }
.capacity-metrics { display: flex; flex-direction: column; gap: 4px; align-items: flex-end; }
.capacity-bar { position: relative; width: 120px; height: 20px; background: #e5e7eb; border-radius: 10px; overflow: hidden; display: flex; align-items: center; justify-content: center; }
.capacity-bar span { color: white; font-size: 11px; font-weight: 600; z-index: 1; }
.capacity-fill { position: absolute; left: 0; top: 0; height: 100%; transition: width 0.3s ease; }
.capacity-fill.low { background: #10b981; }
.capacity-fill.normal { background: #3b82f6; }
.capacity-fill.high { background: #f59e0b; }
.capacity-fill.overloaded { background: #ef4444; }

.bottleneck-item { padding: 12px; border: 1px solid #ef4444; border-radius: 6px; margin-bottom: 8px; background: rgba(239, 68, 68, 0.1); }
.bottleneck-name { font-weight: 600; color: #ef4444; margin-bottom: 4px; }
.bottleneck-metrics { font-size: 13px; color: var(--text-secondary); }

.efficiency-metric { display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid rgba(148, 163, 184, 0.1); }
.efficiency-metric:last-child { border-bottom: none; }
.metric-label { color: var(--text-secondary); }
.metric-value { font-weight: 600; color: var(--text); }

.empty { text-align: center; color: var(--text-secondary); padding: 20px; font-style: italic; }

/* Mobile responsiveness */
@media (max-width: 768px) {
  .grid3 { grid-template-columns: 1fr; }
  .grid2 { grid-template-columns: 1fr; }
  .row { flex-direction: column; align-items: stretch; }
  .wrap { padding: 8px; }
  .card { padding: 10px; margin-bottom: 8px; }
  .btn { padding: 10px 16px; font-size: 16px; }
  input, select, textarea { font-size: 16px; padding: 12px 14px; }
  label { font-size: 14px; }
  .gantt-resource-column, .gantt-resource-cell { width: 120px; font-size: 12px; }
  .gantt-time-slot { font-size: 10px; min-width: 40px; }
  .table { max-height: 40vh; }
  h3 { font-size: 16px; }
  h4 { font-size: 14px; }
  .pill { font-size: 10px; }
}

/* FIX: Wymuszenie kursora w modalach i checklistach */
#custom-modal, #custom-modal * {
  cursor: default !important;
}
#custom-modal [onclick] {
  cursor: pointer !important;
}
#custom-modal input:not([disabled]) {
  cursor: pointer !important;
}

/* Map view styles */
#map-view { display: flex; flex-direction: column; gap: 12px; }
#map-canvas { display: flex; flex-direction: column; gap: 12px; }
.map-card { background: var(--panel); border-radius: 14px; padding: 16px; border: 1px solid rgba(148, 163, 184, 0.18); box-shadow: 0 14px 32px rgba(15, 23, 42, 0.45); }
.map-card-header { display: flex; justify-content: space-between; align-items: flex-start; gap: 12px; margin-bottom: 12px; }
.map-card-title { font-size: 18px; font-weight: 700; color: #ffffff; margin: 0; }
.map-card-subtitle { color: rgba(148, 163, 184, 0.9); font-size: 13px; }
.map-card-meta { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; color: rgba(209, 231, 255, 0.9); font-size: 12px; }
.map-chip { display: inline-flex; align-items: center; gap: 6px; background: rgba(37, 99, 235, 0.18); border: 1px solid rgba(59, 130, 246, 0.3); border-radius: 999px; padding: 4px 10px; font-weight: 600; color: #bfdbfe; }
.map-section { margin-top: 12px; }
.map-section-title { font-weight: 600; color: #ffffff; margin-bottom: 6px; font-size: 14px; }
.map-list { list-style: none; margin: 0; padding: 0; display: flex; flex-direction: column; gap: 6px; }
.map-list li { background: rgba(148, 163, 184, 0.08); border: 1px solid rgba(148, 163, 184, 0.08); border-radius: 10px; padding: 10px 12px; color: #e2e8f0; font-size: 13px; line-height: 1.4; }
.map-order-meta { display: block; margin-top: 4px; font-size: 12px; color: rgba(148, 163, 184, 0.9); }
.map-stat { background: rgba(15, 23, 42, 0.95); border: 1px solid rgba(148, 163, 184, 0.18); border-radius: 12px; padding: 14px 16px; min-width: 140px; box-shadow: 0 10px 24px rgba(15, 23, 42, 0.5); }
.map-stat-value { display: block; font-size: 22px; font-weight: 700; color: #ffffff; }
.map-stat-label { font-size: 12px; color: rgba(148, 163, 184, 0.9); text-transform: uppercase; letter-spacing: 0.05em; }
.map-empty { text-align: center; padding: 40px; color: rgba(148, 163, 184, 0.9); border: 1px dashed rgba(148, 163, 184, 0.3); border-radius: 12px; background: rgba(148, 163, 184, 0.06); font-style: italic; }

@media (max-width: 768px) {
  .map-card-header { flex-direction: column; align-items: flex-start; }
  .map-card-meta { width: 100%; }
}
</style>
</head>
<body>
<header class="wrap">
  <div class="row" style="gap:8px">
    <button class="btn" data-nav="dash">Strona główna</button>
    <button class="btn" data-nav="tasks">Listy</button>
    <button class="btn" data-nav="order">Zlecenia</button>
    <button class="btn" data-nav="proc">Procesy</button>
    <button class="btn" data-nav="opcat">Katalog operacji</button>
    <button class="btn" data-nav="emp">Pracownicy</button>
    <button class="btn" data-nav="as">Montaż/Reklamacje</button>
    <button class="btn" data-nav="gantt">Harmonogram</button>
    <button class="btn" data-nav="capacity">Analiza</button>
    <button class="btn" data-nav="reports">Raporty</button>
    <button class="btn" data-nav="map">Mapy</button>
    <button class="btn" data-nav="monitor">Monitoring</button>
    <button class="btn" data-nav="mrp">MRP</button>
    <button class="btn" data-nav="wh">Magazyn</button>
    <button class="btn" data-nav="sync">🔄 Sync</button>
    <button class="btn" data-nav="backup">Backup</button>
    <button class="btn" data-nav="settings">Ustawienia</button>
  </div>
  <div class="row" style="gap:8px;margin-top:8px">
    <input type="text" id="global-search" placeholder="Szukaj zamówień, pracowników, zadań..." style="flex:1;max-width:400px">
    <button class="btn" id="search-btn">🔍 Szukaj</button>
    <div id="search-results" class="search-results" style="display:none"></div>
  </div>
</header>

<!-- Banner ostrzegawczy o różnych portach -->
<div id="port-warning-banner" style="display:none;background:#dc2626;color:white;padding:12px 20px;text-align:center;font-size:14px;font-weight:600;border-bottom:3px solid #991b1b">
  ⚠️ UWAGA: <span id="port-warning-detail">Aplikacja na porcie <span id="current-port"></span> ma OSOBNE dane!</span>
  <button onclick="window.showPortInfo()" style="background:white;color:#dc2626;border:none;padding:4px 12px;border-radius:4px;margin-left:12px;cursor:pointer;font-weight:600">📊 Pokaż info</button>
  <button onclick="window.exportDataToFile()" style="background:#10b981;color:white;border:none;padding:4px 12px;border-radius:4px;margin-left:8px;cursor:pointer;font-weight:600">💾 Eksport</button>
  <button onclick="window.importDataFromFile()" style="background:#3b82f6;color:white;border:none;padding:4px 12px;border-radius:4px;margin-left:8px;cursor:pointer;font-weight:600">📁 Import</button>
  <button onclick="document.getElementById('port-warning-banner').style.display='none'" style="background:transparent;color:white;border:1px solid white;padding:4px 12px;border-radius:4px;margin-left:8px;cursor:pointer">✕ Zamknij</button>
</div>

<div class="wrap">
  <div class="row" style="justify-content:space-between"><h1>Planner Produkcji Drzwi — v5.6.27</h1></div>

  <div class="card" id="p-dash">
    <h3>Panel</h3>
    <div class="grid3" style="margin-top:12px;gap:12px">
      <div style="background:rgba(37,99,235,0.18);border:1px solid rgba(59,130,246,0.35);border-radius:12px;padding:16px;display:flex;flex-direction:column;gap:6px;box-shadow:0 4px 14px rgba(15,23,42,0.45)">
        <span style="font-size:13px;color:#cbd5f5;text-transform:uppercase;letter-spacing:0.08em">Zlecenia</span>
        <span id="dash-orders" style="font-size:28px;font-weight:700;color:#ffffff">0</span>
      </div>
      <div style="background:rgba(16,185,129,0.18);border:1px solid rgba(16,185,129,0.35);border-radius:12px;padding:16px;display:flex;flex-direction:column;gap:6px;box-shadow:0 4px 14px rgba(15,23,42,0.45)">
        <span style="font-size:13px;color:#bbf7d0;text-transform:uppercase;letter-spacing:0.08em">Procesy</span>
        <span id="dash-proc" style="font-size:28px;font-weight:700;color:#ffffff">0</span>
      </div>
      <div style="background:rgba(249,115,22,0.18);border:1px solid rgba(249,115,22,0.35);border-radius:12px;padding:16px;display:flex;flex-direction:column;gap:6px;box-shadow:0 4px 14px rgba(15,23,42,0.45)">
        <span style="font-size:13px;color:#fed7aa;text-transform:uppercase;letter-spacing:0.08em">Operacje</span>
        <span id="dash-ops" style="font-size:28px;font-weight:700;color:#ffffff">0</span>
      </div>
    </div>

    <div id="deadline-alerts" style="margin-top:16px">
      <h4 style="color:#f59e0b;margin-bottom:8px">⏰ Powiadomienia o terminach</h4>
      <p class="no-alerts">Brak pilnych terminów zamówień</p>
    </div>
  </div>

  <div class="card hidden" id="p-order">
    <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:12px;gap:8px;flex-wrap:wrap">
      <h3>Zlecenia</h3>
      <div class="row" style="gap:8px">
        <button class="btn" type="button" onclick="window.exportDataToFile()">💾 Eksport</button>
        <button class="btn" type="button" onclick="window.importDataFromFile()">📁 Import</button>
      </div>
    </div>
    <form class="grid3" id="order-form">
      <input type="hidden" id="o-id">
      <div><label>Nazwa zlecenia</label><input id="o-name" placeholder="np. Zamówienie #123" required></div>
      <div><label>Klient</label><input id="o-client" placeholder="Nazwa klienta"></div>
      <div><label>Model</label><input id="o-model" placeholder="Model / wariant"></div>
      <div><label>Ilość</label><input id="o-qty" type="number" min="1" value="1"></div>
      <div><label>Data przyjęcia</label><input id="o-start" type="date"></div>
      <div><label>Termin produkcji</label><input id="o-end" type="date"></div>
      <div style="grid-column:1/-1"><label>Uwagi</label><textarea id="o-notes" rows="2" placeholder="Dodatkowe informacje, wymagania, kontakt..."></textarea></div>
      <div><label>Termin montażu</label><input id="o-install" type="date"></div>
      <div><label>Adres montażu</label><input id="o-addr" placeholder="ulica nr, miejscowość"></div>
      <div><label>Kod montażu</label><input id="o-post" placeholder="kod miejsca / 00-000"></div>
      <div><label>Telefon</label><input id="o-phone" placeholder="+48 600 000 000" pattern="\+?[0-9\s]{6,}" title="Minimum 6 cyfr, opcjonalny '+' na początku"></div>
      <div><label>Proces</label><select id="o-proc"></select></div>
      <div><label>Pracownik prowadzący</label><select id="o-lead"><option value="">— wybierz pracownika —</option></select></div>
      <div style="grid-column:1/-1;text-align:right"><button class="btn primary" type="submit">Zapisz zlecenie</button></div>
    </form>
    <div class="table" style="margin-top:12px">
      <table>
        <thead>
          <tr>
            <th>Nr zlecenia</th>
            <th>Klient</th>
            <th>Model</th>
            <th>Ilość</th>
            <th>Data przyjęcia</th>
            <th>Termin</th>
            <th>Montaż</th>
            <th>Kod montażu</th>
            <th>Postęp</th>
            <th>Lead time (h)</th>
            <th>Materiały</th>
            <th>Akcje</th>
          </tr>
        </thead>
        <tbody id="ord-tb"></tbody>
      </table>
    </div>
  </div>

  <div class="card hidden" id="p-tasks">
    <div class="row" style="justify-content:space-between;align-items:flex-start;flex-wrap:wrap;gap:12px">
      <div>
        <h3>Zadania</h3>
        <div class="muted">Wyświetlane zadania: <span id="tasks-count">0</span></div>
      </div>
      <div class="row" style="gap:8px;flex-wrap:wrap;justify-content:flex-end">
        <select id="tasks-filter-order" style="min-width:180px">
          <option value="">Wszystkie zlecenia</option>
        </select>
        <select id="tasks-filter-status" style="min-width:160px">
          <option value="">Wszystkie statusy</option>
          <option value="todo">Do zrobienia</option>
          <option value="run">W realizacji</option>
          <option value="done">Zamknięte</option>
        </select>
        <button class="btn" id="tasks-gen-by-emp" type="button">Zbuduj raport</button>
        <button class="btn" id="tasks-export-csv-by-emp" type="button">Eksport CSV</button>
        <button class="btn" id="tasks-show-by-emp" type="button">Pokaż podział</button>
      </div>
    </div>
    <div class="muted" style="margin-bottom:8px">Użyj filtrów, aby zawęzić listę i szybko przygotować raporty dla brygad.</div>
    <div class="list" id="tasks-list"></div>
    <div id="tasks-by-worker" class="list" style="margin-top:16px"></div>
  </div>

  <div class="card hidden" id="p-opcat">
    <div class="row" style="justify-content:space-between">
      <h3>Katalog operacji</h3><span class="pill" id="op-count">0</span>
      <div class="row">
          <button class="btn" id="op-normalize">Porządkuj</button>
          <button class="btn" id="op-sort-az">Sortuj A→Z</button>
          <select id="op-comp-select" style="min-width:160px;margin-left:8px"><option value="">— wybierz komponent —</option></select>
          <button class="btn" id="op-sort-comp" style="margin-left:6px">Sortuj po komponencie</button>
          <button class="btn green" id="op-save-db" style="margin-left:6px">Zapisz do DB</button>
        </div>
    </div>
    <form class="grid3" id="op-form">
      <input type="hidden" id="op-id">
      <div><label>Nr (kolejność)</label><input id="op-no" type="number" min="1" value="1"></div>
      <div><label>Nazwa</label><input id="op-name" required></div>
      <div><label>Czas [min] (≥1)</label><input id="op-time" type="number" min="1" value="10"></div>
      <div><label>Domyślna liczba prac. (≥1)</label><input id="op-workers" type="number" min="1" value="1"></div>
      <div style="grid-column:1/-1"><label>Komponenty (;)</label>
        <input id="op-skills" placeholder="np. piła; wkręty; listwa">
      </div>
      <div style="grid-column:1/-1"><label>Domyślni pracownicy (multi)</label>
        <select id="op-emp" multiple size="5" style="height:140px"></select>
      </div>
      <div style="grid-column:1/-1;text-align:right">
        <button class="btn primary" type="submit">Dodaj / Zapisz</button>
      </div>
      <div class="muted" id="op-msg"></div>
    </form>
    <div class="table" style="margin-top:8px">
      <table>
        <thead>
          <tr><th>Nr</th><th>Nazwa</th><th>min</th><th>prac.</th><th>komponenty</th><th>domyślni prac.</th><th>Akcje</th></tr>
        </thead>
        <tbody id="op-tb"></tbody>
      </table>
    </div>
  </div>

  <div class="card hidden" id="p-proc">
    <div class="row" style="justify-content:space-between"><h3>Procesy</h3><span class="pill" id="proc-count">0</span></div>
    <form class="grid3" id="proc-form">
      <input type="hidden" id="proc-id">
      <div><label>Nazwa procesu</label><input id="proc-name" required></div>
      <div><label>Dodaj z katalogu</label><select id="proc-op-select"></select></div>
      <div><label>📑 Szablon materiałowy (opcjonalne)</label><select id="proc-template-select"><option value="">Brak</option></select></div>
      <div style="grid-column:1/-1" class="row">
        <button class="btn" id="proc-add-op" type="button">➕ Dodaj operację</button>
        <button class="btn primary" type="submit">Zapisz proces</button>
      </div>
    </form>
    <div><b>Operacje w procesie</b></div>
    <div class="list" id="proc-ops"></div>
    <div class="list" id="proc-list"></div>
  </div>

  <div class="card hidden" id="p-emp">
    <div class="row" style="justify-content:space-between"><h3>Pracownicy</h3><button class="btn" id="emp-add">Dodaj</button></div>
    <div class="table"><table><thead><tr><th>Imię i nazwisko</th><th>cap%</th><th>h/d</th><th>Akcje</th></tr></thead><tbody id="emp-tb"></tbody></table></div>
  </div>

  <div class="card hidden" id="p-as">
    <div class="row" style="justify-content:space-between">
      <h3>Montaż / Reklamacje</h3>
      <button class="btn" data-refresh-as>Odśwież z bazy</button>
    </div>
    <form class="grid3" id="as-form">
      <input type="hidden" id="as-id">
      <div><label>Typ</label><select id="as-type"><option>montaż</option><option>reklamacja</option></select></div>
      <div><label>Zlecenie</label><select id="as-order"></select></div>
      <div><label>Pracownik prowadzący</label><input id="as-lead" readonly></div>
      <div><label>Pracownicy montażowi (Ctrl+klik = wiele)</label><select id="as-employees" multiple size="6" style="width:100%;"></select></div>
      <div><label>Adres montażu</label><input id="as-address" placeholder="ulica nr, miejscowość"></div>
      <div><label>Kod montażu</label><input id="as-placecode" placeholder="kod pocztowy"></div>
      <div><label>Telefon</label><input id="as-phone" placeholder="telefon kontaktowy"></div>
      <div><label>Status</label><select id="as-status"><option>nowe</option><option>w toku</option><option>zamknięte</option></select></div>
      <div><label>Termin montażu</label><input id="as-install" type="date"></div>
      <div><label>Godzina wyjazdu</label><input id="as-go" type="time"></div>
      <div><label>Godzina wizyty</labe><input id="as-visit" type="time"></div>
      <div><label>Liczba godzin montażu</label><input id="as-hours" type="number" step="0.5" min="0" placeholder="np. 2.5"></div>
      <div style="grid-column:1/-1"><label>Opis</label><textarea id="as-desc" rows="2"></textarea></div>
      <div style="grid-column:1/-1;text-align:right"><button class="btn primary" type="submit">Zapisz</button></div>
    </form>
    <div class="list" id="as-list"></div>
  </div>

  <div class="card hidden" id="p-map">
    <div class="row" style="justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap">
      <h3 style="margin:0">Mapy Model↔Proces</h3>
      <div class="row" style="gap:8px;flex-wrap:wrap">
        <button class="btn" id="map-export-json">📄 Eksport JSON</button>
        <button class="btn" id="map-export-png">🖼️ Eksport PNG</button>
      </div>
    </div>
    <div class="row" style="gap:8px;flex-wrap:wrap;margin-top:12px">
      <select id="map-filter-model" style="min-width:180px;padding:8px;border-radius:8px;background:#111827;color:#e2e8f0;border:1px solid rgba(148,163,184,0.3)">
        <option value="__ALL__">Wszystkie modele</option>
      </select>
      <select id="map-filter-process" style="min-width:180px;padding:8px;border-radius:8px;background:#111827;color:#e2e8f0;border:1px solid rgba(148,163,184,0.3)">
        <option value="__ALL__">Wszystkie procesy</option>
      </select>
      <select id="map-filter-status" style="min-width:180px;padding:8px;border-radius:8px;background:#111827;color:#e2e8f0;border:1px solid rgba(148,163,184,0.3)">
        <option value="__ALL__">Wszystkie statusy</option>
      </select>
    </div>
    <div id="map-stats" class="row" style="gap:12px;flex-wrap:wrap;margin-top:16px"></div>
    <div id="map-view" style="margin-top:16px">
      <div id="map-canvas" class="list">
        <div class="map-empty">Ładowanie danych mapy...</div>
      </div>
    </div>
  </div>
  <div class="card hidden" id="p-monitor"><h3>Monitoring postępów</h3><div class="muted">Placeholder.</div></div>
  <div class="card hidden" id="p-mrp">
    <div class="row" style="justify-content:space-between">
      <h3>Zakupy (MRP)</h3>
      <button class="btn green" id="mrp-generate">Generuj listę zakupów</button>
    </div>
    <div class="list" id="mrp-list"></div>
  </div>
  
  <div class="card hidden" id="p-wh">
    <div class="row" style="justify-content:space-between;margin-bottom:16px">
      <h3>📦 Magazyn</h3>
      <div class="row" style="gap:8px">
        <button class="btn orange" onclick="toggleOrderFilter()">🔴 Do zamówienia</button>
        <button class="btn blue" onclick="exportWarehouseToCSV()">📊 Eksportuj CSV</button>
        <button class="btn green" id="wh-add">➕ Dodaj pozycję</button>
      </div>
    </div>
    
    <!-- Zakładki magazynu -->
    <div class="row" style="gap:8px;margin-bottom:16px;border-bottom:1px solid var(--b);padding-bottom:8px">
      <button class="btn" id="wh-tab-items" onclick="switchWarehouseTab('items')">📋 Pozycje</button>
      <button class="btn" id="wh-tab-transactions" onclick="switchWarehouseTab('transactions')">📝 Przychód/Rozchód</button>
      <button class="btn" id="wh-tab-reservations" onclick="switchWarehouseTab('reservations')">🔒 Rezerwacje</button>
      <button class="btn" id="wh-tab-tasks" onclick="switchWarehouseTab('tasks')" style="position:relative">
        ✓ Zadania magazyniera
        <span id="tasks-badge" style="display:none;position:absolute;top:-8px;right:-8px;background:#dc2626;color:white;border-radius:12px;padding:2px 8px;font-size:12px;font-weight:bold;min-width:20px;text-align:center"></span>
      </button>
      <button class="btn" id="wh-tab-templates" onclick="switchWarehouseTab('templates')">📑 Szablony materiałowe</button>
      <button class="btn primary" id="shopping-list-btn" onclick="window.showShoppingList()" style="background:#f59e0b;margin-left:auto;position:relative">
        🛒 Lista zakupów
        <span id="shopping-badge" style="display:none;position:absolute;top:-8px;right:-8px;background:#dc2626;color:white;border-radius:12px;padding:2px 8px;font-size:12px;font-weight:bold;min-width:20px;text-align:center"></span>
      </button>
    </div>
    
    <!-- Widok: Pozycje magazynowe -->
    <div id="wh-view-items">
      <div class="row" style="gap:16px;margin-bottom:16px">
        <input type="text" id="wh-search" placeholder="🔍 Szukaj pozycji..." style="flex:1">
      </div>
      <div class="list" id="wh-list">
        <div style="text-align:center;padding:40px;color:#999">Brak pozycji w magazynie. Kliknij "Dodaj pozycję".</div>
      </div>
    </div>
    
    <!-- Widok: Przychód/Rozchód -->
    <div id="wh-view-transactions" class="hidden">
      <div class="row" style="gap:8px;margin-bottom:16px">
        <button class="btn green" onclick="showTransactionModal('in')">📥 Przyjęcie (PZ)</button>
        <button class="btn orange" onclick="showTransactionModal('out')">📤 Wydanie (WZ)</button>
        <select id="wh-transaction-filter" onchange="renderTransactions()" style="margin-left:auto">
          <option value="">Wszystkie</option>
          <option value="in">Tylko przyjęcia</option>
          <option value="out">Tylko wydania</option>
        </select>
      </div>
      <div class="list" id="wh-transactions-list"></div>
    </div>
    
    <!-- Widok: Rezerwacje -->
    <div id="wh-view-reservations" class="hidden">
      <div class="row" style="gap:8px;margin-bottom:16px">
        <button class="btn blue" onclick="showReservationModal()">🔒 Nowa rezerwacja</button>
        <button class="btn" onclick="autoReserveForOrders()">⚡ Auto-rezerwuj dla zleceń</button>
      </div>
      <div class="list" id="wh-reservations-list"></div>
    </div>
    
    <!-- Widok: Zadania magazyniera -->
    <div id="wh-view-tasks" class="hidden">
      <div style="margin-bottom:16px;padding:12px;background:#eff6ff;border-left:4px solid #3b82f6;border-radius:4px">
        <div style="font-weight:600;font-size:16px;color:#1e40af;margin-bottom:4px">✓ Zadania magazyniera</div>
        <div style="font-size:14px;color:#64748b">Lista zadań związanych z zamówieniami, przyjęciem i wydaniem materiałów</div>
      </div>
      <div class="row" style="gap:8px;margin-bottom:16px">
        <button class="btn" onclick="filterWarehouseTasks('all')">Wszystkie</button>
        <button class="btn" onclick="filterWarehouseTasks('pending')">⏳ Do zrobienia</button>
        <button class="btn" onclick="filterWarehouseTasks('urgent')">🔴 Pilne</button>
        <button class="btn green" onclick="filterWarehouseTasks('completed')">✅ Zakończone</button>
      </div>
      <div class="list" id="wh-tasks-list"></div>
    </div>
    
    <!-- Widok: Szablony materiałowe -->
    <div id="wh-view-templates" class="hidden">
      <div class="row" style="gap:8px;margin-bottom:16px">
        <button class="btn green" onclick="showTemplateModal()">📑 Nowy szablon</button>
        <button class="btn orange" onclick="window.migrateTemplateIds(); alert('Sprawdź konsolę (F12) po wyniki migracji')">🔧 Napraw stare szablony</button>
        <button class="btn red" onclick="refreshAllChecklists()">♻️ Odśwież wszystkie checklisty</button>
        <button class="btn" onclick="diagnoseShablon()">🔍 Diagnoza szablonów</button>
      </div>
      <div class="list" id="wh-templates-list"></div>
    </div>
  </div>

  <div class="card hidden" id="p-sync">
    <div class="row" style="justify-content:space-between;margin-bottom:16px">
      <h3>🔄 Synchronizacja z pracownikami</h3>
    </div>
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
      <div class="card" style="text-align: center;">
        <h4>📤 Eksport zadań</h4>
        <p style="color: #94a3b8; font-size: 14px; margin: 8px 0;">
          Wyeksportuj zadania produkcyjne dla aplikacji pracowników
        </p>
        <button class="btn green" onclick="exportTasksForWorkers()">📤 Eksportuj zadania</button>
      </div>
      <div class="card" style="text-align: center;">
        <h4>📥 Import potwierdzeń</h4>
        <p style="color: #94a3b8; font-size: 14px; margin: 8px 0;">
          Zaimportuj potwierdzenia wykonania zadań od pracowników
        </p>
        <button class="btn blue" onclick="importWorkerConfirmations()">📥 Importuj potwierdzenia</button>
      </div>
    </div>
    <div style="margin-top: 16px; padding: 12px; background: rgba(37, 99, 235, 0.1); border-radius: 8px; border-left: 4px solid #2563eb;">
      <h4 style="margin: 0 0 8px 0; color: #2563eb;">📱 Instrukcja użycia:</h4>
      <ol style="margin: 0; padding-left: 20px; color: #94a3b8; font-size: 14px;">
        <li>Otwórz aplikację <code>worker-app.html</code> na urządzeniu pracownika</li>
        <li>Wyeksportuj zadania i prześlij plik na urządzenie</li>
        <li>Pracownik potwierdza wykonanie zadań w aplikacji</li>
        <li>Zaimportuj potwierdzenia z powrotem do systemu głównego</li>
      </ol>
    </div>
  </div>

  <div class="card hidden" id="p-backup">
    <div class="row" style="justify-content:space-between;margin-bottom:16px">
      <h3>💾 Backup i Odzyskiwanie</h3>
      <div class="row" style="gap:8px">
        <button class="btn green" id="backup-create">📦 Utwórz backup</button>
        <button class="btn blue" id="export-data">💾 Eksportuj dane do pliku</button>
        <button class="btn amber" id="import-data">📁 Importuj dane z pliku</button>
        <button class="btn" id="backup-refresh">🔄 Odśwież listę</button>
        <button class="btn" id="backup-cleanup">🧹 Wyczyść stare</button>
      </div>
    </div>

    <!-- Statystyki backupów -->
    <div class="card" style="margin-bottom:16px">
      <h4>📊 Statystyki backupów</h4>
      <div class="grid3" id="backup-stats">
        <div class="card" style="text-align:center">
          <div style="font-size:24px;font-weight:bold;color:var(--acc)" id="backup-count">0</div>
          <div style="color:var(--text-secondary)">Liczba backupów</div>
        </div>
        <div class="card" style="text-align:center">
          <div style="font-size:24px;font-weight:bold;color:var(--ok)" id="backup-latest">-</div>
          <div style="color:var(--text-secondary)">Najnowszy backup</div>
        </div>
        <div class="card" style="text-align:center">
          <div style="font-size:24px;font-weight:bold;color:var(--warn)" id="backup-size">0 MB</div>
          <div style="color:var(--text-secondary)">Całkowity rozmiar</div>
        </div>
      </div>
    </div>

    <!-- Lista backupów -->
    <div class="card" style="margin-bottom:16px">
      <h4>📁 Dostępne backupy</h4>
      <div id="backup-list" class="list" style="max-height:300px;overflow-y:auto">
        <div class="muted">Brak dostępnych backupów. Utwórz pierwszy backup.</div>
      </div>
    </div>

    <!-- Opcje backupu -->
    <div class="card">
      <h4>⚙️ Opcje backupu</h4>
      <div class="grid2" style="margin-top:12px">
        <div>
          <label><input type="checkbox" id="backup-include-settings" checked> Dołącz ustawienia aplikacji</label>
        </div>
        <div>
          <label><input type="checkbox" id="backup-include-logs" checked> Dołącz historię operacji</label>
        </div>
        <div>
          <label><input type="checkbox" id="backup-compress" checked> Kompresuj backup (ZIP)</label>
        </div>
        <div>
          <label><input type="checkbox" id="backup-auto-cleanup"> Automatyczne czyszczenie starych backupów</label>
        </div>
      </div>

      <div style="margin-top:16px">
        <label>Maksymalna liczba backupów do przechowywania:</label>
        <select id="backup-max-count" style="margin-left:8px;padding:4px">
          <option value="5">5</option>
          <option value="10" selected>10</option>
          <option value="20">20</option>
          <option value="50">50</option>
          <option value="unlimited">Bez limitu</option>
        </select>
      </div>

      <div style="margin-top:16px;text-align:right">
        <button class="btn" id="backup-settings-save">💾 Zapisz ustawienia</button>
      </div>
    </div>

    <!-- Informacje o bezpieczeństwie -->
    <div class="card" style="margin-top:16px;background:#1a2332;border:1px solid #334155">
      <h4>🔒 Bezpieczeństwo danych</h4>
      <ul style="margin:8px 0;padding-left:20px">
        <li>Backupy są przechowywane lokalnie w przeglądarce</li>
        <li>Dane są kompresowane i zabezpieczone</li>
        <li>Można eksportować backupy jako pliki do zewnętrznego przechowywania</li>
        <li>Zaleca się regularne tworzenie backupów przed ważnymi zmianami</li>
      </ul>
    </div>
  </div>

  <div class="card hidden" id="p-gantt">
    <div class="row" style="justify-content:space-between">
      <h3>Harmonogram Produkcji (Gantt)</h3>
      <div class="row">
        <button class="btn" id="gantt-prev-period" title="Poprzedni tydzień/miesiąc">◄ Wstecz</button>
        <button class="btn" id="gantt-today" title="Dzisiaj">Dzisiaj</button>
        <button class="btn" id="gantt-next-period" title="Następny tydzień/miesiąc">Dalej ►</button>
        <select id="gantt-view">
          <option value="week">Widok tygodniowy</option>
          <option value="month">Widok miesięczny</option>
        </select>
  <button class="btn" id="gantt-refresh">Odśwież</button>
  <button class="btn amber" id="gantt-replan-all" title="Resetuj i przelicz wszystkie zadania z uwzględnieniem aktualnej konfiguracji">Przelicz harmonogram</button>
        <button class="btn" id="gantt-auto-assign">Auto-przypisz</button>
        <button class="btn" id="gantt-generate-test">Generuj dane testowe</button>
        <button class="btn" id="gantt-export">Eksport PNG</button>
        <button class="btn" id="gantt-show-dependencies" title="Pokaż/ukryj zależności między zadaniami">📊 Zależności</button>
        <button class="btn" id="gantt-create-dependency" title="Utwórz zależność między zadaniami">🔗 Utwórz zależność</button>
        <button class="btn" id="gantt-manage-dependencies" title="Zarządzaj zależnościami">📋 Zarządzaj</button>
        <button class="btn" id="gantt-show-critical-path" title="Pokaż/ukryj ścieżkę krytyczną">🎯 Ścieżka krytyczna</button>
      </div>
    </div>
    <div class="row" style="padding:8px;gap:8px;align-items:center;background:#f1f5f9;border-radius:4px;margin-bottom:8px">
      <span style="font-size:12px;color:#64748b">Zaznaczone zadanie:</span>
      <span id="gantt-selected-task-info" style="font-size:12px;font-weight:600;color:#1e293b;flex:1">Brak</span>
      <button class="btn" id="gantt-move-task-back" title="Przesuń zadanie o 1 dzień wstecz" disabled>◄ -1 dzień</button>
      <button class="btn" id="gantt-move-task-forward" title="Przesuń zadanie o 1 dzień do przodu" disabled>+1 dzień ►</button>
      <button class="btn amber" id="gantt-clear-selection" title="Odznacz zadanie" disabled>Odznacz</button>
    </div>
    <div id="gantt-container" class="gantt-container">
      <div class="gantt-header">
        <div class="gantt-resource-column">Zasób</div>
        <div class="gantt-timeline" id="gantt-timeline"></div>
      </div>
      <div class="gantt-body" id="gantt-body">
        <!-- Dependencies visualization layer -->
        <svg id="gantt-dependencies" class="gantt-dependency" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10;"></svg>
      </div>
    </div>
  </div>

  <div class="card hidden" id="p-capacity">
    <div class="row" style="justify-content:space-between">
      <h3>Analiza Przepustowości Produkcji</h3>
      <div class="row">
        <select id="capacity-period">
          <option value="day">Dzień</option>
          <option value="week" selected>Tydzień</option>
          <option value="month">Miesiąc</option>
        </select>
        <button class="btn" id="capacity-refresh">Odśwież</button>
        <button class="btn" id="capacity-optimize">🔄 Optymalizuj obciążenie</button>
        <button class="btn" id="capacity-export">Eksport CSV</button>
      </div>
    </div>

    <div class="grid2" style="margin-top: 16px;">
      <div class="card">
        <h4>Wykorzystanie Zasobów</h4>
        <div id="capacity-resources" class="list"></div>
      </div>

      <div class="card">
        <h4>Wąskie Gardła</h4>
        <div id="capacity-bottlenecks" class="list"></div>
      </div>
    </div>

    <div class="card" style="margin-top: 16px;">
      <h4>Efektywność Produkcji</h4>
      <div id="capacity-efficiency" class="list"></div>
    </div>

    <div class="card" style="margin-top: 16px;">
      <h4>💡 Sugestie optymalizacji obciążenia</h4>
      <div id="capacity-optimization" class="list"></div>
    </div>
  </div>

  <div class="card hidden" id="p-settings">
    <div class="row" style="justify-content:space-between"><h3>Ustawienia</h3></div>
    
    <div id="high-contrast-toggle-wrapper">
      <label><input type="checkbox" id="toggle-high-contrast"> Wysoki kontrast ostrzeżeń</label>
    </div>
    
    <div class="grid3">
      <div><label>Tryb</label><select id="set-mode"><option value="local">localStorage</option><option value="firebase" selected>Firebase</option></select></div>
	<div><label>Początek dnia (h)</label><input id="sched-start" type="number" min="0" max="23" value="8"></div>
	<div><label>Długość dnia (h)</label><input id="sched-len" type="number" min="1" max="16" value="8"></div>
      <div><label>App ID</label><input id="set-appid" value="doors-demo"></div>
      <div><label>User ID</label><input id="set-userid" value="hala-1"></div>
      <div style="grid-column:1/4;margin-top:8px">
        <fieldset style="border:1px solid #334155;padding:8px;border-radius:4px">
          <legend style="padding:0 6px;font-size:13px">Dni wolne tygodnia</legend>
          <div style="display:flex;flex-wrap:wrap;gap:8px;font-size:13px">
            <label><input type="checkbox" class="sched-offday" value="1"> Poniedziałek (1)</label>
            <label><input type="checkbox" class="sched-offday" value="2"> Wtorek (2)</label>
            <label><input type="checkbox" class="sched-offday" value="3"> Środa (3)</label>
            <label><input type="checkbox" class="sched-offday" value="4"> Czwartek (4)</label>
            <label><input type="checkbox" class="sched-offday" value="5"> Piątek (5)</label>
            <label><input type="checkbox" class="sched-offday" value="6"> Sobota (6)</label>
            <label><input type="checkbox" class="sched-offday" value="0"> Niedziela (0)</label>
          </div>
          <div style="margin-top:6px;display:flex;align-items:center;gap:8px;flex-wrap:wrap">
            <button type="button" class="btn tiny" id="btn-offdays-weekend">Weekend</button>
            <button type="button" class="btn tiny" id="btn-offdays-workweek">Tylko weekend</button>
            <button type="button" class="btn tiny" id="btn-offdays-clear">Wyczyść</button>
            <span style="font-size:11px;color:#94a3b8">Zaznaczone dni są POMIJANE w planowaniu (Date.getDay(): Niedziela=0 ... Sobota=6)</span>
          </div>
        </fieldset>
      </div>
      <div style="grid-column:1/4;margin-top:8px">
        <label style="display:block;font-size:13px;margin-bottom:4px">Święta / dodatkowe dni wolne (YYYY-MM-DD, po przecinku)</label>
        <textarea id="sched-holidays" rows="2" placeholder="2025-11-01,2025-12-25" style="width:100%;resize:vertical"></textarea>
      </div>
    </div>
  <div class="list" style="margin-top:8px">
      <label>Firebase config (JSON)</label>
      <textarea id="set-fb" rows="8">{
  "apiKey": "AIzaSyD93UqqsHWoAUBV7g8OVKAnajIfGDX_ZdY",
  "authDomain": "doors-planner.firebaseapp.com",
  "projectId": "doors-planner",
  "storageBucket": "doors-planner.appspot.com",
  "messagingSenderId": "513098608067",
  "appId": "1:513098608067:web:1fe3855b3470ca7ef22176"
}</textarea>
      <div class="row">
        <button class="btn primary" id="set-test">Test &amp; Connect</button>
        <button class="btn green"   id="set-save">Zapisz do DB</button>
        <button class="btn"         id="set-load">Wczytaj z DB</button>
      </div>
      <div class="row" style="margin-top:8px">
  <label style="font-size:13px"><input type="checkbox" id="set-autosave-assign" checked> Auto-save do Firebase przy ważnych zmianach (np. przypisania)</label>
      </div>
    <div class="row" style="margin-top:8px">
  <label style="font-size:13px"><input type="checkbox" id="set-autoload-db"> Automatycznie wczytaj z Firebase przy starcie (jeśli tryb = Firebase)</label>
    </div>
      <div class="row" style="margin-top:8px">
        <label style="font-size:13px">Threshold wąskich gardeł: <input id="set-monitor-threshold" type="number" min="1" value="5" style="width:80px;margin-left:8px"></label>
      </div>
      <div class="row" style="margin-top:8px">
        <label style="font-size:13px"><input type="checkbox" id="set-monitor-alerts" checked> Włącz alerty monitoringu (baner gdy threshold przekroczony)</label>
      </div>
    <div class="row" style="margin-top:8px">
      <label style="font-size:13px"><input type="checkbox" id="set-auto-cleanup"> Automatyczne czyszczenie zleceń (usuń zadania po zamknięciu wszystkich)</label>
    </div>
    <div class="row" style="margin-top:8px">
  <label style="font-size:13px"><input type="checkbox" id="set-spellcheck-enforce"> Wymuszaj sprawdzanie pisowni (PL) dla wszystkich pól</label>
    </div>
      <div class="row" style="margin-top:8px;gap:8px">
        <button class="btn" id="export-tasks">Eksport zadań (.json)</button>
        <input type="file" id="import-tasks-file" accept=".json" style="display:none">
        <button class="btn" id="import-tasks">Import zadań</button>
        <button class="btn red" id="restore-authentic-data" title="Przywróć autentyczne dane z backupu">🔄 Przywróć dane</button>
        <button class="btn blue" id="restore-click-delegation" title="Przywróć normalną obsługę kliknięć">🔧 Napraw kliknięcia</button>
      </div>
      <div class="row" style="margin-top:8px;gap:8px">
        <button class="btn green" id="gen-test-data">Zaktualizuj dane testowe</button>
        <button class="btn blue" id="gen-deadline-test">Dodaj zamówienia testowe</button>
        <button class="btn" id="export-data">Eksportuj dane</button>
        <button class="btn" id="import-data">Importuj dane</button>
        <button class="btn red" id="clear-data">Wyczyść dane</button>
      </div>
      <div id="set-info" style="color:#ffffff !important;font-weight:600;font-size:14px;background:#1a2332;padding:4px 8px;border-radius:4px;border:1px solid #334155;"></div>
    </div>
  </div>
</div>

<!-- Raporty produkcyjne -->
<div class="card hidden" id="p-reports">
  <div class="row" style="justify-content:space-between;margin-bottom:16px">
    <h3>Raporty produkcyjne</h3>
    <div class="row" style="gap:8px">
      <select id="report-period" style="padding:6px 8px;border-radius:6px;border:1px solid var(--b)">
        <option value="week">Tydzień</option>
        <option value="month">Miesiąc</option>
        <option value="quarter">Kwartał</option>
        <option value="year">Rok</option>
      </select>
      <button class="btn" id="report-generate-test">Generuj dane testowe</button>
      <button class="btn" id="report-generate">📊 Generuj raport</button>
      <button class="btn" id="report-export">📄 Eksport PDF</button>
    </div>
  </div>

  <div id="reports-content">
    <!-- Progress bar -->
    <div id="reports-progress" class="card hidden" style="margin-bottom:16px">
      <div style="display:flex;align-items:center;gap:12px;margin-bottom:8px">
        <span id="reports-progress-text">Generowanie raportu...</span>
        <span id="reports-progress-percent">0%</span>
      </div>
      <div style="width:100%;height:8px;background:#e5e7eb;border-radius:4px;overflow:hidden">
        <div id="reports-progress-bar" style="width:0%;height:100%;background:linear-gradient(90deg,#3b82f6,#1d4ed8);transition:width 0.3s ease"></div>
      </div>
    </div>

    <!-- Statystyki ogólne -->
    <div class="card" style="margin-bottom:16px">
      <h4>📈 Statystyki produkcji</h4>
      <div class="grid3" id="report-stats">
        <div class="card" style="text-align:center">
          <div style="font-size:24px;font-weight:bold;color:var(--acc)" id="stat-total-orders">0</div>
          <div style="color:var(--text-secondary)">Zleceń</div>
        </div>
        <div class="card" style="text-align:center">
          <div style="font-size:24px;font-weight:bold;color:var(--ok)" id="stat-completed-tasks">0</div>
          <div style="color:var(--text-secondary)">Ukończonych zadań</div>
        </div>
        <div class="card" style="text-align:center">
          <div style="font-size:24px;font-weight:bold;color:var(--warn)" id="stat-efficiency">0%</div>
          <div style="color:var(--text-secondary)">Efektywność</div>
        </div>
      </div>
    </div>

    <!-- Wykresy wydajności -->
    <div class="card" style="margin-bottom:16px">
      <h4>📊 Wydajność pracowników</h4>
      <div id="report-employee-performance" style="height:300px">
        <div class="empty">Wybierz okres i kliknij "Generuj raport"</div>
      </div>
    </div>

    <!-- Raport kosztów -->
    <div class="card" style="margin-bottom:16px">
      <h4>💰 Koszty produkcji</h4>
      <div id="report-costs">
        <div class="empty">Wybierz okres i kliknij "Generuj raport"</div>
      </div>
    </div>

    <!-- Szczegółowe statystyki -->
    <div class="card">
      <h4>📋 Szczegółowe statystyki</h4>
      <div id="report-details" class="table">
        <div class="empty">Wybierz okres i kliknij "Generuj raport"</div>
      </div>
    </div>
  </div>
</div>

<div id="client-window" class="hidden">
  <!-- Szczegóły klienta będą renderowane dynamicznie -->
</div>

<!-- Wczytanie podstawowych utili oraz UI zanim główny skrypt inline uruchomi diagnostykę -->
<script src="js/base-utils.js?v=20251005-1400"></script>
<script src="js/store.js?v=20251005-1400"></script>
<script src="js/ui.js?v=20251005-1415"></script>
<script src="js/schedule.js?v=20251005-1500"></script>
<script src="js/app-helpers.js?v=20251005-1400"></script>
<script src="js/map.js?v=20251019-01"></script>
<script>
// === MAGAZYN - NAJWYŻSZY PRIORYTET ===
// System magazynowy zostanie zainicjalizowany później w kodzie
console.log('Magazyn: Inicjalizacja systemu zarządzania magazynem...');

// Kod automatycznego renderowania magazynu usunięty

(function(){
  // create on-page developer log panel with visible toggle so user can read logs without DevTools
  try{
    const initDevLog = ()=>{
      const devLogEl = document.createElement('div');
      devLogEl.id = 'dev-log';
      Object.assign(devLogEl.style, {
        position: 'fixed', right: '12px', bottom: '48px', maxWidth: '420px', maxHeight: '40vh', overflow: 'auto',
        background: 'rgba(8,8,12,0.95)', color: '#cbd5e1', padding: '8px', borderRadius: '8px', fontSize: '12px', zIndex: '99999', boxShadow: '0 6px 18px rgba(0,0,0,.5)', border: '1px solid rgba(255,255,255,0.04)'
      });
      devLogEl.innerHTML = '<b style="display:block;margin-bottom:6px">Dev log</b>';

      const toggle = document.createElement('button');
      toggle.type = 'button'; toggle.id = 'dev-log-toggle'; toggle.textContent = 'DevLog';
      Object.assign(toggle.style, { position:'fixed', right:'12px', bottom:'12px', zIndex:'100000', padding:'8px 10px', borderRadius:'8px', border:'1px solid rgba(0,0,0,0.2)', background:'#f59e0b', color:'#071019', fontWeight:'700', cursor:'pointer', boxShadow:'0 6px 18px rgba(245,158,11,0.12)' });
      toggle.addEventListener('click', ()=>{
        if(document.body.contains(devLogEl)){ document.body.removeChild(devLogEl); toggle.textContent='DevLog'; } else { document.body.appendChild(devLogEl); toggle.textContent='Hide'; }
      });

      // ensure we don't append duplicates
      if(!document.getElementById('dev-log-toggle')) document.body.appendChild(toggle);
      if(!document.getElementById('dev-log')) document.body.appendChild(devLogEl);

      window.logDev = function(){
        try{
          // Respect runtime flag: state.storage.devLogEnabled === false disables dev logging
          const enabled = !(window.state && window.state.storage && window.state.storage.devLogEnabled === false);
          if(!enabled) return;
          const args = Array.from(arguments).map(a=> (typeof a==='object'?JSON.stringify(a):String(a)) );
          const line = document.createElement('div');
          line.textContent = args.join(' ');
          devLogEl.appendChild(line);
          devLogEl.scrollTop = devLogEl.scrollHeight;
          console.log.apply(console, arguments);
        }catch(_){ try{ console.log.apply(console, arguments); }catch(__){} }
      };
      // alias for simpler calls
      window.plog = window.logDev;
    };
    if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', initDevLog); else initDevLog();
  }catch(_){/* ignore */}

  const qs=s=>document.querySelector(s), qsa=s=>Array.from(document.querySelectorAll(s));

  // Emergency focus unlock function - make it available immediately
  window.unlockFocus = function(){
    console.log('Attempting to unlock focus...');
    
    // Hide any visible modals
    ['app-confirm-modal', 'app-preview-modal', '__scroll_debug_overlay'].forEach(id => {
      const el = document.getElementById(id);
      if (el) {
        el.style.display = 'none';
        console.log('Hidden modal:', id);
      }
    });
    
    // Remove any focus locks
    document.body.style.pointerEvents = '';
    document.body.style.userSelect = '';
    
    // Try to focus on a safe element
    try {
      const safeElement = document.querySelector('input, button, [tabindex]');
      if (safeElement) {
        safeElement.focus();
        console.log('Focused on safe element');
      }
    } catch (e) {
      console.warn('Could not focus on safe element:', e);
    }
    
    console.log('Focus unlock attempt completed');
  };

  // Emergency click diagnostics & recovery
  window.diagnoseClicks = function(){
    try{
      const report = [];
      // 1. Sprawdź globalne style blokujące interakcje
      const bodyPE = getComputedStyle(document.body).pointerEvents;
      const bodyUS = getComputedStyle(document.body).userSelect;
      if(bodyPE === 'none') report.push('[!] body ma pointer-events:none');
      if(bodyUS === 'none') report.push('[!] body ma user-select:none');

      // 2. Poszukaj dużych, potencjalnie zasłaniających elementów z pointer-events:auto
      const vw = window.innerWidth, vh = window.innerHeight;
      const blockers = [];
      document.querySelectorAll('body *').forEach(el=>{
        try{
          const st = getComputedStyle(el);
            if(st.display==='none' || st.visibility==='hidden' || st.opacity==='0') return;
            if(st.pointerEvents==='none') return;
            const r = el.getBoundingClientRect();
            if(r.width > vw*0.8 && r.height > vh*0.8 && r.top <= 0 && r.left <= 0){
              blockers.push({tag:el.tagName, cls:el.className, id:el.id, w:Math.round(r.width), h:Math.round(r.height), z:st.zIndex});
            }
        }catch(_){/* ignore */}
      });
      if(blockers.length) report.push('[!] Możliwe elementy zasłaniające: '+ blockers.map(b=>`${b.tag}#${b.id}.${b.cls} ${b.w}x${b.h} z=${b.z}`).join('; '));

      // 3. Test elementFromPoint
      const midEl = document.elementFromPoint(vw/2, vh/2);
      if(midEl) report.push('[i] elementFromPoint(środek): '+ midEl.tagName + (midEl.id?('#'+midEl.id):''));

      // 4. Szybki test czy listener działa (syntetyczny click)
      let syntheticOk = false;
      const testBtn = document.createElement('button');
      testBtn.textContent='__test_click__';
      testBtn.style.position='fixed'; testBtn.style.top='4px'; testBtn.style.left='4px'; testBtn.style.zIndex=999999; testBtn.style.opacity='0.4';
      testBtn.addEventListener('click', ()=>{ syntheticOk = true; console.log('[diagnoseClicks] Syntetyczny click dotarł do listenera.'); setTimeout(()=>testBtn.remove(), 50); });
      document.body.appendChild(testBtn);
      testBtn.click();
      setTimeout(()=>{ if(!syntheticOk){ console.warn('[diagnoseClicks] Wygląda jakby eventy click nie były obsługiwane (brak reakcji listenera).'); } }, 100);

      if(!report.length) report.push('[OK] Nie znaleziono oczywistych blokad.');
      console.log('[diagnoseClicks] Raport:', report.join('\n'));
      return report;
    }catch(e){ console.error('[diagnoseClicks] Błąd', e); return ['error:'+e.message]; }
  };

  window.recoverClicks = function(){
    try{
      console.log('[recoverClicks] Próba odblokowania zdarzeń...');
      // NAJWAŻNIEJSZE: Przywróć normalną delegację kliknięć
      window.restoreNormalClickDelegation();
      document.body.style.pointerEvents='auto';
      document.body.style.userSelect='auto';
      // Usuń ewentualne pełnoekranowe warstwy debug / modal z atrybutem data-block-ui
      document.querySelectorAll('[data-block-ui]')?.forEach(el=>{ el.remove(); });
      // Schowaj potencjalne modale
      ['app-confirm-modal','app-preview-modal','__scroll_debug_overlay'].forEach(id=>{ const el = document.getElementById(id); if(el){ el.style.display='none'; } });
      // Wyczyść style inline blokujące pointer events dla .hidden (czasem nadpisane przez błędny CSS)
      document.querySelectorAll('.hidden').forEach(el=>{ el.style.pointerEvents='none'; });
      // Dodaj delikatny znacznik powodzenia
      const tag = document.createElement('div');
      tag.textContent='[clicks recovered]';
      Object.assign(tag.style,{position:'fixed',bottom:'4px',right:'6px',background:'#059669',color:'#fff',padding:'4px 8px',borderRadius:'6px',fontSize:'11px',zIndex:999999});
      document.body.appendChild(tag); setTimeout(()=>tag.remove(), 2500);
      console.log('[recoverClicks] Zakończono');
    }catch(e){ console.error('[recoverClicks] Błąd', e); }
  };

  // Skrót klawiszowy: Ctrl+Alt+K -> diagnoza, Ctrl+Alt+R -> próba naprawy
  window.addEventListener('keydown', (ev)=>{
    if(ev.ctrlKey && ev.altKey && ev.key.toLowerCase()==='k'){ diagnoseClicks(); }
    if(ev.ctrlKey && ev.altKey && ev.key.toLowerCase()==='r'){ recoverClicks(); }
  });

  // Validation functions
  function validateOrderForm() {
    const errors = [];
    const name = qs('#o-name').value.trim();
    const qty = parseInt(qs('#o-qty').value) || 0;
    const startDate = qs('#o-start').value;
    const endDate = qs('#o-end').value;

    if (!name) errors.push('Nazwa zamówienia jest wymagana');
    if (name.length < 3) errors.push('Nazwa zamówienia musi mieć co najmniej 3 znaki');
    if (qty <= 0) errors.push('Ilość musi być większa od 0');
    if (qty > 1000) errors.push('Ilość nie może przekraczać 1000');

    if (startDate && endDate) {
      const start = new Date(startDate);
      const end = new Date(endDate);
      if (start > end) errors.push('Data rozpoczęcia nie może być późniejsza niż data zakończenia');
    }

    // Check for duplicate names (optional)
    const existingOrder = state.orders.find(o => o.name.toLowerCase() === name.toLowerCase() && o.id !== qs('#o-id').value);
    if (existingOrder) errors.push('Zamówienie o tej nazwie już istnieje');

    return errors;
  }

  function validateEmployeeForm() {
    const errors = [];
    const name = qs('#emp-name').value.trim();
    const capacity = parseInt(qs('#emp-cap').value) || 0;
    const hoursPerDay = parseInt(qs('#emp-hours').value) || 0;

    if (!name) errors.push('Imię i nazwisko pracownika jest wymagane');
    if (name.length < 2) errors.push('Imię i nazwisko musi mieć co najmniej 2 znaki');
    if (capacity <= 0 || capacity > 100) errors.push('Wydajność musi być między 1 a 100');
    if (hoursPerDay <= 0 || hoursPerDay > 24) errors.push('Godziny pracy dziennie muszą być między 1 a 24');

    // Check for duplicate names
    const existingEmp = state.employees.find(e => e.name.toLowerCase() === name.toLowerCase() && e.id !== qs('#emp-id').value);
    if (existingEmp) errors.push('Pracownik o tym imieniu i nazwisku już istnieje');

    return errors;
  }

  function showValidationErrors(errors) {
    // Remove existing error messages
    const existingErrors = document.querySelectorAll('.validation-error');
    existingErrors.forEach(el => el.remove());

    if (errors.length === 0) return;

    // Create error message container
    const errorDiv = document.createElement('div');
    errorDiv.className = 'validation-error card error';
    errorDiv.innerHTML = '<h4>Błędy walidacji:</h4><ul>' + errors.map(err => `<li>${err}</li>`).join('') + '</ul>';

    // Insert at the top of the current panel
    const currentPanel = document.querySelector('.card:not(.hidden)');
    if (currentPanel) {
      currentPanel.insertBefore(errorDiv, currentPanel.firstChild);
    }

    // Auto-hide after 5 seconds
    setTimeout(() => {
      if (errorDiv.parentNode) {
        errorDiv.remove();
      }
    }, 5000);
  }

  // Global search functions
  function performGlobalSearch(query) {
    if (!query || query.trim().length < 2) {
      hideSearchResults();
      return;
    }

    const results = [];
    const searchTerm = query.toLowerCase().trim();

    // Search orders
    (state.orders || []).forEach(order => {
      if (order.name && order.name.toLowerCase().includes(searchTerm)) {
        results.push({
          type: 'order',
          id: order.id,
          title: order.name,
          details: `Klient: ${order.client || 'Brak'} • Ilość: ${order.quantity || 0}`,
          navTarget: 'order'
        });
      }
      if (order.client && order.client.toLowerCase().includes(searchTerm)) {
        results.push({
          type: 'order',
          id: order.id,
          title: `Zamówienie: ${order.name}`,
          details: `Klient: ${order.client} • Ilość: ${order.quantity || 0}`,
          navTarget: 'order'
        });
      }
    });

    // Search employees
    (state.employees || []).forEach(emp => {
      if (emp.name && emp.name.toLowerCase().includes(searchTerm)) {
        results.push({
          type: 'employee',
          id: emp.id,
          title: emp.name,
          details: `Wydajność: ${emp.cap || 100}% • Godziny: ${emp.hoursPerDay || 8}/dzień`,
          navTarget: 'emp'
        });
      }
    });

    // Search tasks
    (state.tasks || []).forEach(task => {
      if (task.opName && task.opName.toLowerCase().includes(searchTerm)) {
        const orderName = task.orderId ? (state.orders.find(o => o.id === task.orderId)?.name || task.orderId) : 'Brak zamówienia';
        results.push({
          type: 'task',
          id: task.id,
          title: task.opName,
          details: `Zamówienie: ${orderName} • Status: ${task.status || 'todo'}`,
          navTarget: 'tasks'
        });
      }
    });

    // Search processes
    (state.processes || []).forEach(proc => {
      if (proc.name && proc.name.toLowerCase().includes(searchTerm)) {
        results.push({
          type: 'process',
          id: proc.id,
          title: proc.name,
          details: `Operacji: ${(proc.operations || []).length}`,
          navTarget: 'proc'
        });
      }
    });

    // Search operations catalog
    (state.operationsCatalog || []).forEach(op => {
      if (op.name && op.name.toLowerCase().includes(searchTerm)) {
        results.push({
          type: 'operation',
          id: op.id,
          title: op.name,
          details: `Czas: ${op.time || 0}min • Nr: ${op.no || 0}`,
          navTarget: 'opcat'
        });
      }
    });

    displaySearchResults(results.slice(0, 20)); // Limit to 20 results
  }

  function displaySearchResults(results) {
    const container = qs('#search-results');
    if (!container) return;

    if (results.length === 0) {
      container.innerHTML = '<div class="search-no-results">Brak wyników wyszukiwania</div>';
      container.style.display = 'block';
      return;
    }

    const typeLabels = {
      order: 'Zamówienie',
      employee: 'Pracownik',
      task: 'Zadanie',
      process: 'Proces',
      operation: 'Operacja'
    };

    container.innerHTML = results.map(result => `
      <div class="search-result-item" data-type="${result.type}" data-id="${result.id}" data-nav="${result.navTarget}">
        <div class="search-result-category">${typeLabels[result.type] || result.type}</div>
        <div class="search-result-title">${result.title}</div>
        <div class="search-result-details">${result.details}</div>
      </div>
    `).join('');

    container.style.display = 'block';
  }

  function hideSearchResults() {
    const container = qs('#search-results');
    if (container) {
      container.style.display = 'none';
    }
  }

  const storeKey='door_v50_state';

  let state={storage:{mode:'firebase',appId:'doors-demo',userId:'hala-1',fbConfig:{
    "apiKey": "AIzaSyD93UqqsHWoAUBV7g8OVKAnajIfGDX_ZdY",
    "authDomain": "doors-planner.firebaseapp.com",
    "projectId": "doors-planner",
    "storageBucket": "doors-planner.appspot.com",
    "messagingSenderId": "513098608067",
    "appId": "1:513098608067:web:1fe3855b3470ca7ef22176"
  }},
    employees:[],operationsCatalog:[],processes:[],orders:[],tasks:[],after:[],PROC_TMP:[],page:'dash',_timers:{}};
  state.uiShowTasksByEmpTable = false;
  // migracja istniejących tasków (dodanie nowych pól jeśli brak)
  try{ if(window.scheduleCore){ window.scheduleCore.migrateTasks(state); } }catch(e){ console.warn('migrateTasks warn', e.message); }
  // migracja orderów - pole tasksGenerated
  try{ (state.orders||[]).forEach(o=>{ if(typeof o.tasksGenerated==='undefined') o.tasksGenerated=false; }); }catch(e){ console.warn('migrateOrders warn', e.message); }
  
  // Funkcja do sprawdzania i ładowania stanu
  function checkAndLoadState(){
    console.log('Sprawdzam stan aplikacji...');
    
    // Sprawdź czy stan istnieje
    if(!window.state){
      console.error('Stan aplikacji nie istnieje!');
      alert('Błąd: Stan aplikacji nie został załadowony!');
      return false;
    }
    
    // Sprawdź kluczowe właściwości stanu
    const requiredProps = ['storage', 'employees', 'operationsCatalog', 'processes', 'orders', 'tasks'];
    const missing = requiredProps.filter(prop => !state.hasOwnProperty(prop));
    if(missing.length > 0){
      console.error('Brakujące właściwości stanu:', missing);
      alert('Błąd stanu aplikacji! Brakujące właściwości: ' + missing.join(', '));
      return false;
    }
    
    // Sprawdź tryb storage
    console.log('Aktualny tryb storage:', state.storage.mode);
    console.log('Czy localhost:', window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1');
    
    console.log('Stan aplikacji załadowany poprawnie');
    return true;
  }
  
  // Sprawdź czy aplikacja została poprawnie załadowana
  window.addEventListener('load', function(){
    console.log('Aplikacja załadowana, sprawdzam stan...');
    
    // Sprawdź czy aplikacja jest otwierana z właściwego protokołu
    if(window.location.protocol === 'file:'){
      console.warn('⚠️ Aplikacja otwarta z file:// - niektóre funkcje mogą nie działać');
      // NIE przerywamy - użytkownik zgłosił że file:// DZIAŁA POPRAWNIE
      // alert('⚠️ UWAGA: Aplikacja została otwarta z pliku lokalnego (file://).\n\nDla prawidłowego działania otwórz ją przez serwer HTTP:\nhttp://localhost:5500\n\nW VS Code użyj "Open with Live Server" lub uruchom:\npython -m http.server 5500');
      // return;  // USUNIĘTE - to blokowało działanie aplikacji
    }
    
    // Sprawdź stan aplikacji
    if(!checkAndLoadState()){
      console.error('Stan aplikacji nieprawidłowy - odświeżam stronę');
      setTimeout(() => forceRefresh(), 1000);
      return;
    }
    
    // Sprawdź czy localStorage działa
    try {
      localStorage.setItem('test', 'test');
      localStorage.removeItem('test');
      console.log('localStorage działa poprawnie');
    } catch(e) {
      console.error('localStorage nie działa:', e);
      alert('localStorage nie działa! Aplikacja może nie działać poprawnie.');
    }
    
    // Sprawdź czy wszystkie funkcje są dostępne
    const requiredFunctions = ['qs', 'save', 'renderDash', 'updateConnectionStatus'];
    const missing = requiredFunctions.filter(fn => typeof window[fn] !== 'function');
    if(missing.length > 0){
      console.error('Brakujące funkcje:', missing);
      alert('Błąd ładowania aplikacji! Brakujące funkcje: ' + missing.join(', '));
    } else {
      console.log('Wszystkie funkcje załadowane poprawnie');
    }
    
    // Wymuś aktualizację statusu
    if(typeof updateConnectionStatus === 'function'){
      updateConnectionStatus();
    }

    // Inicjalizacja przełącznika wysokiego kontrastu ostrzeżeń
    try{
      const toggle = document.getElementById('toggle-high-contrast');
      const callout = document.getElementById('startup-warning');
      if(toggle && callout){
        // wczytaj poprzednią preferencję
        const prefRaw = localStorage.getItem('highContrastWarnings');
        const pref = prefRaw === '1';
        toggle.checked = pref;
        if(pref){ callout.classList.add('high-contrast'); }
        toggle.addEventListener('change', ()=>{
          if(toggle.checked){ callout.classList.add('high-contrast'); localStorage.setItem('highContrastWarnings','1'); }
          else { callout.classList.remove('high-contrast'); localStorage.setItem('highContrastWarnings','0'); }
        });
      }
    }catch(e){ console.warn('HC toggle init error', e && e.message); }
    
    // Wymuś renderowanie dashboard
    if(typeof renderDash === 'function'){
  renderDash(); renderGantt();
  if(typeof initOffdaysQuickButtons==='function') initOffdaysQuickButtons();
    }
  });
  
  // === UWAGA: Seedowanie operacji i procesów przeniesione PO wczytaniu localStorage ===
  // (Zobacz linie ~1540-1600)
  
  // ensure all requested operations exist (no duplicates by lowercased name)
  const ensureOp = (name, time=10, skills=[])=>{
    if(!name) return;
    const exists = (state.operationsCatalog||[]).some(o=> (o.name||'').toLowerCase() === name.toLowerCase());
    if(!exists){ state.operationsCatalog.push({id:uid(), no:(state.operationsCatalog||[]).length+1, name, time, workers:1, skills, defaultAssignees:[]}); }
  };
  // operations from user list
  [
    'Wycięcie belek pod futrynę', 'Frezowanie na CNC 40 m', 'Sklejanie belek', 'Kontrola wymiarów', 'Szlifowanie', 'Szczotkowanie', 'Malowanie', 'Okuwanie',
    'Wycięcie belek pod skrzydło', 'Sklejenie belek', 'Wycięcie sklejki', 'Przygotowanie forniru zgodnie z zamówieniem', 'Fornirowanie', 'Przygotowanie rurek pod elektronikę', 'Montaż rurek pod elektronikę',
    'Przycięcie poprzeczek', 'Montaż poprzeczek', 'Przycięcie styropianu', 'Montaż styropianu', 'Przycięcie naciągu', 'Montaż naciągu', 'Sklejanie w prasie', 'Frezowanie na CNC',
    'Przygotowanie zestawu do drzwi', 'Przygotowanie antaby', 'Zamówienie szyb', 'Malowanie szyb', 'Klejenie szyb', 'Polerowanie zamków i wypalenie logo', 'Wymiary szyby (szer, H)'
  ].forEach(n=>ensureOp(n, 10, []));
  // --- STORAGE HELPERS (zdefiniowane przed pierwszym użyciem) ---
  let autoSaveTimeout;
  function autoSaveDebounced(){
    clearTimeout(autoSaveTimeout);
    autoSaveTimeout = setTimeout(()=>{ try{ saveToDB(); }catch(e){ /* ignore at startup */ } }, 500);
  }
  function safeStringifyState(data){
    const seen = new WeakSet();
    return JSON.stringify(data, (key, value) => {
      if (typeof value === 'function') {
        return undefined;
      }
      if (typeof Node !== 'undefined' && value instanceof Node) {
        return undefined;
      }
      if (typeof value === 'object' && value !== null) {
        if (value === window) {
          return undefined;
        }
        if (seen.has(value)) {
          return undefined;
        }
        seen.add(value);
      }
      if (typeof value === 'number' && !Number.isFinite(value)) {
        return null;
      }
      return value;
    });
  }

  function save(){
    try{ 
      console.log('💾 SAVE: Zapisuję dane...', {
        employees: state.employees?.length || 0,
        operations: state.operationsCatalog?.length || 0,
        processes: state.processes?.length || 0,
        orders: state.orders?.length || 0,
        tasks: state.tasks?.length || 0
      });
      const dataToSave = safeStringifyState(state);
      console.log('💾 SAVE: Klucz:', storeKey, '| Wielkość:', dataToSave.length, 'znaków');
      localStorage.setItem(storeKey, dataToSave); 
      
      // Weryfikacja zapisu
      const saved = localStorage.getItem(storeKey);
      if (saved) {
        try {
          const savedData = JSON.parse(saved);
          console.log('✅ SAVE: Dane zapisane i zweryfikowane! Zleceń w localStorage:', savedData.orders?.length || 0);
        } catch(verifyErr) {
          console.warn('⚠️ SAVE: Nie udało się zweryfikować danych po zapisie:', verifyErr);
        }
      } else {
        console.error('❌ SAVE: Dane NIE zostały zapisane do localStorage!');
      }

      if (window.store && typeof window.store.set === 'function') {
        try {
          window.store.set(state);
        } catch(storeErr) {
          console.warn('⚠️ SAVE: synchronizacja store.set nie powiodła się:', storeErr);
        }
      }

      if (typeof window.state === 'undefined' || window.state !== state) {
        window.state = state;
      }
    }catch(e){ 
      console.error('❌ SAVE: Błąd zapisu:', e);
    }
    autoSaveDebounced();
  }
  try{ window.save = save; }catch(_){ }

  // === NARZĘDZIE DO SYNCHRONIZACJI DANYCH MIĘDZY PORTAMI ===
  window.exportDataToFile = function() {
    try {
      const dataStr = localStorage.getItem(storeKey);
      if (!dataStr) {
        alert('❌ Brak danych do eksportu!');
        return;
      }
      
      const data = JSON.parse(dataStr);
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `planner-backup-${new Date().toISOString().slice(0,10)}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      console.log('✅ Dane wyeksportowane do pliku');
      alert('✅ Dane wyeksportowane!\n\nPobrano plik: ' + a.download);
    } catch(e) {
      console.error('❌ Błąd eksportu:', e);
      alert('❌ Błąd eksportu danych: ' + e.message);
    }
  };
  
  window.importDataFromFile = function() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    input.onchange = function(e) {
      const file = e.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = function(ev) {
        try {
          const importedData = JSON.parse(ev.target.result);
          
          // Sprawdź czy to są poprawne dane
          if (!importedData.orders || !importedData.employees) {
            alert('❌ Nieprawidłowy format danych!');
            return;
          }
          
          const currentData = localStorage.getItem(storeKey);
          const currentState = currentData ? JSON.parse(currentData) : null;
          
          const msg = `📊 IMPORT DANYCH\n\n` +
            `Aktualny stan:\n` +
            `  • Zlecenia: ${currentState?.orders?.length || 0}\n` +
            `  • Pracownicy: ${currentState?.employees?.length || 0}\n` +
            `  • Procesy: ${currentState?.processes?.length || 0}\n\n` +
            `Importowane dane:\n` +
            `  • Zlecenia: ${importedData.orders?.length || 0}\n` +
            `  • Pracownicy: ${importedData.employees?.length || 0}\n` +
            `  • Procesy: ${importedData.processes?.length || 0}\n\n` +
            `⚠️ UWAGA: To NADPISZE wszystkie aktualne dane!\n\n` +
            `Czy na pewno chcesz kontynuować?`;
          
          if (!confirm(msg)) {
            console.log('Import anulowany');
            return;
          }
          
          // Zapisz dane
          localStorage.setItem(storeKey, JSON.stringify(importedData));
          Object.assign(state, importedData);
          window.state = state;
          
          console.log('✅ Dane zaimportowane pomyślnie');
          alert('✅ Dane zaimportowane!\n\nOdświeżam stronę...');
          
          setTimeout(() => window.location.reload(), 500);
        } catch(e) {
          console.error('❌ Błąd importu:', e);
          alert('❌ Błąd importu danych: ' + e.message);
        }
      };
      reader.readAsText(file);
    };
    input.click();
  };
  
  window.showPortInfo = function() {
    const info = `📊 INFORMACJE O APLIKACJI\n\n` +
      `Port/URL: ${window.location.origin}\n` +
      `Klucz localStorage: ${storeKey}\n\n` +
      `Załadowane dane:\n` +
      `  • Zlecenia: ${state.orders?.length || 0}\n` +
      `  • Pracownicy: ${state.employees?.length || 0}\n` +
      `  • Procesy: ${state.processes?.length || 0}\n` +
      `  • Operacje: ${state.operationsCatalog?.length || 0}\n` +
      `  • Zadania: ${state.tasks?.length || 0}\n\n` +
      `💡 WAŻNE:\n` +
      `Każdy port (5500, 8000) ma OSOBNĄ bazę danych!\n\n` +
      `Aby przenieść dane między portami:\n` +
      `1. Wywołaj: exportDataToFile()\n` +
      `2. Otwórz aplikację na drugim porcie\n` +
      `3. Wywołaj: importDataFromFile()\n\n` +
      `Dostępne komendy:\n` +
      `  • exportDataToFile() - eksport do pliku\n` +
      `  • importDataFromFile() - import z pliku\n` +
      `  • showPortInfo() - pokaż te informacje`;
    
    console.log(info);
    alert(info);
  };

  // Najpierw spróbuj wczytać poprzedni stan (jeśli istnieje) ZANIM wymusimy zapis seedów
  try{
    const raw=localStorage.getItem(storeKey); 
    console.log('🔍 LOAD: Sprawdzam localStorage (klucz: ' + storeKey + ')...');
    if(raw) {
      const loadedData = JSON.parse(raw);
      console.log('📦 LOAD: Dane z localStorage (długość):', raw.length, 'znaków');
      Object.assign(state, loadedData);
      console.log('✅ LOAD: Dane załadowane z localStorage:', {
        employees: state.employees?.length || 0,
        operations: state.operationsCatalog?.length || 0,
        processes: state.processes?.length || 0,
        orders: state.orders?.length || 0,
        tasks: state.tasks?.length || 0
      });
    } else {
      console.log('⚠️ LOAD: Brak danych w localStorage (klucz: ' + storeKey + '), używam domyślne');
    }
  }catch(e){ 
    console.error('❌ LOAD: Błąd ładowania danych:', e);
  }
  
  // === SEEDOWANIE DANYCH (PO WCZYTANIU localStorage) ===
  // Jeśli po wczytaniu localStorage nadal brak procesów/operacji, generuj domyślne dane
  
  // Seed operationsCatalog if empty
  if(!(state.operationsCatalog && state.operationsCatalog.length)){
    console.log('🌱 SEED: Tworzę domyślne operacje...');
    state.operationsCatalog = [];
    let i = 1;
    const addOp = (name, time=10, skills=[])=>{ state.operationsCatalog.push({id: uid(), no: i++, name, time, workers:1, skills, defaultAssignees:[]}); };
    // FUTRYNA
    addOp('Frezowanie na CNC (belki futryny)', 40, ['CNC','belki']);
    addOp('Sklejanie belek (futryna)', 20, ['sklejanie','belki']);
    addOp('Kontrola wymiarów (futryna)', 10, ['kontrola']);
    addOp('Szlifowanie (futryna)', 15, ['szlifowanie']);
    addOp('Szczotkowanie (futryna)', 12, ['szczotkowanie']);
    addOp('Malowanie (futryna)', 30, ['malowanie']);
    addOp('Okuwanie (futryna)', 8, ['okucia']);
    // SKRZYDŁO
    addOp('Wycięcie belek pod skrzydło', 35, ['CNC','belki']);
    addOp('Sklejenie belek (skrzydło)', 20, ['sklejanie','belki']);
    addOp('Wycięcie sklejki', 25, ['sklejka']);
    addOp('Przygotowanie forniru', 18, ['fornir']);
    addOp('Fornirowanie', 30, ['fornirowanie']);
    addOp('Przygotowanie rurek pod elektronikę', 12, ['elektronika']);
    addOp('Montaż rurek pod elektronikę', 18, ['elektronika']);
    addOp('Przycięcie poprzeczek', 10, ['poprzeczki']);
    addOp('Montaż poprzeczek', 12, ['poprzeczki']);
    addOp('Przycięcie styropianu', 5, ['styropian']);
    addOp('Montaż styropianu', 8, ['styropian']);
    addOp('Przycięcie naciągu', 6, ['naciag']);
    addOp('Montaż naciągu', 8, ['naciag']);
    addOp('Sklejanie w prasie', 25, ['prasa']);
    addOp('Frezowanie na CNC (skrzydło)', 40, ['CNC']);
    addOp('Szlifowanie (skrzydło)', 15, ['szlifowanie']);
    addOp('Szczotkowanie (skrzydło)', 12, ['szczotkowanie']);
    addOp('Malowanie (skrzydło)', 30, ['malowanie']);
    addOp('Okuwanie (skrzydło)', 8, ['okucia']);
    // DODATKOWE
    addOp('Przygotowanie zestawu do drzwi', 10, ['zestaw']);
    addOp('Przygotowanie antaby', 8, ['antaba']);
    addOp('Zamówienie szyb', 5, ['szyby']);
    addOp('Malowanie szyb', 15, ['szyby','malowanie']);
    addOp('Klejenie szyb', 20, ['szyby','klejenie']);
    addOp('Polerowanie zamków i wypalenie logo', 12, ['zamki','polerowanie']);
    addOp('Wymiary szyby (szer, H)', 4, ['szyby','wymiary']);
    console.log('✅ SEED: Utworzono', state.operationsCatalog.length, 'operacji');
  }
  
  // Seed processes if empty (MUSI BYĆ PO operationsCatalog!)
  if(!(state.processes && state.processes.length)){
    console.log('🌱 SEED: Tworzę domyślne procesy...');
    const procAdd = (name, opNames)=>{
      const ops = (opNames||[]).map(n=>{ const o = state.operationsCatalog.find(x=>x.name===n); return o?{name:o.name,time:o.time||0}:{name:n,time:0}; });
      state.processes.push({id:uid(), name, operations: ops});
    };
    procAdd('Proces: Futryna', ['Frezowanie na CNC (belki futryny)','Sklejanie belek (futryna)','Kontrola wymiarów (futryna)','Szlifowanie (futryna)','Szczotkowanie (futryna)','Malowanie (futryna)','Okuwanie (futryna)']);
    procAdd('Proces: Skrzydło', ['Wycięcie belek pod skrzydło','Sklejenie belek (skrzydło)','Wycięcie sklejki','Fornirowanie','Frezowanie na CNC (skrzydło)','Szlifowanie (skrzydło)','Malowanie (skrzydło)','Okuwanie (skrzydło)']);
    procAdd('Proces: Drzwi kompletne', ['Frezowanie na CNC (belki futryny)','Sklejanie belek (futryna)','Wycięcie belek pod skrzydło','Sklejenie belek (skrzydło)','Sklejanie w prasie','Fornirowanie','Malowanie (skrzydło)','Okuwanie (skrzydło)']);
    console.log('✅ SEED: Utworzono', state.processes.length, 'procesów');
  }
  
  // Jeśli wygenerowaliśmy seedy, zapisz je do localStorage
  if((state.processes && state.processes.length) || (state.operationsCatalog && state.operationsCatalog.length)){
    try{ save(); console.log('💾 SEED: Zapisano seedy do localStorage'); }catch(e){ console.warn('seed save error', e && e.message); }
  }
  
  // seed employees if empty
  if(!(state.employees && state.employees.length)){
    state.employees.push({id: 'emp-1', name: 'Jan Kowalski', hoursPerDay: 8, cap: 100, skills: ['montaż'], isProductionWorker: false});
    state.employees.push({id: 'emp-2', name: 'Anna Nowak', hoursPerDay: 8, cap: 100, skills: ['produkcja'], isProductionWorker: true});
    state.employees.push({id: 'emp-3', name: 'Piotr Wiśniewski', hoursPerDay: 8, cap: 100, skills: ['montaż'], isProductionWorker: false});
    state.employees.push({id: 'emp-4', name: 'Maria Zielińska', hoursPerDay: 8, cap: 100, skills: ['produkcja'], isProductionWorker: true});
  }
  // ensure stored autosave preference exists
  state.storage.autoSaveAssign = state.storage.autoSaveAssign === undefined ? true : !!state.storage.autoSaveAssign;
  // ensure stored spellcheck enforce preference exists (default: true)
  state.storage.spellcheckEnforce = state.storage.spellcheckEnforce === undefined ? true : !!state.storage.spellcheckEnforce;
  // (przeniesione wyżej – odczyt localStorage przed seedingiem)
  // ensure settings object exists and default autoCleanup = true
  state.settings = state.settings || {};
  if (typeof state.settings.autoCleanup === 'undefined') state.settings.autoCleanup = true;
  // expose state for debugging and console access
  try{ window.state = state; }catch(e){console.warn('unable to expose state', e);}

  // DEFINICJA FUNKCJI PRZED JEJ WYWOLANIEM
  window.restoreNormalClickDelegation = function(){
    window.disableGlobalClickDelegation = false;
    console.log('[rescue] Normal click delegation RESTORED');
    // Zapobiegaj ponownemu włączeniu - nadpisz funkcję awaryjną
    window.enableNoDelegateMode = function(){
      console.warn('[rescue] No-delegation mode BLOCKED - normal delegation required');
      return false;
    };
  };

  // NATYCHMIAST przywróć normalną delegację kliknięć - NAJWYŻSZY PRIORYTET
  window.restoreNormalClickDelegation();
  console.log('INIT: Normalna delegacja kliknięć przywrócona na starcie');

  // AWARYJNE: Sprawdzaj i przywracaj delegację co 5 sekund
  setInterval(() => {
    if (window.disableGlobalClickDelegation) {
      window.restoreNormalClickDelegation();
      console.log('AUTO-RESTORE: Delegacja kliknięć przywrócona automatycznie');
    }
  }, 5000);

  // (stara definicja save/autoSaveDebounced usunięta – przeniesiona wyżej)

  // call this to trigger optional immediate Firebase save when enabled in settings
  function maybeAutoSave(reason){
    try{
      const enabled = !!state.storage.autoSaveAssign;
      if(enabled){ saveToDB(); setInfoText('Auto-save: ' + (reason||'sync'), 'default'); }
    }catch(e){ console.warn('maybeAutoSave error', e); }
  }
  
  function nav(p){
    // AWARYJNE: Przy każdej nawigacji przywracaj normalną delegację kliknięć
    if (window.disableGlobalClickDelegation) {
      window.restoreNormalClickDelegation();
      console.log('[nav] Emergency delegation restore for page:', p);
    }
    const map={dash:'p-dash',tasks:'p-tasks',order:'p-order',proc:'p-proc',opcat:'p-opcat',emp:'p-emp',as:'p-as',
               map:'p-map',monitor:'p-monitor',mrp:'p-mrp',wh:'p-wh',sync:'p-sync',backup:'p-backup',migr:'p-migr',settings:'p-settings',gantt:'p-gantt',capacity:'p-capacity',reports:'p-reports'};
    qsa('[id^="p-"]').forEach(el=>el.classList.add('hidden'));
    qs('#'+(map[p]||'p-dash')).classList.remove('hidden');
    state.page=p; save();
    if(p==='order') renderOrderPage(window.state||state);
    if(p==='tasks') renderTasks();
    if(p==='opcat') renderOps();
    if(p==='proc') renderProcPage();
    if(p==='emp') renderEmployees(window.state||state);
    if(p==='as') renderASPage();
    if(p==='mrp') renderMRPPage();
    if(p==='gantt') renderGantt();
    if(p==='capacity') renderCapacityAnalysis();
    if(p==='reports') renderReports();
    if(p==='monitor') try{ renderMonitor(); }catch(_){ /* no-op if monitor renderer missing */ }
    if(p==='wh') {
      try { 
        // Przywracamy normalną delegację kliknięć przy wejściu do magazynu
        window.restoreNormalClickDelegation();
        initWarehouse(); 
      } catch(e){ console.warn('[warehouse] init error', e); }
    }
  renderDash(window.state||state); renderGantt();
  }
  window.nav=nav;

  const handleEvents = async (e) => {
    console.log('handleEvents called', e.target);
    let t = e.target;
    // AWARYJNE: Ignoruj flagę disableGlobalClickDelegation dla przycisków nawigacji i podstawowych kontrolek
    const isNavigationButton = t.closest && (t.closest('[data-nav]') || t.closest('button') && t.closest('header'));
    const isBasicControl = t.closest && (t.closest('#restore-click-delegation') || t.closest('#set-save') || t.closest('#set-load'));
    if (window.disableGlobalClickDelegation && !isNavigationButton && !isBasicControl) {
      return;
    }
    while(t && t !== document.body) {
      if(e.type === 'click') {
        // Jeśli element ma atrybut data-no-global, przerywamy delegację (pozwalamy lokalnym listenerom działać bez wpływu globalnego handlera)
        if(t.hasAttribute && t.hasAttribute('data-no-global')) break;
        if(t.dataset.nav) { nav(t.dataset.nav); break; }
        if(t.dataset.od) {
          const id = t.dataset.od; 
          console.log('🗑️ USUŃ ZLECENIE:', id);
          console.log('📊 Zleceń przed usunięciem:', state.orders.length);
          state.orders = state.orders.filter(x => x.id !== id); 
          state.tasks = state.tasks.filter(t => t.orderId !== id); 
          state.after = state.after.filter(a => a.order !== id); 
          console.log('📊 Zleceń po usunięciu:', state.orders.length);
          save();
          console.log('💾 Zapisano po usunięciu');
          renderOrderPage(); renderASPage(); renderDash(window.state||state); renderGantt(); break;
        }
        if(t.dataset.oed) {
          const id = t.dataset.oed;
          const o = state.orders.find(x => x.id === id);
          if (!o) return;
          qs('#o-id').value = o.id || '';
          qs('#o-name').value = o.name || '';
          qs('#o-client').value = o.client || '';
          qs('#o-model').value = o.model || '';
          qs('#o-qty').value = o.quantity || 1;
          qs('#o-start').value = o.startDate || '';
          qs('#o-end').value = o.endDate || '';
          qs('#o-notes').value = o.notes || '';
          qs('#o-install').value = o.installDate || '';
          qs('#o-addr').value = o.address || '';
          qs('#o-post').value = o.postalCode || '';
          qs('#o-phone').value = o.phone || '';
          qs('#o-proc').value = o.processId || '';
          qs('#o-lead').value = o.leadEmployeeId || '';
          window.scrollTo({top: 0, behavior: 'smooth'});
          break;
        }
        if(t.dataset.checklist) {
          const orderId = t.dataset.checklist;
          showMaterialChecklist(orderId);
          break;
        }
        if(t.dataset.ogen) {
          const id = t.dataset.ogen; const o = state.orders.find(x => x.id === id); if (!o) return;
          qs('#o-id').value = o.id || '';
          qs('#o-name').value = o.name || '';
          qs('#o-client').value = o.client || '';
          qs('#o-model').value = o.model || '';
          qs('#o-qty').value = o.quantity || 1;
          qs('#o-start').value = o.startDate || '';
          qs('#o-end').value = o.endDate || '';
          qs('#o-notes').value = o.notes || '';
          qs('#o-install').value = o.installDate || '';
          qs('#o-addr').value = o.address || '';
          if(qs('#o-post')) qs('#o-post').value = o.postalCode || o.post || '';
          qs('#o-post').value = o.postalCode || '';
          qs('#o-phone').value = o.phone || '';
          qs('#o-name').value = o.name || o.number || o.orderNumber || '';
          qs('#o-proc').value = o.processId || '';
          // Sprawdź czy zlecenie ma przypisany proces
          if (!o.processId) {
            alert('To zlecenie nie ma przypisanego procesu. Najpierw wybierz proces w edycji zlecenia.');
            break;
          }
          
          // Znajdź przypisany proces
          let p = state.processes.find(x => x.id === o.processId);
          if (!p) {
            alert('Nie znaleziono przypisanego procesu (ID: ' + o.processId + '). Wybierz inny proces.');
            break;
          }
          
          // Sprawdź czy proces ma operacje
          if (!p.operations || !p.operations.length) {
            alert('Wybrany proces nie zawiera żadnych operacji. Wybierz inny proces lub dodaj operacje do obecnego.');
            break;
          }
          
          // Sprawdź czy zamówienie już ma zadania
          const existingOrderTasks = (state.tasks || []).filter(t => t.orderId === o.id);
          if (existingOrderTasks.length > 0) {
            alert('To zamówienie już ma wygenerowane zadania. Jeśli chcesz wygenerować ponownie, najpierw usuń istniejące zadania.');
            break;
          }
          
          console.log('Przed generowaniem zadań:', {
            currentTasks: state.tasks ? state.tasks.length : 0,
            currentOrderId: o.id
          });
          
          // Zachowaj istniejące zadania niezwiązane z tym zleceniem
          const existingTasks = Array.isArray(state.tasks) ? state.tasks : [];
          const otherTasks = existingTasks.filter(t => t.orderId !== o.id);
          const newTasks = [];
          
          console.log('Generowanie zadań z procesu:', {
            processId: p.id,
            processName: p.name,
            operations: p.operations.length
          });
          
          // Dodaj nowe zadania z procesu wybranego dla zlecenia
          (p.operations || []).forEach(op => {
            // Znajdź definicję operacji w katalogu
            const catalogOp = (state.operationsCatalog || []).find(co => co.name === op.name);
            
            // Użyj przypisań z procesu, a jeśli brak to z katalogu operacji
            const assignees = op.assignee ? [op.assignee] : 
                            (catalogOp && catalogOp.defaultAssignees ? catalogOp.defaultAssignees : []);
            newTasks.push({
              id: uid(), 
              orderId: o.id,
              processId: p.id, // Dodajemy ID procesu
              opName: op.name,
              status: 'todo',
              elapsedMin: 0,
              estMin: op.time || 0,
              assignees: assignees,
              processName: p.name, // Dodajemy nazwę procesu
              opIndex: p.operations.indexOf(op) // Dodajemy indeks operacji w procesie
            });
          });
          
          // Połącz istniejące zadania z nowymi
          state.tasks = [...otherTasks, ...newTasks];
          
          console.log('Po dodaniu nowych zadań:', {
            newTasks: newTasks.length,
            finalTasks: state.tasks.length,
            sample: state.tasks.slice(0, 3)
          });
          
          // Upewnij się że state.tasks jest tablicą
          if (!Array.isArray(state.tasks)) {
            console.error('state.tasks nie jest tablicą!', state.tasks);
            state.tasks = [];
          }
          
          save(); try{ updateOrderProgress(o.id); }catch(_){ } nav('tasks'); break;
        }
        if(t.dataset.opEd) {
          const id = t.dataset.opEd; const o = (state.operationsCatalog || []).find(x => x.id === id); if (!o) return;
          qs('#op-id').value = o.id || ''; qs('#op-no').value = o.no || 1; qs('#op-name').value = o.name || '';
          qs('#op-time').value = o.time || 10; qs('#op-workers').value = o.workers || 1;
          qs('#op-skills').value = (o.skills || []).join(';'); populateOpEmployees();
          const sel = qs('#op-emp'); const set = new Set((o.defaultAssignees || []).map(a => a.id));
          Array.from(sel.options || []).forEach(opt => opt.selected = set.has(opt.value)); qs('#op-msg').textContent = ''; break;
        }
        if(t.dataset.opDel) {
          const id = t.dataset.opDel; if (!confirm('Usunąć operację?')) return;
          state.operationsCatalog = (state.operationsCatalog || []).filter(x => x.id !== id); save(); renderOps();
          try { if (state.storage.mode === 'firebase' && await ensureFirebase()) { await fbRoot().collection('operationsCatalog').doc(id).delete(); } } catch (e) { console.warn('Błąd usuwania operacji:', e.message); } break;
        }
        if(t.dataset.opUp) { moveOp(t.dataset.opUp, 'up'); break; }
        if(t.dataset.opDown) { moveOp(t.dataset.opDown, 'down'); break; }
        if(t.dataset.pup) { const i = +t.dataset.pup; const a = state.PROC_TMP; if (i > 0) { [a[i - 1], a[i]] = [a[i], a[i - 1]]; renderProcOps(); } break; }
        if(t.dataset.pdown) { const i = +t.dataset.pdown; const a = state.PROC_TMP; if (i < a.length - 1) { [a[i + 1], a[i]] = [a[i], a[i + 1]]; renderProcOps(); } break; }
        if(t.dataset.pdel) { const i = +t.dataset.pdel; state.PROC_TMP.splice(i, 1); renderProcOps(); break; }
        if(t.dataset.ped) {
          const p = state.processes.find(x => x.id === t.dataset.ped); if (!p) return; qs('#proc-id').value = p.id;
          qs('#proc-name').value = p.name;
          // Załaduj szablon materiałowy
          const templateSel = qs('#proc-template-select');
          if (templateSel) templateSel.value = p.materialTemplateId || '';
          // preserve assignee when loading for edit
          state.PROC_TMP = (p.operations || []).map(x => ({name: x.name, time: x.time || 0, assignee: x.assignee || null}));
          renderProcOps(); window.scrollTo({top: 0, behavior: 'smooth'}); break;
        }
        if(t.dataset.pdel2) { state.processes = state.processes.filter(x => x.id !== t.dataset.pdel2); save(); renderProcList(); break; }
        if(t.dataset.taskStart) {
          const id = t.dataset.taskStart; const task = state.tasks.find(x => x.id === id); if (!task) return;
          task.status = 'run'; state._timers[id] = Date.now(); save(); try{ updateOrderProgress(task.orderId); }catch(_){ } renderTasks(); break;
        }
        if(t.dataset.taskPause) {
          const id = t.dataset.taskPause; const task = state.tasks.find(x => x.id === id); if (!task) return;
          if (state._timers[id]) { task.elapsedMin = (task.elapsedMin || 0) + (Date.now() - state._timers[id]) / 60000; delete state._timers[id]; }
          task.status = 'todo'; save(); try{ updateOrderProgress(task.orderId); }catch(_){ } renderTasks(); break;
        }
        if(t.dataset.taskDone) {
          const id = t.dataset.taskDone; const task = state.tasks.find(x => x.id === id); if (!task) return;
          if (state._timers[id]) { task.elapsedMin = (task.elapsedMin || 0) + (Date.now() - state._timers[id]) / 60000; delete state._timers[id]; }
          task.status = 'done'; save(); try{ updateOrderProgress(task.orderId); }catch(_){ } renderTasks(); break;
        }
        if(t.dataset.taskRepeat) {
          const id = t.dataset.taskRepeat; const task = state.tasks.find(x => x.id === id); if (!task) return;
          if (state._timers[id]) delete state._timers[id]; task.status = 'todo'; task.elapsedMin = 0; save(); try{ updateOrderProgress(task.orderId); }catch(_){ } renderTasks(); break;
        }
        if(t.dataset.taskRetry) {
          const id = t.dataset.taskRetry; const task = state.tasks.find(x => x.id === id); if (!task) return;
          task._syncPending = true; task._syncError = false; save(); try{ renderTasks(); }catch(_){ }
          if(state.storage && state.storage.mode === 'firebase'){
            try{ await saveTaskToDB(id); }catch(e){ (window.logDev||console.warn)('taskRetry saveToDB error', e && e.message); }
          }
          break;
        }
        if(t.dataset.taskDel) { const id = t.dataset.taskDel; 
          const ask = state.storage.askBeforeTaskDelete === undefined ? true : !!state.storage.askBeforeTaskDelete;
          const doDelete = await (async ()=>{
            if(!ask) return true;
            try{ return await confirmModal('Usunąć zadanie?'); }catch(_){ return false; }
          })();
          if(!doDelete) return; const toDel = (state.tasks||[]).find(x=>x.id===id); state.tasks = (state.tasks||[]).filter(x=>x.id!==id); save(); try{ if(toDel) updateOrderProgress(toDel.orderId); }catch(_){ } renderTasks(); break; }
        if(t.dataset.empDel) { state.employees = state.employees.filter(x => x.id !== t.dataset.empDel); save(); renderEmployees(); break; }
        if(t.dataset.empEd) {
          const e = state.employees.find(x => x.id === t.dataset.empEd); if (!e) return;
          const n = prompt('Nowe imię', e.name) || e.name; e.name = n; save(); renderEmployees(); break;
        }
        if(t.dataset.assign) {
          // legacy hook for assign buttons (if any). mark save and maybeAutoSave
          const id = t.dataset.assign; // task id
          // a real assign flow should update state.tasks[].assignees
          maybeAutoSave('assign');
          break;
        }
        if(t.dataset.taskStart){
          const id = t.dataset.taskStart; const task = (state.tasks||[]).find(x=>x.id===id); if(!task) break;
          // mark as running
          task.status = 'run';
          task.startedAt = new Date().toISOString();
          task.startedBy = (state.storage && state.storage.userId) || task.startedBy || null;
          if(typeof task.elapsedMin === 'undefined') task.elapsedMin = 0;
          save(); try{ renderTasks(); renderMonitor && renderMonitor(); }catch(_){ }
          maybeAutoSave('task-start');
          break;
        }
        if(t.dataset.taskDone){
          const id = t.dataset.taskDone; const task = (state.tasks||[]).find(x=>x.id===id); if(!task) break;
          task.status = 'done'; task.closedAt = new Date().toISOString(); task.closedBy = (state.storage && state.storage.userId) || task.closedBy || null;
          try{ if(task.startedAt){ const s = new Date(task.startedAt); const diff = (Date.now() - s.getTime())/60000; task.elapsedMin = Math.round((task.elapsedMin||0) + diff); } }catch(_){ }
          save(); try{ renderTasks(); renderMonitor && renderMonitor(); }catch(_){ }
          // after marking a task done, if all tasks for the same order are finished, remove tasks for that order
          try{ if(task.orderId){ cleanupTasksForOrder(task.orderId); } }catch(_){ }
          maybeAutoSave('task-done');
          break;
        }
        if(t.dataset.asDel) { state.after = state.after.filter(x => x.id !== t.dataset.asDel); save(); renderASPage(); break; }
        if(t.dataset.asEd) {
          const a = state.after.find(x => x.id === t.dataset.asEd); if (!a) return; qs('#as-id').value = a.id;
          qs('#as-type').value = a.type; qs('#as-order').value = a.order || ''; qs('#as-status').value = a.status;
          qs('#as-desc').value = a.desc || ''; qs('#as-install').value = a.installDate || '';
          qs('#as-go').value = a.departTime || ''; qs('#as-visit').value = a.visitTime || '';
          // populate phone, placecode and address fields
          qs('#as-phone').value = a.phone || '';
          qs('#as-placecode').value = a.postalCode || a.placeCode || '';
          qs('#as-address').value = a.address || '';
          qs('#as-hours').value = a.hours || '';
          // populate lead employee from related order
          const relatedOrder = (state.orders||[]).find(o => o.id === a.order);
          if(relatedOrder && relatedOrder.leadEmployeeId) {
            const leadEmp = (state.employees||[]).find(e => e.id === relatedOrder.leadEmployeeId);
            qs('#as-lead').value = leadEmp ? leadEmp.name : '';
          } else {
            qs('#as-lead').value = '';
          }
          // Select appropriate employees in multi-select (support both old and new format)
          const empIds = a.employeeIds || (a.employeeId ? [a.employeeId] : []);
          const empSel = qs('#as-employees');
          if(empSel) {
            Array.from(empSel.options).forEach(opt => {
              opt.selected = empIds.includes(opt.value);
            });
          }
          window.scrollTo({top: 0, behavior: 'smooth'});
          break;
        }
        if(t.dataset.refreshAs) { loadFromDB(); break; }
        if (t.id === 'mrp-generate') { renderMRPPage(); break; }
      } else if (e.type === 'input') {
        if(e.target && (e.target.id === 'o-start' || e.target.id === 'o-weeks' || e.target.id === 'o-end')) {
            if (e.target.id === 'o-start' || e.target.id === 'o-weeks') {
                calcEndDate();
            } else if (e.target.id === 'o-end') {
                calcInstallDate();
            }
            break;
        }
        if (t.parentElement && t.parentElement.id === 'p-settings') {
          state.storage.mode = qs('#set-mode').value;
          state.storage.appId = qs('#set-appid').value.trim();
          state.storage.userId = qs('#set-userid').value.trim();
          try { state.storage.fbConfig = JSON.parse(qs('#set-fb').value || '{}'); } catch(e) {}
          save();
          updateConnectionStatus();
          break;
        }
      }
      t = t.parentElement;
    }
  };
  document.addEventListener('click', handleEvents);

  // Tryb awaryjny: bezpośrednie listenery dla data-nav i krytycznych przycisków
  window.initDirectNavHandlers = function(){
    try{
      console.log('[rescue] Installing direct nav handlers');
      document.querySelectorAll('[data-nav]').forEach(el=>{
        if(el.__directNavBound) return;
        el.addEventListener('click', (ev)=>{ if(window.disableGlobalClickDelegation){ ev.preventDefault(); ev.stopPropagation(); nav(el.getAttribute('data-nav')); } });
        el.__directNavBound = true;
      });
      // Magazyn przyciski
      // Kod bezpośrednich listenerów dla magazynu usunięty
      console.log('[rescue] Direct handlers ready');
    }catch(e){ console.warn('[rescue] direct nav error', e); }
  };
  
  // Funkcja włączająca tryb awaryjny (wyłącza delegację, dodaje bezpośrednie listenery)
  window.enableNoDelegateMode = function(){
    console.warn('[BLOCKED] No-delegation mode DISABLED - normal delegation required for this app');
    // Automatycznie przywróć normalną delegację
    window.restoreNormalClickDelegation();
    return false;
  };

  // NOWA FUNKCJA: Przywracanie normalnej delegacji kliknięć - PRZENIESIONA WYŻEJ
  // window.restoreNormalClickDelegation = function(){
  //   window.disableGlobalClickDelegation = false;
  //   console.log('[rescue] Normal click delegation RESTORED');
  //   // Zapobiegaj ponownemu włączeniu - nadpisz funkcję awaryjną
  //   window.enableNoDelegateMode = function(){
  //     console.warn('[rescue] No-delegation mode BLOCKED - normal delegation required');
  //     return false;
  //   };
  // };

  // Awaryjna funkcja przywracania klikalności
  window.enableClicksRescue = function(){
    try{
      console.log('[rescue] Starting click rescue...');
      document.body.style.pointerEvents='auto';
      document.body.style.userSelect='auto';
      // Usuń potencjalne pełnoekranowe zasłony (heurystyka)
      const vw=innerWidth, vh=innerHeight;
      let removed=0;
      document.querySelectorAll('body *').forEach(el=>{
        try{
          const st=getComputedStyle(el); if(st.position!=='fixed'&&st.position!=='absolute') return;
          const r=el.getBoundingClientRect();
          if(r.width>vw*0.98 && r.height>vh*0.98){
            if(st.pointerEvents!=='none' && !el.id.includes('dev-log')){
              el.style.pointerEvents='none'; el.style.opacity='0.999'; removed++;
            }
          }
        }catch(_){/* ignore */}
      });
      console.log('[rescue] Processed overlays, modified:', removed);
      // Dodaj testowy przycisk diagnostyczny
      if(!document.getElementById('__click_test_btn')){
        const b=document.createElement('button'); b.id='__click_test_btn'; b.textContent='test click'; b.style.cssText='position:fixed;top:4px;right:4px;z-index:999999;padding:4px 8px;font-size:12px';
        b.addEventListener('click',()=>console.log('[rescue] test button clicked OK'));
        document.body.appendChild(b);
      }
      console.log('[rescue] Click rescue finished.');
    }catch(e){ console.warn('[rescue] error', e); }
  };

  // DEBUG: when Edit buttons are clicked (data-op-ed), log the event and #op-id after population
  (function attachOpEditLog(){
    document.body.addEventListener('click', function(ev){
      const btn = ev.target.closest && ev.target.closest('[data-op-ed]');
      if(!btn) return; const opId = btn.getAttribute('data-op-ed');
      (window.logDev||console.log)('[ui] Edit click', { dataOpEd: opId });
      // schedule a short tick to log #op-id after any population logic runs
      setTimeout(()=>{ const cur = qs('#op-id')?qs('#op-id').value:''; (window.logDev||console.log)('[ui] #op-id after edit click', cur); }, 50);
    }, true);
  })();
  document.addEventListener('input', handleEvents);

  // sync autosave checkbox UI with state on load
  try{ const cb = qs('#set-autosave-assign'); if(cb) cb.checked = !!state.storage.autoSaveAssign; }catch(e){}
  // sync autoload DB checkbox UI with state on load
  try{ const al = qs('#set-autoload-db'); if(al) al.checked = !!state.storage.autoLoadFromDB; }catch(e){}
  // sync monitor threshold UI with state on load
  try{ const th = qs('#set-monitor-threshold'); if(th) th.value = String(state.storage.monitorThreshold || 5); }catch(e){}
  // sync monitor alerts UI with state on load
  try{ const ma = qs('#set-monitor-alerts'); if(ma) ma.checked = (state.storage.monitorAlertsEnabled !== false); }catch(e){}
  // sync auto-cleanup UI with state on load
  try{ const ac = qs('#set-auto-cleanup'); if(ac) ac.checked = (state.settings && state.settings.autoCleanup !== false); }catch(e){}
  // sync spellcheck enforce checkbox UI with state on load
  try{ const sc = qs('#set-spellcheck-enforce'); if(sc) sc.checked = !!state.storage.spellcheckEnforce; }catch(e){}

  // persist autosave checkbox changes
  const autosaveEl = qs('#set-autosave-assign'); if(autosaveEl){ autosaveEl.addEventListener('change', (ev)=>{ state.storage.autoSaveAssign = !!ev.target.checked; save(); }); }
  // persist autoload checkbox changes
  const autoloadEl = qs('#set-autoload-db'); if(autoloadEl){ autoloadEl.addEventListener('change', (ev)=>{ state.storage.autoLoadFromDB = !!ev.target.checked; save(); }); }
  // persist monitor threshold changes
  const monitorThEl = qs('#set-monitor-threshold'); if(monitorThEl){ monitorThEl.addEventListener('change', (ev)=>{ const v = parseInt(ev.target.value||'5',10) || 5; state.storage.monitorThreshold = Math.max(1, v); save(); }); }
  // persist monitor alerts changes
  const monitorAlertEl = qs('#set-monitor-alerts'); if(monitorAlertEl){ monitorAlertEl.addEventListener('change', (ev)=>{ state.storage.monitorAlertsEnabled = !!ev.target.checked; save(); }); }
  // persist auto-cleanup changes
  const autoCleanupEl = qs('#set-auto-cleanup'); if(autoCleanupEl){ autoCleanupEl.addEventListener('change', (ev)=>{ state.settings.autoCleanup = !!ev.target.checked; save(); }); }
  // persist spellcheck enforce changes
  const spellEl = qs('#set-spellcheck-enforce'); if(spellEl){ spellEl.addEventListener('change', (ev)=>{ state.storage.spellcheckEnforce = !!ev.target.checked; save(); if(ev.target.checked) enableSpellAndLang(); else disableSpellAndLang(); }); }

  // in-page confirmation modal (promise-based)
  function confirmModal(message){
    return new Promise((resolve)=>{
      try{
        const modal = qs('#app-confirm-modal'); const msg = qs('#app-confirm-msg'); const ok = qs('#app-confirm-ok'); const cancel = qs('#app-confirm-cancel'); const close = qs('#app-confirm-close'); const noask = qs('#app-confirm-noask');
        if(!modal || !msg || !ok || !cancel) return resolve(false);
        msg.textContent = String(message||'');
        modal.classList.remove('hidden');
        const cleanup = ()=>{ modal.classList.add('hidden'); ok.removeEventListener('click', onOk); cancel.removeEventListener('click', onCancel); close && close.removeEventListener('click', onCancel); };
        const onOk = ()=>{ const na = !!noask.checked; if(na) state.storage.askBeforeTaskDelete = false; save(); cleanup(); resolve(true); };
        const onCancel = ()=>{ const na = !!noask.checked; if(na) state.storage.askBeforeTaskDelete = false; save(); cleanup(); resolve(false); };
        ok.addEventListener('click', onOk); cancel.addEventListener('click', onCancel); if(close) close.addEventListener('click', onCancel);
      }catch(e){ resolve(false); }
    });
  }

  function addWorkdays(dateString, days) {
    let d = new Date(dateString + 'T00:00:00');
    let count = 0;
    while (count < days) {
      d.setDate(d.getDate() + 1);
      if (d.getDay() !== 0 && d.getDay() !== 6) {
        count++;
      }
    }
    return d.toISOString().slice(0, 10);
  }

  function calcEndDate() {
    const s = qs('#o-start').value;
    const w = +qs('#o-weeks').value || 1;
    if (!s) return;
    const end = addWorkdays(s, w * 5 - 1);
    qs('#o-end').value = end;
    calcInstallDate();
  }

  function calcInstallDate() {
    const end = qs('#o-end').value;
    if (!end) return;
    const install = addWorkdays(end, 7);
    qs('#o-install').value = install;
  }

  // Funkcja pomocnicza do ustawiania tekstu z dobrym kontrastem
  function setInfoText(text, type = 'default') {
    const info = qs('#set-info');
    if(!info) return;
    
    info.textContent = text;
    info.style.color = '#ffffff';
    info.style.fontWeight = '600';
    info.style.fontSize = '14px';
    info.style.padding = '4px 8px';
    info.style.borderRadius = '4px';
    info.style.border = '1px solid #334155';
    
    // Kolorystyka według typu wiadomości
    switch(type) {
      case 'success':
        info.style.background = '#059669'; // Zielone
        break;
      case 'warning':
        info.style.background = '#d97706'; // Pomarańczowe
        break;
      case 'error':
        info.style.background = '#dc2626'; // Czerwone
        break;
      default:
        info.style.background = '#1a2332'; // Domyślne ciemnoniebieskie
    }
  }

  function updateConnectionStatus(){
    const info = qs('#set-info');
    if(!info) return;
    
    if(state.storage.mode === 'firebase'){
      setInfoText('Tryb Firebase - sprawdzam połączenie...', 'default');
      // Sprawdź połączenie z Firebase
      ensureFirebase().then(ok => {
        if(ok){
          setInfoText('✅ Połączono z Firebase', 'success');
        } else {
          setInfoText('⚠️ Firebase niedostępny - tryb offline', 'warning');
        }
      }).catch(() => {
        setInfoText('❌ Błąd połączenia z Firebase', 'error');
      });
    } else {
      setInfoText('Tryb localStorage (offline)', 'default');
    }
  }
  // Upewnij się że funkcja dostępna globalnie do diagnostyki ładowania
  window.updateConnectionStatus = window.updateConnectionStatus || updateConnectionStatus;
  
  function populateProcessSelect(){
    const sel = qs('#o-proc');
    if (sel) {
      sel.innerHTML = '<option value="">Brak</option>';
      (state.processes || []).forEach(p => {
        const opt = document.createElement('option');
        opt.value = p.id;
        opt.textContent = p.name;
        sel.appendChild(opt);
      });
    }
  }

  function renderOrderPage(){
    populateProcessSelect();
    populateLeadSelect();
    const host=qs('#ord-tb'); if(!host) return; host.innerHTML='';
    // show progress column: percent + counts
    (state.orders||[]).slice().reverse().forEach(o=>{
      const tr=document.createElement('tr');
      const place = o.postalCode || o.post || '';
      const pr = computeOrderProgress(o.id) || (o.progress || {total:0,done:0,run:0,todo:0,pct:0});
      const pct = Math.round((pr.pct||0));
      const barWidth = Math.min(100, Math.max(0, pct));
      const bar = `<div style="background:#0b1222;border:1px solid #223044;border-radius:6px;height:12px;width:120px;overflow:hidden"><div style="height:100%;width:${barWidth}%;background:linear-gradient(90deg,#16a34a,#a3e635);"></div></div>`;
      // Lead time (planned) w godzinach
      const ts = (state.tasks||[]).filter(t=>t.orderId===o.id && t.startPlanned && t.endPlanned);
      let leadH = '-';
      if(ts.length){
        const startMin = Math.min(...ts.map(t=>t.startPlanned));
        const endMax = Math.max(...ts.map(t=>t.endPlanned));
        leadH = ((endMax - startMin)/3600000).toFixed(1);
      }
  const genBtn = o.tasksGenerated ? '' : `<button class=\"btn\" data-ogen=\"${o.id}\">Gen. zadania</button>`;
  const replanOneBtn = `<button class=\"btn amber\" data-replan-order=\"${o.id}\" title=\"Resetuj i przelicz tylko zadania tego zlecenia\">Replan</button>`;
  const checklistBtn = o.processId ? `<button class=\"btn blue\" data-checklist=\"${o.id}\" title=\"Pokaż checklistę materiałów\">📋 Checklist</button>` : '';
  
  // Oblicz status materiałów dla zlecenia
  let materialsStatus = '-';
  let materialsBtn = '';
  if (o.materialChecklist && o.materialChecklist.length > 0) {
    const warehouseItems = window.warehouseItems || [];
    const reservations = window.warehouseReservations || [];
    let allAvailable = 0;
    let someShortage = 0;
    let notFound = 0;
    
    o.materialChecklist.forEach(item => {
      const warehouseItem = warehouseItems.find(w => w.id === item.itemId);
      if (!warehouseItem) {
        notFound++;
        return;
      }
      const reserved = reservations.filter(r => r.itemId === item.itemId && r.status === 'active').reduce((sum, r) => sum + (r.quantity || 0), 0);
      const available = warehouseItem.quantity - reserved;
      if (available >= item.quantity) {
        allAvailable++;
      } else if (available > 0) {
        someShortage++;
      } else {
        someShortage++;
      }
    });
    
    if (notFound === o.materialChecklist.length) {
      materialsStatus = '❌ Brak';
    } else if (allAvailable === o.materialChecklist.length) {
      materialsStatus = '✅ Dostępne';
    } else {
      materialsStatus = '⚠️ Braki';
    }
    materialsBtn = `<button class=\"btn blue\" onclick=\"window.showOrderMaterials('${o.id}')\" title=\"Pokaż materiały i wydaj z magazynu\">📦 Materiały</button>`;
  }
  
  tr.innerHTML=`<td>${o.name||'-'}</td><td>${o.client||'-'}</td><td>${o.model||'-'}</td><td>${o.quantity||'-'}</td>
                    <td>${o.startDate||'-'}</td><td>${o.endDate||'-'}</td><td>${o.installDate||'-'}</td><td>${place||'-'}</td>
                    <td>${bar} <div class="muted" style="font-size:12px;margin-top:4px">${pct}% (${pr.done}/${pr.total})</div></td>
                    <td>${leadH}</td>
                    <td>${materialsStatus}<br>${materialsBtn}</td>
  <td><div class="row"><button class="btn" data-oed="${o.id}">Edytuj</button>${genBtn}${checklistBtn}${replanOneBtn}<button class="btn red" data-od="${o.id}">Usuń</button></div></td>`;
      host.appendChild(tr);
    });
  }

  // Mini-Gantt v1 (z wierszem niezaplanowanych + widoczne dni wolne)
  function renderGantt(){
    const host = qs('#gantt-container'); if(!host) return;
    const all = (state.tasks||[]).slice();
    const scheduled = all.filter(t=>t.startPlanned && t.endPlanned);
    const unplanned = all.filter(t=>!(t.startPlanned && t.endPlanned));
    if(!scheduled.length && !unplanned.length){ host.innerHTML='<div class="muted">Brak zadań</div>'; return; }
    const minStart = scheduled.length ? Math.min(...scheduled.map(t=>t.startPlanned)) : Date.now();
    const maxEnd = scheduled.length ? Math.max(...scheduled.map(t=>t.endPlanned)) : (minStart + 8*3600*1000);
    
    // Rozszerz zakres o kilka dni wstecz aby pokazać weekend przed pierwszymi zadaniami
    const expandedStart = minStart - (3 * 24*3600*1000); // 3 dni wstecz
    const expandedEnd = maxEnd + (2 * 24*3600*1000); // 2 dni naprzód
    const dayMs = 24*3600*1000;
    const days = Math.max(1, Math.ceil((expandedEnd - expandedStart)/dayMs));
    
    // Pobierz konfigurację dni wolnych
    const off = new Set(((state.scheduleConfig&&state.scheduleConfig.offWeekdays)||[]).map(Number));
    const holidays = new Set(((state.scheduleConfig&&state.scheduleConfig.holidays)||[]));
    
    let html = '<div style="position:relative;">';
    html += '<div style="display:flex;margin-bottom:4px">'+Array.from({length:days}).map((_,i)=>{
      const d=new Date(expandedStart + i*dayMs); 
      const y=d.getFullYear(); const m=(d.getMonth()+1+'').padStart(2,'0'); const dayNum=(d.getDate()+'').padStart(2,'0'); const key=`${y}-${m}-${dayNum}`;
      const isOff = off.has(d.getDay()) || holidays.has(key);
      const bgStyle = isOff ? 'background:repeating-linear-gradient(45deg,#2d1b34,#2d1b34 4px,#1e293b 4px,#1e293b 8px);opacity:0.7;' : 'background:#0f172a;';
      const title = isOff ? 'title="Dzień wolny - brak zadań"' : '';
      return `<div style=\"flex:0 0 160px;border-right:1px solid #1e293b;padding:2px 4px;${bgStyle}color:#94a3b8\" ${title}>${d.toLocaleDateString()}</div>`; 
    }).join('')+'</div>';
    const byOrder = {};
    scheduled.forEach(t=>{ (byOrder[t.orderId]||(byOrder[t.orderId]=[])).push(t); });
    Object.keys(byOrder).forEach(oid=>{
      const orderName = (state.orders||[]).find(o=>o.id===oid)?.name || oid;
      html += `<div style=\"display:flex;align-items:stretch;margin-bottom:2px;\">`;
      html += `<div style=\"position:sticky;left:0;z-index:2;background:#0b1222;border:1px solid #1e293b;min-width:120px;padding:2px 4px;color:#e2e8f0;font-weight:600\">${orderName}</div>`;
      html += `<div style=\"display:flex;position:relative;\">`;
      const rowTasks = byOrder[oid].sort((a,b)=>a.startPlanned-b.startPlanned);
      rowTasks.forEach(t=>{
        const offsetDays=(t.startPlanned-expandedStart)/dayMs; // Użyj expandedStart zamiast minStart
        const spanDays=(t.endPlanned-t.startPlanned)/dayMs;
        const left=offsetDays*160;
        const width=Math.max(6, spanDays*160 - 4);
        const crit=t.critical?'box-shadow:0 0 0 2px #dc2626 inset;':'';
        const tip=`${t.name||t.opName||''}\n${new Date(t.startPlanned).toLocaleString()} -> ${new Date(t.endPlanned).toLocaleString()}\nStatus: ${t.status||'-'}\nCzas: ${(t.estMin||t.duration||0)} min`;
        html += `<div title=\"${tip}\" style=\"position:absolute;left:${left}px;width:${width}px;height:18px;background:linear-gradient(90deg,#3b82f6,#06b6d4);border-radius:4px;border:1px solid #1e293b;${crit}overflow:hidden;\"></div>`;
      });
      for(let d=0; d<days; d++){ const gx=d*160; html += `<div style=\"position:absolute;left:${gx}px;top:0;bottom:0;width:160px;border-right:1px solid #1e293b;pointer-events:none\"></div>`; }
      html += `</div>`;
      html += `</div>`;
    });
    if(unplanned.length){
      html += `<div style=\"display:flex;align-items:stretch;margin-top:4px;\">`;
      html += `<div style=\"position:sticky;left:0;z-index:2;background:#0b1222;border:1px solid #1e293b;min-width:120px;padding:2px 4px;color:#fbbf24;font-weight:600\">(Niezaplanowane)</div>`;
      html += `<div style=\"display:flex;flex-wrap:wrap;gap:4px;padding:2px 4px;max-width:calc(160px*${days});\">`;
      unplanned.slice(0,200).forEach(t=>{ const label=(t.name||t.opName||'Zadanie').slice(0,24); const tip=`${t.name||t.opName||''}\nStatus: ${t.status||'-'}\nCzas: ${(t.estMin||t.duration||0)} min`; html += `<div title=\"${tip}\" style=\"background:#334155;color:#e2e8f0;font-size:11px;padding:2px 6px;border-radius:4px;border:1px solid #1e293b;\">${label}</div>`; });
      if(unplanned.length>200){ html += `<div style=\"font-size:11px;color:#94a3b8\">+${unplanned.length-200} więcej...</div>`; }
      html += `</div></div>`;
    }
    html += '</div>';
    host.innerHTML=html;
  }

  function updateScheduleConfigFromUI(){
    try{
      const wh = parseInt(qs('#sched-start')?.value||'8',10);
      const wl = parseInt(qs('#sched-len')?.value||'8',10);
      const offWeekdays = Array.from(document.querySelectorAll('.sched-offday:checked')).map(cb=>Number(cb.value));
      const holidaysRaw = (qs('#sched-holidays')?.value||'').split(/[\,\n]/).map(s=>s.trim()).filter(s=>/^\d{4}-\d{2}-\d{2}$/.test(s));
      state.scheduleConfig = { workdayStartHour: wh, workdayLengthHours: wl, offWeekdays, holidays: holidaysRaw };
      (window.logDev||console.log)('[scheduleConfig] updated', state.scheduleConfig);
    }catch(e){ console.warn('updateScheduleConfigFromUI error', e.message); }
  }

  // Szybkie przyciski wyboru dni wolnych
  function initOffdaysQuickButtons(){
    const weekendBtn = document.getElementById('btn-offdays-weekend');
    const workweekBtn = document.getElementById('btn-offdays-workweek');
    const clearBtn = document.getElementById('btn-offdays-clear');
    if(!weekendBtn) return; // UI nie istnieje jeszcze
    const all = Array.from(document.querySelectorAll('.sched-offday'));
    const setChecked = (values)=>{
      const set = new Set(values);
      all.forEach(cb=>{ cb.checked = set.has(Number(cb.value)); });
      updateScheduleConfigFromUI();
    };
    weekendBtn.addEventListener('click', ()=> setChecked([6,0]));
    workweekBtn.addEventListener('click', ()=> setChecked([])); // Czyść dni wolne dla dni roboczych (Pn-Pt)
    clearBtn.addEventListener('click', ()=> setChecked([]));
  }

  function computeOrderProgress(orderId){
    const tasks = (state.tasks||[]).filter(t=>t.orderId === orderId);
    const total = tasks.length;
    const done = tasks.filter(t=>t.status === 'done').length;
    const run = tasks.filter(t=>t.status === 'run').length;
    const todo = tasks.filter(t=>t.status === 'todo').length;
    const pct = total ? Math.round((done + run*0.5) / total * 100) : 0;
    return {total, done, run, todo, pct};
  }

  function updateOrderProgress(orderId){
    try{ const o = (state.orders||[]).find(x=>x.id===orderId); if(!o) return; o.progress = computeOrderProgress(orderId); save(); }catch(_){ }
  }
  qs('#order-form').addEventListener('submit',(ev)=>{
    ev.preventDefault();
    const t0 = performance.now();
    try {
      (window.logDev||console.log)('[order-form] submit start');
      const validationErrors = validateOrderForm();
      if (validationErrors.length > 0) {
        (window.logDev||console.log)('[order-form] validation errors', validationErrors);
        showValidationErrors(validationErrors);
        return;
      }
      const id = (qs('#o-id').value || '').trim();
      const nr=(qs('#o-name').value||'').trim(); if(!nr){ (window.logDev||console.log)('[order-form] brak nazwy'); return; }
      const beforeLen = (state.orders||[]).length;
      const orderObj={id:id||uid(),name:nr,client:qs('#o-client').value||'',model:qs('#o-model').value||'',quantity:parseInt(qs('#o-qty').value||'1',10),
        startDate:qs('#o-start').value||'',endDate:qs('#o-end').value||'',installDate:qs('#o-install').value||'',
        address:qs('#o-addr').value||'',postalCode:qs('#o-post').value||'',phone:qs('#o-phone').value||'',notes:qs('#o-notes').value||'',
        processId:qs('#o-proc').value||'',leadEmployeeId:qs('#o-lead').value||''};
      if(id){
        const existing = state.orders.find(x=>x.id===id);
        if(existing){ Object.assign(existing, orderObj); (window.logDev||console.log)('[order-form] updated', id); }
      } else {
        orderObj.tasksGenerated = false;
        state.orders.push(orderObj);
        (window.logDev||console.log)('[order-form] inserted new order', orderObj.id, 'len=', state.orders.length);
        try{
          const afterEntry = { 
            id: uid(), 
            type:'montaż', 
            order: orderObj.id, 
            status:'nowe', 
            desc: orderObj.notes || '', 
            installDate: orderObj.installDate || '', 
            departTime:'', 
            visitTime:'',
            phone: orderObj.phone || '',
            postalCode: orderObj.postalCode || '',
            address: orderObj.address || '',
            employeeIds: [],
            hours: 0
          };
          state.after.push(afterEntry);
        }catch(e){ console.warn('[order-form] after push error', e.message); }
        try{
          if(window.scheduleCore){
            const gen = window.scheduleCore.generateTasksForOrder(orderObj, state);
            if(gen && gen.length){
              state.tasks = (state.tasks||[]).concat(gen);
              if(typeof updateScheduleConfigFromUI === 'function'){ updateScheduleConfigFromUI(); }
              window.scheduleCore.generateSchedule(state);
              orderObj.tasksGenerated = true;
              (window.logDev||console.log)('[order-form] auto tasks', gen.length);
            }
          }
        }catch(e){ console.warn('[order-form] auto generate tasks error', e.message); }
      }
      const afterLen = (state.orders||[]).length;
      if(!id && afterLen === beforeLen){ console.warn('[order-form] liczba zleceń nie wzrosła!'); }
      maybeAutoSave('order-save');
      save();
      // Podsumowanie skutków zapisu
      const genTasksForOrder = (state.tasks||[]).filter(t=>t.orderId === orderObj.id);
      (window.logDev||console.log)('[order-form] summary', {
        orderId: orderObj.id,
        tasksGeneratedFlag: orderObj.tasksGenerated,
        tasksCount: genTasksForOrder.length,
        firstTask: genTasksForOrder[0] && {id:genTasksForOrder[0].id, op:genTasksForOrder[0].operationId, start:genTasksForOrder[0].startPlanned, end:genTasksForOrder[0].endPlanned}
      });
      if(orderObj.tasksGenerated && !genTasksForOrder.length){
        console.warn('[order-form] tasksGenerated=true ale brak tasków w state.tasks dla order', orderObj.id);
      }
      // Czy harmonogram ma start/end
      const scheduled = genTasksForOrder.filter(t=>t.startPlanned && t.endPlanned).length;
      if(orderObj.tasksGenerated && scheduled === 0){
        console.warn('[order-form] brak zaplanowanych czasów (startPlanned)');
      }
      ev.target.reset(); const hid = qs('#o-id'); if(hid) hid.value='';
      renderOrderPage(); renderASPage(); renderDash(window.state||state); renderGantt();
      const msg = id ? 'Zlecenie zaktualizowane.' : (orderObj.tasksGenerated ? 'Zlecenie zapisane i wygenerowano '+genTasksForOrder.length+' zadań.' : 'Zlecenie zapisane (brak zadań – sprawdź katalog operacji).');
      const feed = qs('#order-feedback');
      if(feed){ feed.textContent = msg; feed.className='ok'; setTimeout(()=>{ if(feed.textContent===msg) feed.textContent=''; }, 6000); }
      else { (window.logDev||console.log)('[order-form] feedback', msg); }
      (window.logDev||console.log)('[order-form] done in', (performance.now()-t0).toFixed(1)+'ms');
    } catch(err){
      console.error('[order-form] fatal', err); alert('Błąd zapisu zlecenia: '+(err.message||err));
    }
  });
  // Delegacja kliknięć - generowanie zadań na żądanie
  document.addEventListener('click', (ev)=>{
    const genBtn = ev.target.closest('[data-ogen]');
    const replanBtn = ev.target.closest('[data-replan-order]');
    if(!genBtn && !replanBtn) return;
    if(genBtn){
      const oid = genBtn.getAttribute('data-ogen');
      const order = (state.orders||[]).find(o=>o.id===oid);
      if(!order){ alert('Nie znaleziono zamówienia'); return; }
      if(order.tasksGenerated){ alert('Zadania już zostały wygenerowane dla tego zamówienia.'); return; }
      
      // Use new generateTasks function
      const success = generateTasks(oid);
      if(success){
        order.tasksGenerated = true;
        save();
        renderDash(window.state||state);
        renderGantt();
        renderOrderPage();
        console.log('[order] Tasks generated successfully for order', order.name);
      } else {
        alert('Nie udało się wygenerować zadań. Sprawdź czy zlecenie ma przypisany proces.');
      }
      return;
    }
    if(replanBtn){
      const oid = replanBtn.getAttribute('data-replan-order');
      if(!window.scheduleCore) return;
      if(typeof updateScheduleConfigFromUI==='function') updateScheduleConfigFromUI();
      if(!confirm('Przeliczyć od nowa zadania tego zlecenia?')) return;
      window.scheduleCore.generateSchedule(state,{force:true, onlyOrderId: oid});
      save(); renderGantt(); renderOrderPage();
      (window.logDev||console.log)('[replan] single order', oid);
    }
  });
  
  function populateOpEmployees(){
    const sel=qs('#op-emp'); if(!sel) return;
    const keep=new Set(Array.from(sel.selectedOptions||[]).map(o=>o.value));
    sel.innerHTML='';
    (state.employees||[]).forEach(e=>{const o=document.createElement('option');o.value=e.id;o.textContent=e.name||e.id;if(keep.has(e.id))o.selected=true;sel.appendChild(o);});
  }
  function populateLeadSelect(){
    const sel=qs('#o-lead'); if(!sel) return;
    const current = sel.value;
    sel.innerHTML='<option value="">— wybierz pracownika —</option>';
    (state.employees||[]).forEach(e=>{const o=document.createElement('option');o.value=e.id;o.textContent=e.name||e.id;sel.appendChild(o);});
    if(current) sel.value = current;
  }
  // Normalize operation numbers (ensure sequential no = 1..N sorted by no)
  function normalizeOpNumbers() {
    state.operationsCatalog = (state.operationsCatalog || []).slice().sort((a,b)=>(a.no||0)-(b.no||0)).map((o,i)=>{ o.no = i+1; return o; });
  }

  // Move operation by id up/down in the ordered list
  function moveOp(id, dir){
    const arr = (state.operationsCatalog || []).slice().sort((a,b)=>(a.no||0)-(b.no||0));
    const idx = arr.findIndex(x=>x.id===id);
    if(idx === -1) return;
    const newIdx = dir === 'up' ? Math.max(0, idx-1) : Math.min(arr.length-1, idx+1);
    if(newIdx === idx) return;
    const [item] = arr.splice(idx,1);
    arr.splice(newIdx,0,item);
    arr.forEach((o,i)=>o.no = i+1);
    state.operationsCatalog = arr;
    save(); renderOps();
  }
  function renderOps(){
    populateOpEmployees();
    const tb=qs('#op-tb'); if(!tb) return; tb.innerHTML='';
    // populate component selector with unique components
    const compSel = qs('#op-comp-select'); if(compSel){
      const comps = new Set(); (state.operationsCatalog||[]).forEach(op=>{(op.skills||[]).forEach(s=>comps.add(s.trim()));});
      const prev = compSel.value || '';
      compSel.innerHTML = '<option value="">— wybierz komponent —</option>' + Array.from(comps).filter(Boolean).sort().map(c=>`<option value="${c}">${c}</option>`).join('');
      if(prev) compSel.value = prev;
    }

    (state.operationsCatalog||[]).slice().sort((a,b)=>(a.no||0)-(b.no||0)).forEach((o,idx,arr)=>{
      const ass=(o.defaultAssignees||[]).map(a=>a.name).join(', ')||'-';
      const tr=document.createElement('tr');
      tr.innerHTML=`<td>${o.no||0}</td><td>${o.name||''}</td><td>${o.time||0}</td><td>${o.workers||1}</td>
                    <td>${(o.skills||[]).join(', ')}</td><td>${ass}</td>
                    <td>
                      <div class="row">
                        <button class="btn" data-op-up="${o.id}" ${idx===0?"disabled":""}>↑</button>
                        <button class="btn" data-op-down="${o.id}" ${idx===arr.length-1?"disabled":""}>↓</button>
                        <button class="btn" data-op-ed="${o.id}">Edytuj</button>
                        <button class="btn red" data-op-del="${o.id}">Usuń</button>
                      </div>
                    </td>`;
      tb.appendChild(tr);
    });
    qs('#op-count').textContent=String((state.operationsCatalog||[]).length);
    const sel=qs('#proc-op-select'); if(sel){ sel.innerHTML=''; (state.operationsCatalog||[]).forEach(o=>{ const opt=document.createElement('option'); opt.value=o.id; opt.textContent=(o.no||0)+'. '+o.name+' ('+(o.time||0)+'m)'; sel.appendChild(opt); }); }
  }
  // sort operations by whether they contain a selected component (selected first), then keep rest, normalize numbers
  function sortByComponent(component){
    if(!component) return;
    const ops = (state.operationsCatalog||[]).slice();
    const match = [];
    const rest = [];
    ops.forEach(o=>{ if((o.skills||[]).map(s=>s.toLowerCase()).indexOf(component.toLowerCase())!==-1) match.push(o); else rest.push(o); });
    const res = match.concat(rest);
    res.forEach((o,i)=>o.no = i+1);
    state.operationsCatalog = res; save(); renderOps();
  }
  // normalize numbers to 1..N (already provided as normalizeOpNumbers)
  // sort operations alphabetically by name
  function sortOpsAZ(){
    const ops = (state.operationsCatalog||[]).slice().sort((a,b)=>{ const A=(a.name||'').toLowerCase(); const B=(b.name||'').toLowerCase(); return A.localeCompare(B); });
    ops.forEach((o,i)=>o.no = i+1);
    state.operationsCatalog = ops; save(); renderOps();
  }

  // wire buttons
  const opNormalizeBtn = qs('#op-normalize'); if(opNormalizeBtn){ opNormalizeBtn.addEventListener('click', ()=>{ normalizeOpNumbers(); save(); renderOps(); }); }
  const opSortBtn = qs('#op-sort-az'); if(opSortBtn){ opSortBtn.addEventListener('click', ()=>{ sortOpsAZ(); }); }
  const opSortCompBtn = qs('#op-sort-comp'); if(opSortCompBtn){ opSortCompBtn.addEventListener('click', ()=>{ const sel = qs('#op-comp-select'); if(sel) sortByComponent(sel.value); }); }
  const opSaveDbBtn = qs('#op-save-db'); if(opSaveDbBtn){ opSaveDbBtn.addEventListener('click', async ()=>{
    try{
      if(!(state.storage.mode==='firebase' && await ensureFirebase())){ alert('Firebase nie jest skonfigurowany/aktywowany. Nie można zapisać do DB.'); return; }
      const col = fbRoot().collection('operationsCatalog');
      for(const op of (state.operationsCatalog||[])){
        try{ await col.doc(op.id).set(JSON.parse(JSON.stringify(op)),{merge:true}); }catch(e){ console.warn('Błąd zapisu op:', e.message); }
      }
      alert('Zapisano katalog operacji do DB.');
    }catch(e){ console.warn('saveAllOpsToDB error', e); alert('Błąd: ' + (e.message||e)); }
  }); }
  qs('#op-form').addEventListener('submit', async (ev)=>{
    ev.preventDefault();
    const msg=(t,ok=false)=>{const el=qs('#op-msg'); if(el){el.textContent=t||''; el.className='muted '+(ok?'oktxt':'err');}};
    const submitBtn = ev.target.querySelector('button[type="submit"]');
    if(submitBtn) submitBtn.disabled = true;
    try{
      const rawOpId = (qs('#op-id').value||'').trim();
      console.log('[op-form] submit start', { rawOpId });
      const name=(qs('#op-name').value||'').trim();
      const no=toInt(qs('#op-no').value, 1);
      const time=toInt(qs('#op-time').value, 10);
      const workers=toInt(qs('#op-workers').value, 1);
      const skills=(qs('#op-skills').value||'').split(';').map(s=>s.trim()).filter(Boolean);
      const sel=qs('#op-emp'); const assIds=Array.from(sel.selectedOptions||[]).map(o=>o.value);
      const ass=assIds.map(v=>{const e=(state.employees||[]).find(x=>x.id===v); return e?{id:e.id,name:e.name}:null;}).filter(Boolean);
      if(!name){msg('Podaj nazwę operacji.'); if(submitBtn) submitBtn.disabled = false; return;}
      if(!(time>=1)){msg('Czas [min] musi być ≥ 1.'); if(submitBtn) submitBtn.disabled = false; return;}
      if(!(workers>=1)){msg('Domyślna liczba pracowników musi być ≥ 1.'); if(submitBtn) submitBtn.disabled = false; return;}

  // use in-memory state snapshot (avoid reading localStorage here to prevent overwriting recent in-memory edits)
  state._inOpEdit = true;

      // operate on a shallow copy
      const ops = (state.operationsCatalog||[]).slice();
      const existingIdx = rawOpId ? ops.findIndex(x=> x.id === rawOpId) : -1;
      const isUpdate = existingIdx >= 0;
      console.log('[op-form] isUpdate?', isUpdate, 'existingIdx', existingIdx);
      const id = isUpdate ? rawOpId : uid();
      const payload = { id, no, name, time, workers, skills, defaultAssignees: ass };

      if(isUpdate){
        // update only the specific operation by id (preserve other fields)
        const existingOp = ops[existingIdx] || {};
        const merged = Object.assign({}, existingOp, payload);
        ops.splice(existingIdx, 1, merged);
        msg('Zaktualizowano operację.', true);
      } else {
        // always INSERT when no op-id provided — never replace existing items even if names collide
        const insertAt = Math.max(0, Math.min(no-1, ops.length));
        ops.splice(insertAt, 0, payload);
        msg('Dodano nową operację.', true);
      }

      // Persist our ops array directly into state to avoid accidental drops during
      // rapid consecutive inserts. Reindex sequentially and keep the ops order.
      try{
        ops.forEach((o,i)=>o.no = i+1);
        state.operationsCatalog = ops;
      }catch(_){ ops.forEach((o,i)=>o.no=i+1); state.operationsCatalog = ops; }

      try{ localStorage.setItem(storeKey, JSON.stringify(state)); }catch(_){ }
      save(); renderOps();
      // DEVLOG: snapshot after submit — last 3 operations and total length
      try{
        const all = (state.operationsCatalog||[]).slice().sort((a,b)=>(a.no||0)-(b.no||0));
        const last3 = all.slice(-3).map(o=>({id:o.id,name:o.name,no:o.no}));
        (window.logDev||console.log)('[op-form] post-submit snapshot', { total: all.length, last3 });
        const infoEl = qs('#set-info'); if(infoEl) infoEl.textContent = `Ops:${all.length} last:${ last3.map(x=>x.name).join(', ') }`;
      }catch(e){ (window.logDev||console.log)('[op-form] post-submit debug error', e && e.message); }
      try{ if(state.storage.mode==='firebase' && await ensureFirebase()){ await fbRoot().collection('operationsCatalog').doc(id).set(JSON.parse(JSON.stringify(payload)),{merge:true}); } }catch(e){ console.warn('Błąd zapisu operacji:', e && e.message); }
  // after save (insert or update): reset form and clear op-id so UI is clean
  try{ ev.target.reset(); }catch(_){ }
  if(qs('#op-id')) qs('#op-id').value = '';
  populateOpEmployees && populateOpEmployees();
  state._inOpEdit = false;
    }catch(e){ console.log('[op-form] submit error', e && e.message); if(qs('#op-msg')) qs('#op-msg').textContent='Błąd zapisu'; state._inOpEdit = false; }
    if(submitBtn) submitBtn.disabled = false;
  });

  function renderProcOps(){
    const box=qs('#proc-ops'); box.innerHTML='';
    (state.PROC_TMP||[]).forEach((op,i)=>{
      const d=document.createElement('div'); d.className='card';
      const empArr = (state.employees||[]).slice();
      if(op.assignee && op.assignee.id && !empArr.some(e=>e.id===op.assignee.id)){
        empArr.unshift({id:op.assignee.id, name: op.assignee.name || op.assignee.id});
      }
      const empOptions = empArr.map(e=>`<option value="${e.id}">${e.name}</option>`).join('');
  d.innerHTML = '<div class="row" style="justify-content:space-between"><div>'+op.name+' <span class="muted">('+(op.time||0)+'m)</span></div>'+
        '<div class="row"><select data-pass>'+ '<option value="">— przypisz pracownika —</option>'+ empOptions +'</select>'+
        ' <button class="btn small" data-clear-ass="'+i+'">Usuń przypisanie</button>'+
        ' <button class="btn" data-pup="'+i+'">↑</button><button class="btn" data-pdown="'+i+'">↓</button><button class="btn red" data-pdel="'+i+'">Usuń</button></div></div>';
      box.appendChild(d);
      const sel = d.querySelector('select[data-pass]');
      if(sel){
        if(op.assignee && op.assignee.id) sel.value = op.assignee.id;
        sel.addEventListener('change', ()=>{
          const val = sel.value;
          if(!val) state.PROC_TMP[i].assignee = null;
          else { const emp = (state.employees||[]).find(x=>x.id===val); state.PROC_TMP[i].assignee = emp?{id:emp.id,name:emp.name}:null; }
          save();
        });
        // clear assignment button
        const clr = d.querySelector('[data-clear-ass]'); if(clr){ clr.addEventListener('click', ()=>{ state.PROC_TMP[i].assignee = null; if(sel) sel.value = ''; save(); renderProcOps(); }); }
      }
    });
  }
  function renderProcList(){ const box=qs('#proc-list'); box.innerHTML=''; (state.processes||[]).forEach(p=>{ const assigned = Array.from(new Set((p.operations||[]).map(o=>o.assignee && o.assignee.name).filter(Boolean))); const assText = assigned.length?(' • pracownicy: '+assigned.join(', ')) : ''; const d=document.createElement('div'); d.className='card'; d.innerHTML='<div class="row" style="justify-content:space-between"><div><b>'+p.name+'</b>'+assText+' • operacji: '+((p.operations||[]).length||0)+'</div><div class="row"><button class="btn" data-ped="'+p.id+'">Edytuj</button> <button class="btn red" data-pdel2="'+p.id+'">Usuń</button></div></div>'; box.appendChild(d); }); qs('#proc-count').textContent=String((state.processes||[]).length); }
  function renderProcPage(){ 
    const sel=qs('#proc-op-select'); if(sel){ sel.innerHTML=''; (state.operationsCatalog||[]).forEach(o=>{ const opt=document.createElement('option'); opt.value=o.id; opt.textContent=(o.no||0)+'. '+o.name+' ('+(o.time||0)+'m)'; sel.appendChild(opt); }); }
    // Wypełnij dropdown szablonów materiałowych
    const templateSel = qs('#proc-template-select');
    if (templateSel) {
      const currentValue = templateSel.value;
      templateSel.innerHTML = '<option value="">Brak</option>';
      (window.materialTemplates || []).forEach(tmpl => {
        const opt = document.createElement('option');
        opt.value = tmpl.id;
        opt.textContent = tmpl.name;
        templateSel.appendChild(opt);
      });
      if (currentValue) templateSel.value = currentValue;
    }
    renderProcOps(); renderProcList(); 
  }
  qs('#proc-add-op').addEventListener('click',()=>{ const id=qs('#proc-op-select').value; const o=state.operationsCatalog.find(x=>x.id===id); if(o){
    let initialAssignee = null;
    if(Array.isArray(o.defaultAssignees) && o.defaultAssignees.length){ const da = o.defaultAssignees[0]; if(da && (da.id || da.name)){ const emp = (state.employees||[]).find(e=>e.id===da.id); if(emp) initialAssignee = { id: emp.id, name: emp.name }; else if(da.id) initialAssignee = { id: da.id, name: da.name || da.id }; else if(da.name) initialAssignee = { id: uid(), name: da.name }; } }
    state.PROC_TMP.push({name:o.name,time:o.time||0, assignee: initialAssignee}); renderProcOps(); save(); } });
  
  qs('#proc-form').addEventListener('submit',(ev)=>{
    ev.preventDefault(); const id=qs('#proc-id').value||uid(); const name=(qs('#proc-name').value||'').trim(); if(!name||(state.PROC_TMP||[]).length===0) return;
    const templateId = qs('#proc-template-select')?.value || null;
    const payload={id,name,operations:(state.PROC_TMP||[]).map(op=>({name:op.name,time:op.time||0, assignee: op.assignee || null})), materialTemplateId: templateId};
    const ex=state.processes.find(x=>x.id===id); if(ex) Object.assign(ex,payload); else state.processes.push(payload);
    state.PROC_TMP=[]; save(); ev.target.reset(); renderProcPage();
  });

  function renderTasks(){
    const list=qs('#tasks-list'); if(!list) return; list.innerHTML='';
    const selOrd=qs('#tasks-filter-order'); if(selOrd){ selOrd.innerHTML='<option value="">Wszystkie zlecenia</option>'+ (state.orders||[]).map(o=>`<option value="${o.id}">${o.name}</option>`).join(''); }
    const fOrd=qs('#tasks-filter-order')?.value||''; const fSt=qs('#tasks-filter-status')?.value||'';
    const rows=(state.tasks||[]).filter(t=>(!fOrd||t.orderId===fOrd)&&(!fSt||(t.status||'')===fSt));
    qs('#tasks-count').textContent=String(rows.length);
    
    // Dodaj przycisk do masowego usuwania na górze listy
    const controlsDiv = document.createElement('div');
    controlsDiv.className = 'row';
    controlsDiv.style.justifyContent = 'flex-end';
    controlsDiv.style.marginBottom = '12px';
    controlsDiv.innerHTML = `
      <button class="btn red" id="mass-delete-tasks" ${rows.length ? '' : 'disabled'}>
        Usuń wszystkie wyświetlone zadania (${rows.length})
      </button>
    `;
    list.appendChild(controlsDiv);
    
    // Dodaj obsługę przycisku
    const massDeleteBtn = qs('#mass-delete-tasks');
    if(massDeleteBtn) {
      massDeleteBtn.addEventListener('click', () => {
        if(confirm(`Czy na pewno chcesz usunąć ${rows.length} zadań? Ta operacja jest nieodwracalna.`)) {
          const idsToDelete = rows.map(t => t.id);
          state.tasks = (state.tasks || []).filter(t => !idsToDelete.includes(t.id));
          save();
          renderTasks();
          setInfoText('Usunięto ' + rows.length + ' zadań', 'success');
        }
      });
    }
    // helper for sync badge
    const syncBadge = (tt)=>{ try{ if(tt._syncPending) return `<span class="task-sync-status pending" title="Czekaj na synchronizację">⏳</span>`; if(tt._syncError) return `<span class="task-sync-status error" title="Błąd synchronizacji">⚠️</span>`; if(tt._lastSync) return `<span class="task-sync-status ok" title="Ostatnia synchronizacja: ${new Date(tt._lastSync).toLocaleString()}">✔️</span>`; return `<span class="task-sync-status unknown" title="Brak synchronizacji">—</span>`; }catch(e){return''} };
    rows.forEach(t=>{
      const d=document.createElement('div'); d.className='card';
      const sb = syncBadge(t);
      const startP = t.startPlanned ? new Date(t.startPlanned).toLocaleString() : '-';
      const endP = t.endPlanned ? new Date(t.endPlanned).toLocaleString() : '-';
      const plannedDur = (t.startPlanned && t.endPlanned) ? Math.round((t.endPlanned - t.startPlanned)/60000)+'m' : '-';
      d.innerHTML=`<div class="row" style="justify-content:space-between">
        <div>
          <b>${t.opName||t.name||'(zadanie)'} ${sb}</b> 
          <span class="muted">
            ${(state.orders||[]).find(o=>o.id===t.orderId)?.name||'-'}
            ${t.processName ? ` • Proces: ${t.processName} (${t.opIndex + 1}/${(state.processes.find(p=>p.id===t.processId)?.operations||[]).length})` : ''}
          </span>
          <div class="muted">Status: ${t.status||'todo'} • Plan: ${plannedDur} • Real: ${Math.round(t.elapsedMin||0)}m ${typeof t.slackMs==='number'?('• Slack: '+Math.round(t.slackMs/60000)+'m'):''} ${t.critical?'• CRITICAL':''}</div>
        <div class="muted">StartP: ${startP} • EndP: ${endP}</div>
        <div class="muted">${t.startedBy?('Rozpoczął: '+t.startedBy):''} ${t.closedBy?('Zamknął: '+t.closedBy):''} ${t.startedAt?(' • start: '+(new Date(t.startedAt)).toLocaleTimeString()):''}</div></div>
        <div class="row">
          ${/* start button green when running */''}
          <button class="${t.status==='run'?'btn green':'btn gray'}" data-task-start="${t.id}" ${t.status==='run'?'disabled':''}>Start</button>
          <button class="btn" data-task-pause="${t.id}" ${t.status!=='run'?'disabled':''}>Pauza</button>
          <button class="btn amber" data-task-repeat="${t.id}">Powtórz</button>
          <button class="${t.status==='done'?'btn green':'btn gray'}" data-task-done="${t.id}" ${t.status==='done'?'disabled':''}>Zamknij</button>
          ${t._syncError?`<button class="btn amber" data-task-retry="${t.id}" title="Ponów synchronizację">Retry</button>`:''}
        </div></div>`;
      list.appendChild(d);
    });
    const byW = qs('#tasks-by-worker'); if(byW) byW.innerHTML = '';
    // small HTML escape helper for safe insertion into innerHTML - delegate to appHelpers when available
    function escapeHtml(s){
      try{ if(window.appHelpers && typeof window.appHelpers.escapeHtml === 'function') return window.appHelpers.escapeHtml(s); }catch(_){ }
      if(s == null) return '';
      try{ return window.escapeHtml ? window.escapeHtml(s) : String(s).replace(/[&<>"']/g, function(c){ return {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[c]; }); }catch(_){ return String(s); }
    }
    try{ window.escapeHtml = escapeHtml; }catch(_){ }
  }

  // If an order has no remaining active tasks (todo/run), remove all tasks linked to that order from state.tasks
  function cleanupTasksForOrder(orderId){
    try{
      // respect settings: if autoCleanup explicitly disabled, skip
      if(state.settings && state.settings.autoCleanup === false){ (window.logDev||console.log)('[cleanupTasksForOrder] skipped due to settings.autoCleanup=false for', orderId); return; }
      const tasks = (state.tasks||[]).filter(t=>t.orderId===orderId);
      if(tasks.length===0) return; // nothing to do
      const anyActive = tasks.some(t=> (t.status||'') !== 'done');
      if(!anyActive){
        // remove tasks belonging to this order
        state.tasks = (state.tasks||[]).filter(t=> t.orderId !== orderId);
        save(); try{ renderTasks(); renderMonitor && renderMonitor(); }catch(_){ }
        (window.logDev||console.log)('[cleanupTasksForOrder] removed tasks for order', orderId);
      }
    }catch(e){ (window.logDev||console.log)('[cleanupTasksForOrder] error', e && e.message); }
  }

  // Generate tasks for an order based on its process
  function generateTasks(orderId){
    try{
      console.log('[generateTasks] Generating tasks for order:', orderId);
      
      // Find the order
      const order = (state.orders||[]).find(o => o.id === orderId);
      if(!order){
        console.error('[generateTasks] Order not found:', orderId);
        return false;
      }
      
      // Check if order has a process assigned
      if(!order.processId){
        console.warn('[generateTasks] Order has no process assigned:', orderId);
        alert('Zlecenie nie ma przypisanego procesu. Wybierz proces dla tego zlecenia.');
        return false;
      }
      
      // Find the process
      const process = (state.processes||[]).find(p => p.id === order.processId);
      if(!process){
        console.error('[generateTasks] Process not found:', order.processId);
        return false;
      }
      
      // Check if process has operations
      if(!process.operations || process.operations.length === 0){
        console.warn('[generateTasks] Process has no operations:', process.name);
        alert('Proces "' + process.name + '" nie ma zdefiniowanych operacji.');
        return false;
      }
      
      // Remove existing tasks for this order (clean slate)
      const existingTasks = (state.tasks||[]).filter(t => t.orderId === orderId);
      if(existingTasks.length > 0){
        console.log('[generateTasks] Removing', existingTasks.length, 'existing tasks for order', orderId);
        state.tasks = (state.tasks||[]).filter(t => t.orderId !== orderId);
      }
      
      // Generate new tasks from process operations
      let tasksCreated = 0;
      (process.operations||[]).forEach((op, idx) => {
        const taskId = uid();
        const task = {
          id: taskId,
          orderId: orderId,
          opId: op.id || op.no,
          opIndex: idx, // ⭐ Position in process - needed for dependencies!
          opName: op.name || 'Operacja ' + (idx + 1),
          status: 'todo', // All tasks start as 'todo'
          estMin: op.time || 60, // Estimated time in minutes
          elapsedMin: 0,
          assignees: [], // Will be assigned later
          createdAt: new Date().toISOString()
        };
        
        state.tasks = state.tasks || [];
        state.tasks.push(task);
        tasksCreated++;
      });
      
      console.log('[generateTasks] Created', tasksCreated, 'tasks for order', order.name);
      
      // Save and refresh UI
      save();
      try{
        renderTasks();
        renderOrderPage && renderOrderPage();
        renderGantt && renderGantt();
      }catch(e){
        console.error('[generateTasks] Error refreshing UI:', e);
      }
      
      return true;
    }catch(e){
      console.error('[generateTasks] Error:', e && e.message);
      return false;
    }
  }

  // Change task status (todo → run → done)
  function changeTaskStatus(taskId, newStatus){
    try{
      console.log('[changeTaskStatus] Changing task', taskId, 'to status:', newStatus);
      
      // Validate status
      const validStatuses = ['todo', 'run', 'done'];
      if(!validStatuses.includes(newStatus)){
        console.error('[changeTaskStatus] Invalid status:', newStatus);
        return false;
      }
      
      // Find the task
      const task = (state.tasks||[]).find(t => t.id === taskId);
      if(!task){
        console.error('[changeTaskStatus] Task not found:', taskId);
        return false;
      }
      
      const oldStatus = task.status;
      task.status = newStatus;
      
      // Update timestamp
      task.lastStatusChange = new Date().toISOString();
      
      // If marking as 'run', set start time
      if(newStatus === 'run' && !task.startedAt){
        task.startedAt = new Date().toISOString();
      }
      
      // If marking as 'done', set completion time
      if(newStatus === 'done' && !task.completedAt){
        task.completedAt = new Date().toISOString();
        // Set elapsed time = estimated time if not already set
        if(!task.elapsedMin || task.elapsedMin === 0){
          task.elapsedMin = task.estMin || 0;
        }
      }
      
      console.log('[changeTaskStatus] Task', taskId, 'status changed from', oldStatus, 'to', newStatus);
      
      // Save and refresh UI
      save();
      try{
        renderTasks();
        renderOrderPage && renderOrderPage();
        renderGantt && renderGantt();
        updateOrderProgress && updateOrderProgress(task.orderId);
      }catch(e){
        console.error('[changeTaskStatus] Error refreshing UI:', e);
      }
      
      // Check if order can be auto-completed
      if(newStatus === 'done'){
        setTimeout(() => {
          const order = (state.orders||[]).find(o => o.id === task.orderId);
          if(order){
            const allTasks = (state.tasks||[]).filter(t => t.orderId === task.orderId);
            const allDone = allTasks.length > 0 && allTasks.every(t => t.status === 'done');
            if(allDone){
              console.log('[changeTaskStatus] All tasks done for order', task.orderId, '- consider completing order');
              // Could show notification or auto-complete
            }
          }
        }, 100);
      }
      
      return true;
    }catch(e){
      console.error('[changeTaskStatus] Error:', e && e.message);
      return false;
    }
  }

  // Complete/close an order
  function completeOrder(orderId){
    try{
      console.log('[completeOrder] Completing order:', orderId);
      
      // Find the order
      const order = (state.orders||[]).find(o => o.id === orderId);
      if(!order){
        console.error('[completeOrder] Order not found:', orderId);
        return false;
      }
      
      // Check if all tasks are done
      const orderTasks = (state.tasks||[]).filter(t => t.orderId === orderId);
      if(orderTasks.length === 0){
        console.warn('[completeOrder] Order has no tasks:', orderId);
      }else{
        const incompleteTasks = orderTasks.filter(t => t.status !== 'done');
        if(incompleteTasks.length > 0){
          console.warn('[completeOrder] Order has', incompleteTasks.length, 'incomplete tasks');
          const confirmMsg = 'Zlecenie "' + order.name + '" ma ' + incompleteTasks.length + ' niedokończonych zadań.\n\nCzy na pewno chcesz zamknąć to zlecenie?';
          if(!confirm(confirmMsg)){
            return false;
          }
        }
      }
      
      // Mark order as completed
      order.status = 'completed';
      order.completedAt = new Date().toISOString();
      
      // Mark all tasks as done (if not already)
      orderTasks.forEach(task => {
        if(task.status !== 'done'){
          task.status = 'done';
          task.completedAt = task.completedAt || new Date().toISOString();
        }
      });
      
      // Release warehouse reservations (optional)
      try{
        if(window.warehouseReservations && Array.isArray(window.warehouseReservations)){
          const orderReservations = window.warehouseReservations.filter(r => r.orderId === orderId);
          if(orderReservations.length > 0){
            console.log('[completeOrder] Releasing', orderReservations.length, 'warehouse reservations');
            // Mark reservations as fulfilled
            orderReservations.forEach(res => {
              res.status = 'fulfilled';
              res.fulfilledAt = new Date().toISOString();
            });
          }
        }
      }catch(e){
        console.warn('[completeOrder] Error releasing reservations:', e);
      }
      
      console.log('[completeOrder] Order', order.name, 'marked as completed');
      
      // Save and refresh UI
      save();
      try{
        renderOrderPage && renderOrderPage();
        renderTasks && renderTasks();
        renderGantt && renderGantt();
        renderDashboard && renderDashboard();
      }catch(e){
        console.error('[completeOrder] Error refreshing UI:', e);
      }
      
      alert('Zlecenie "' + order.name + '" zostało zamknięte.');
      return true;
    }catch(e){
      console.error('[completeOrder] Error:', e && e.message);
      return false;
    }
  }

  function generateTasksByWorker(){
    showReportsProgress(true, 'Przetwarzanie danych pracowników...', 20);
    
    setTimeout(() => {
      const container = qs('#tasks-by-worker'); if(!container) return;
      container.innerHTML = '';
      (window.logDev||console.log)('[generateTasksByWorker] start');
      const map = new Map();
      const empLookup = new Map((state.employees||[]).map(e=>[e.id, e]));
      
      showReportsProgress(true, 'Analizowanie zadań...', 40);
      
      setTimeout(() => {
        showReportsProgress(true, 'Przetwarzanie zadań...', 60);
        
        setTimeout(() => {
          // Pokaż tylko aktywne zadania (te które są w state.tasks)
          (state.tasks||[]).forEach(t=>{
            const order = (state.orders||[]).find(o => o.id === t.orderId);
            // Pokaż zadanie tylko jeśli ma przypisanych pracowników i jest powiązane z aktywnym zleceniem
            if (order) {
              // Support multiple formats: assignees array, assignee object, or employeeId (for assembly tasks)
              let as = t.assignees || (t.assignee ? [t.assignee] : []);
              // If no assignees, check for employeeId (assembly/montaż tasks)
              if ((!Array.isArray(as) || as.length === 0) && t.employeeId) {
                as = [t.employeeId];
              }
              if (Array.isArray(as) && as.length) {
                as.forEach(a => {
                  const id = a.id || a;
                  const name = a.name || (empLookup.get(id)||{}).name || id;
                  if (!map.has(id)) {
                    map.set(id, {id, name, tasks: []});
                  }
                  map.get(id).tasks.push({
                    orderId: t.orderId,
                    orderName: order.name,
                    opName: t.opName || t.name || 'Zadanie',
                    process: order.name,
                    time: t.hours ? (t.hours * 60) : (t.estMin || t.elapsedMin || 0),
                    status: t.status || 'todo'
                  });
                });
              }
            }
          });
          
          showReportsProgress(true, 'Renderowanie wyników...', 80);
          
          setTimeout(() => {
            if(map.size===0){ container.innerHTML = '<div class="muted">Brak przypisań do pracowników (brak assignee). Upewnij się, że procesy mają przypisanych pracowników.</div>'; showReportsProgress(false); return; }
            (window.logDev||console.log)('[generateTasksByWorker] map keys', Array.from(map.keys()), 'size', map.size);
            Array.from(map.values()).sort((a,b)=>a.name.localeCompare(b.name)).forEach(w=>{
              (window.logDev||console.log)('[generateTasksByWorker] worker', w.id, w.name, 'tasks:', JSON.parse(JSON.stringify(w.tasks)));
              const card = document.createElement('div'); card.className='card';
              let listItems = '';
              try{
                listItems = w.tasks.map(t=>{
                  const orderLabel = t.orderId ? (t.orderName ? `${t.orderName} (${t.orderId})` : t.orderId) : (t.process || '-');
                  return `<li><strong>${escapeHtml(orderLabel)}</strong> — ${escapeHtml(t.opName||'(zadanie)')} <span class="muted">• ${escapeHtml(t.process||'')}</span> <span class="pill">${t.time}m</span></li>`;
                }).join('');
              }catch(err){ (window.logDev||console.log)('[generateTasksByWorker] listItems render error', err && err.message); listItems = `<li class="err">Błąd renderowania: ${err && (err.message||err)}</li>`; }
              const ul = `<ul class="emp-tasks-list" style="margin:8px 0;padding-left:18px">${listItems}</ul>`;
              card.innerHTML = `<div class="row" style="justify-content:space-between"><div><b>${w.name}</b><div class="muted">Zadań: ${w.tasks.length}</div></div><div class="row"><button class="btn" data-export-emp="${w.id}">Eksport CSV</button> <button class="btn blue" data-send-emp="${w.id}">Wyślij</button></div></div>${ul}`;
              container.appendChild(card);
              (window.logDev||console.log)('[generateTasksByWorker] appended card innerText', (container && container.innerText)? container.innerText.slice(0,200) : '<empty>');
            });
            container.querySelectorAll('[data-export-emp]').forEach(btn=>btn.addEventListener('click', ()=>{ const id = btn.getAttribute('data-export-emp'); exportCSVForEmployee(id); }));
            container.querySelectorAll('[data-send-emp]').forEach(btn=>btn.addEventListener('click', ()=>{ const id = btn.getAttribute('data-send-emp'); console.log('Wyślij clicked for emp:', id); const txt = buildEmployeeText(id); copyToClipboard(txt); // also trigger download
              const a=document.createElement('a'); const blob=new Blob([txt],{type:'text/plain'}); const url=URL.createObjectURL(blob); a.href=url; a.download = `tasks_${id}.txt`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
            }));
            
            showReportsProgress(false);
          }, 100);
        }, 100);
      }, 100);
    }, 50);
  }

  function exportCSVForEmployee(empId){
    const emp = (state.employees||[]).find(e=>e.id===empId) || {id:empId,name:empId};
    const rows = [];
    (state.processes||[]).forEach(proc=>{ (proc.operations||[]).forEach(op=>{ if(op.assignee && op.assignee.id===empId){ rows.push({employee:emp.name, process:proc.name, opName:op.name, time:op.time||0}); } }); });
    (state.tasks||[]).forEach(t=>{ const as = t.assignees || (t.assignee ? [t.assignee] : []); if(Array.isArray(as) && as.some(a=> (a.id||a) === empId)) rows.push({employee:emp.name, process: (state.orders||[]).find(o=>o.id===t.orderId)?.name || t.orderId, opName: t.opName, time: t.estMin||t.elapsedMin||0}); });
    if(rows.length===0){ alert('Brak zadań dla pracownika: '+emp.name); return; }
    const csv = ['employee,process,operation,timeMin'].concat(rows.map(r=>`"${(r.employee||'').replace(/"/g,'""')}","${(r.process||'').replace(/"/g,'""')}","${(r.opName||'').replace(/"/g,'""')}",${r.time||0}`)).join('\n');
    const blob=new Blob([csv],{type:'text/csv'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='tasks_'+(emp.name.replace(/\s+/g,'_'))+'.csv'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  }

  function exportCSVAllByWorker(){
    const map = new Map(); const empLookup = new Map((state.employees||[]).map(e=>[e.id,e]));
    (state.processes||[]).forEach(proc=>{ (proc.operations||[]).forEach(op=>{ if(op.assignee && op.assignee.id){ const id=op.assignee.id; if(!map.has(id)) map.set(id,[]); map.get(id).push({process:proc.name,opName:op.name,time:op.time||0}); } }); });
    (state.tasks||[]).forEach(t=>{ const as = t.assignees || (t.assignee ? [t.assignee] : []); if(Array.isArray(as)) as.forEach(a=>{ const id=a.id||a; if(!map.has(id)) map.set(id,[]); map.get(id).push({process: (state.orders||[]).find(o=>o.id===t.orderId)?.name || t.orderId, opName:t.opName, time:t.estMin||t.elapsedMin||0}); }); });
    if(map.size===0){ alert('Brak przypisań do eksportu.'); return; }
    const rows=[]; map.forEach((tasks,id)=>{ const name=(state.employees||[]).find(e=>e.id===id)?.name || id; tasks.forEach(t=>rows.push({employee:name,process:t.process,opName:t.opName,time:t.time})); });
    const csv = ['employee,process,operation,timeMin'].concat(rows.map(r=>`"${(r.employee||'').replace(/"/g,'""')}","${(r.process||'').replace(/"/g,'""')}","${(r.opName||'').replace(/"/g,'""')}",${r.time||0}`)).join('\n');
    const blob=new Blob([csv],{type:'text/csv'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='tasks_by_employee.csv'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  }

  const tasksGenBtn = qs('#tasks-gen-by-emp'); if(tasksGenBtn){ tasksGenBtn.addEventListener('click', ()=>{ generateTasksByWorker(); }); }
  const tasksExportAllBtn = qs('#tasks-export-csv-by-emp'); if(tasksExportAllBtn){ tasksExportAllBtn.addEventListener('click', ()=>{ exportCSVAllByWorker(); }); }
  const tasksShowByEmpBtn = qs('#tasks-show-by-emp'); if(tasksShowByEmpBtn){ tasksShowByEmpBtn.addEventListener('click', ()=>{
    state.uiShowTasksByEmpTable = !state.uiShowTasksByEmpTable;
    if(state.uiShowTasksByEmpTable){ tasksShowByEmpBtn.textContent = 'Ukryj podział'; generateTasksByWorker(); }
    else { tasksShowByEmpBtn.textContent = 'Pokaż podział'; const byW = qs('#tasks-by-worker'); if(byW) byW.innerHTML = ''; }
  }); }
  const tasksFilterOrder = qs('#tasks-filter-order'); if(tasksFilterOrder){ tasksFilterOrder.addEventListener('change', ()=>{ renderTasks(); }); }
  const tasksFilterStatus = qs('#tasks-filter-status'); if(tasksFilterStatus){ tasksFilterStatus.addEventListener('change', ()=>{ renderTasks(); }); }

  function renderEmployees(){ const tb=qs('#emp-tb'); tb.innerHTML=''; (state.employees||[]).forEach(e=>{ const tr=document.createElement('tr'); tr.innerHTML='<td>'+e.name+'</td><td>'+(e.cap||100)+'</td><td>'+(e.hoursPerDay||8)+'</td><td><button class="btn" data-emp-ed="'+e.id+'">Edytuj</button> <button class="btn red" data-emp-del="'+e.id+'">Usuń</button></td>'; tb.appendChild(tr); } ); }

  // Function to restore authentic data
  function restoreAuthenticData() {
    const authenticData = {
      "storage": {
        "mode": "firebase",
        "appId": "doors-demo",
        "userId": "hala-1",
        "fbConfig": {
          "apiKey": "AIzaSyD93UqqsHWoAUBV7g8OVKAnajIfGDX_ZdY",
          "authDomain": "doors-planner.firebaseapp.com",
          "projectId": "doors-planner",
          "storageBucket": "doors-planner.appspot.com",
          "messagingSenderId": "513098608067",
          "appId": "1:513098608067:web:1fe3855b3470ca7ef22176"
        },
        "autoSaveAssign": true,
        "spellcheckEnforce": true
      },
      "employees": [
        {"id": "emp1", "name": "Jan Kowalski", "cap": 100, "hoursPerDay": 8},
        {"id": "emp2", "name": "Anna Nowak", "cap": 90, "hoursPerDay": 8},
        {"id": "emp3", "name": "Piotr Wiśniewski", "cap": 95, "hoursPerDay": 8},
        {"id": "emp4", "name": "Maria Zielińska", "cap": 85, "hoursPerDay": 8}
      ],
      "operationsCatalog": [
        {"id": "mg9t6hiit3at", "no": 1, "name": "Frezowanie na CNC (belki futryny)", "time": 40, "workers": 1, "skills": ["CNC", "belki"], "defaultAssignees": []},
        {"id": "mg9t6hii3w84", "no": 2, "name": "Sklejanie belek (futryna)", "time": 20, "workers": 1, "skills": ["sklejanie", "belki"], "defaultAssignees": []},
        {"id": "mg9t6hiije0t", "no": 3, "name": "Kontrola wymiarów (futryna)", "time": 10, "workers": 1, "skills": ["kontrola"], "defaultAssignees": []},
        {"id": "mg9t6hiinhp6", "no": 4, "name": "Szlifowanie (futryna)", "time": 15, "workers": 1, "skills": ["szlifowanie"], "defaultAssignees": []},
        {"id": "mg9t6hii8h6d", "no": 5, "name": "Szczotkowanie (futryna)", "time": 12, "workers": 1, "skills": ["szczotkowanie"], "defaultAssignees": []},
        {"id": "mg9t6hii22fy", "no": 6, "name": "Malowanie (futryna)", "time": 30, "workers": 1, "skills": ["malowanie"], "defaultAssignees": []},
        {"id": "mg9t6hii8c9m", "no": 7, "name": "Okuwanie (futryna)", "time": 8, "workers": 1, "skills": ["okucia"], "defaultAssignees": []},
        {"id": "mg9t6hii16mh", "no": 8, "name": "Wycięcie belek pod skrzydło", "time": 35, "workers": 1, "skills": ["CNC", "belki"], "defaultAssignees": []},
        {"id": "mg9t6hiibhu3", "no": 9, "name": "Sklejenie belek (skrzydło)", "time": 20, "workers": 1, "skills": ["sklejanie", "belki"], "defaultAssignees": []},
        {"id": "mg9t6hii82z6", "no": 10, "name": "Wycięcie sklejki", "time": 25, "workers": 1, "skills": ["sklejka"], "defaultAssignees": []},
        {"id": "mg9t6hii6g4a", "no": 11, "name": "Przygotowanie forniru", "time": 18, "workers": 1, "skills": ["fornir"], "defaultAssignees": []},
        {"id": "mg9t6hiibgls", "no": 12, "name": "Fornirowanie", "time": 30, "workers": 1, "skills": ["fornirowanie"], "defaultAssignees": []},
        {"id": "mg9t6hii482o", "no": 13, "name": "Przygotowanie rurek pod elektronikę", "time": 12, "workers": 1, "skills": ["elektronika"], "defaultAssignees": []},
        {"id": "mg9t6hiiy42w", "no": 14, "name": "Montaż rurek pod elektronikę", "time": 18, "workers": 1, "skills": ["elektronika"], "defaultAssignees": []},
        {"id": "mg9t6hiil5zr", "no": 15, "name": "Przycięcie poprzeczek", "time": 10, "workers": 1, "skills": ["poprzeczki"], "defaultAssignees": []},
        {"id": "mg9t6hii01mz", "no": 16, "name": "Montaż poprzeczek", "time": 12, "workers": 1, "skills": ["poprzeczki"], "defaultAssignees": []},
        {"id": "mg9t6hii5ucc", "no": 17, "name": "Przycięcie styropianu", "time": 5, "workers": 1, "skills": ["styropian"], "defaultAssignees": []},
        {"id": "mg9t6hiihdry", "no": 18, "name": "Montaż styropianu", "time": 8, "workers": 1, "skills": ["styropian"], "defaultAssignees": []},
        {"id": "mg9t6hii55mz", "no": 19, "name": "Przycięcie naciągu", "time": 6, "workers": 1, "skills": ["naciag"], "defaultAssignees": []},
        {"id": "mg9t6hiiuh2p", "no": 20, "name": "Montaż naciągu", "time": 8, "workers": 1, "skills": ["naciag"], "defaultAssignees": []},
        {"id": "mg9t6hii8dmo", "no": 21, "name": "Sklejanie w prasie", "time": 25, "workers": 1, "skills": ["prasa"], "defaultAssignees": []},
        {"id": "mg9t6hii2y8d", "no": 22, "name": "Frezowanie na CNC (skrzydło)", "time": 40, "workers": 1, "skills": ["CNC"], "defaultAssignees": []},
        {"id": "mg9t6hiisdiv", "no": 23, "name": "Szlifowanie (skrzydło)", "time": 15, "workers": 1, "skills": ["szlifowanie"], "defaultAssignees": []},
        {"id": "mg9t6hiiz9js", "no": 24, "name": "Szczotkowanie (skrzydło)", "time": 12, "workers": 1, "skills": ["szczotkowanie"], "defaultAssignees": []},
        {"id": "mg9t6hiimtpd", "no": 25, "name": "Malowanie (skrzydło)", "time": 30, "workers": 1, "skills": ["malowanie"], "defaultAssignees": []},
        {"id": "mg9t6hii642n", "no": 26, "name": "Okuwanie (skrzydło)", "time": 8, "workers": 1, "skills": ["okucia"], "defaultAssignees": []},
        {"id": "mg9t6hii5mri", "no": 27, "name": "Przygotowanie zestawu do drzwi", "time": 10, "workers": 1, "skills": ["zestaw"], "defaultAssignees": []},
        {"id": "mg9t6hii942t", "no": 28, "name": "Przygotowanie antaby", "time": 8, "workers": 1, "skills": ["antaba"], "defaultAssignees": []},
        {"id": "mg9t6hiihf4q", "no": 29, "name": "Zamówienie szyb", "time": 5, "workers": 1, "skills": ["szyby"], "defaultAssignees": []},
        {"id": "mg9t6hii6goh", "no": 30, "name": "Malowanie szyb", "time": 15, "workers": 1, "skills": ["szyby", "malowanie"], "defaultAssignees": []},
        {"id": "mg9t6hii6fl4", "no": 31, "name": "Klejenie szyb", "time": 20, "workers": 1, "skills": ["szyby", "klejenie"], "defaultAssignees": []},
        {"id": "mg9t6hii96bh", "no": 32, "name": "Polerowanie zamków i wypalenie logo", "time": 12, "workers": 1, "skills": ["zamki", "polerowanie"], "defaultAssignees": []},
        {"id": "mg9t6hiidt0v", "no": 33, "name": "Wymiary szyby (szer, H)", "time": 4, "workers": 1, "skills": ["szyby", "wymiary"], "defaultAssignees": []},
        {"id": "mg9t6hiig5mf", "no": 34, "name": "Wycięcie belek pod futrynę", "time": 10, "workers": 1, "skills": [], "defaultAssignees": []},
        {"id": "mg9t6hii5uvr", "no": 35, "name": "Frezowanie na CNC 40 m", "time": 10, "workers": 1, "skills": [], "defaultAssignees": []},
        {"id": "mg9t6hiilbtt", "no": 36, "name": "Sklejanie belek", "time": 10, "workers": 1, "skills": [], "defaultAssignees": []},
        {"id": "mg9t6hijxejj", "no": 37, "name": "Kontrola wymiarów", "time": 10, "workers": 1, "skills": [], "defaultAssignees": []},
        {"id": "mg9t6hijmycx", "no": 38, "name": "Szlifowanie", "time": 10, "workers": 1, "skills": [], "defaultAssignees": []},
        {"id": "mg9t6hijmp8a", "no": 39, "name": "Szczotkowanie", "time": 10, "workers": 1, "skills": [], "defaultAssignees": []},
        {"id": "mg9t6hijkvs2", "no": 40, "name": "Malowanie", "time": 10, "workers": 1, "skills": [], "defaultAssignees": []},
        {"id": "mg9t6hijdgql", "no": 41, "name": "Okuwanie", "time": 10, "workers": 1, "skills": [], "defaultAssignees": []},
        {"id": "mg9t6hijx585", "no": 42, "name": "Sklejenie belek", "time": 10, "workers": 1, "skills": [], "defaultAssignees": []},
        {"id": "mg9t6hijwq00", "no": 43, "name": "Przygotowanie forniru zgodnie z zamówieniem", "time": 10, "workers": 1, "skills": [], "defaultAssignees": []},
        {"id": "mg9t6hijh68k", "no": 44, "name": "Frezowanie na CNC", "time": 10, "workers": 1, "skills": [], "defaultAssignees": []}
      ],
      "processes": [
        {"id": "mg9t6hiieyao", "name": "Proces: Futryna", "operations": [{"name": "Frezowanie na CNC (belki futryny)", "time": 40}, {"name": "Sklejanie belek (futryna)", "time": 20}, {"name": "Kontrola wymiarów (futryna)", "time": 10}, {"name": "Szlifowanie (futryna)", "time": 15}, {"name": "Szczotkowanie (futryna)", "time": 12}, {"name": "Malowanie (futryna)", "time": 30}, {"name": "Okuwanie (futryna)", "time": 8}]},
        {"id": "mg9t6hiiffge", "name": "Proces: Skrzydło", "operations": [{"name": "Wycięcie belek pod skrzydło", "time": 35}, {"name": "Sklejenie belek (skrzydło)", "time": 20}, {"name": "Wycięcie sklejki", "time": 25}, {"name": "Fornirowanie", "time": 30}, {"name": "Frezowanie na CNC (skrzydło)", "time": 40}, {"name": "Szlifowanie (skrzydło)", "time": 15}, {"name": "Malowanie (skrzydło)", "time": 30}, {"name": "Okuwanie (skrzydło)", "time": 8}]},
        {"id": "mg9t6hiiuztd", "name": "Proces: Drzwi kompletne", "operations": [{"name": "Frezowanie na CNC (belki futryny)", "time": 40}, {"name": "Sklejanie belek (futryna)", "time": 20}, {"name": "Wycięcie belek pod skrzydło", "time": 35}, {"name": "Sklejenie belek (skrzydło)", "time": 20}, {"name": "Sklejanie w prasie", "time": 25}, {"name": "Fornirowanie", "time": 30}, {"name": "Malowanie (skrzydło)", "time": 30}, {"name": "Okuwanie (skrzydło)", "time": 8}]}
      ],
      "orders": [],
      "tasks": [
        {"id": "task1", "orderId": "order1", "opName": "Przygotowanie surowców", "status": "todo", "elapsedMin": 0, "estMin": 120, "assignees": [{"id": "emp1"}]},
        {"id": "task2", "orderId": "order1", "opName": "Cięcie drewna", "status": "run", "elapsedMin": 45, "estMin": 90, "assignees": [{"id": "emp2"}]},
        {"id": "task3", "orderId": "order1", "opName": "Szlifowanie", "status": "todo", "elapsedMin": 0, "estMin": 60, "assignees": [{"id": "emp3"}]},
        {"id": "task4", "orderId": "order2", "opName": "Montaż futryny", "status": "todo", "elapsedMin": 0, "estMin": 180, "assignees": [{"id": "emp1"}, {"id": "emp4"}]},
        {"id": "task5", "orderId": "order2", "opName": "Malowanie", "status": "todo", "elapsedMin": 0, "estMin": 150, "assignees": [{"id": "emp2"}]},
        {"id": "task6", "orderId": "order3", "opName": "Wykończenie", "status": "done", "elapsedMin": 200, "estMin": 200, "assignees": [{"id": "emp3"}]}
      ],
      "after": [],
      "PROC_TMP": [],
      "page": "gantt",
      "_timers": {},
      "uiShowTasksByEmpTable": false,
      "settings": {"autoCleanup": true}
    };

    // Restore the data
    Object.assign(state, authenticData);
    localStorage.setItem(storeKey, JSON.stringify(state));

    // Refresh all views
    renderEmployees();
    renderOps();
    renderProcPage();
    renderOrderPage();
    renderTasks();
    renderGantt();
    renderCapacityAnalysis();

    alert('✅ Przywrócono autentyczne dane!\n\nTwoje dane zostały odzyskane z backupu.');
  }

  // Zmienna do przechowywania zaznaczonego zadania
  let selectedGanttTaskId = null;

  function selectGanttTask(taskId, taskData, employeeName) {
    // Odznacz poprzednie zadanie
    const prevSelected = qs('.gantt-task.selected');
    if (prevSelected) {
      prevSelected.classList.remove('selected');
    }

    // Zaznacz nowe zadanie
    selectedGanttTaskId = taskId;
    const taskEl = qs(`.gantt-task[data-task-id="${taskId}"]`);
    if (taskEl) {
      taskEl.classList.add('selected');
    }

    // Aktualizuj informacje o zaznaczonym zadaniu
    const infoEl = qs('#gantt-selected-task-info');
    if (infoEl) {
      const taskName = taskData.opName || taskData.name || 'Zadanie';
      const taskDate = taskData.startPlanned ? new Date(taskData.startPlanned).toLocaleDateString('pl-PL') : 'Brak daty';
      infoEl.textContent = `${taskName} (${employeeName}) - ${taskDate}`;
    }

    // Włącz przyciski
    qs('#gantt-move-task-back').disabled = false;
    qs('#gantt-move-task-forward').disabled = false;
    qs('#gantt-clear-selection').disabled = false;
  }

  function clearGanttTaskSelection() {
    selectedGanttTaskId = null;
    const prevSelected = qs('.gantt-task.selected');
    if (prevSelected) {
      prevSelected.classList.remove('selected');
    }

    const infoEl = qs('#gantt-selected-task-info');
    if (infoEl) {
      infoEl.textContent = 'Brak';
    }

    // Wyłącz przyciski
    qs('#gantt-move-task-back').disabled = true;
    qs('#gantt-move-task-forward').disabled = true;
    qs('#gantt-clear-selection').disabled = true;
  }

  function moveSelectedTask(days) {
    if (!selectedGanttTaskId) return;

    const task = state.tasks.find(t => t.id === selectedGanttTaskId);
    if (!task || !task.startPlanned) return;

    // Przesuń datę początkową
    const newStart = task.startPlanned + (days * 24 * 60 * 60 * 1000);
    task.startPlanned = newStart;

    // Przesuń datę końcową jeśli istnieje
    if (task.endPlanned) {
      const duration = task.endPlanned - task.startPlanned;
      task.endPlanned = newStart + duration;
    }

    // Zapisz i odśwież
    save();
    renderGantt();

    // Ponownie zaznacz zadanie po przerenderowaniu
    const taskEl = qs(`.gantt-task[data-task-id="${selectedGanttTaskId}"]`);
    if (taskEl) {
      const emp = state.employees?.find(e => {
        const empTasks = state.tasks.filter(t => {
          let a = t.assignees || (t.assignee ? [t.assignee] : []);
          if ((!Array.isArray(a) || a.length === 0) && t.employeeId) {
            a = [t.employeeId];
          }
          return a.some(assignee => (assignee.id || assignee) === e.id);
        });
        return empTasks.some(t => t.id === selectedGanttTaskId);
      });
      selectGanttTask(selectedGanttTaskId, task, emp?.name || '(Niezaplanowane)');
    }
  }

  function renderGantt(){
    const container = qs('#gantt-container');
    if(!container) {
      console.error('Gantt container not found');
      return;
    }

    console.log('🎨 Rendering Gantt chart...');

    // Ensure container is visible for width calculations
    const wasHidden = container.closest('.hidden');
    if(wasHidden) {
      container.style.visibility = 'hidden';
      container.style.position = 'absolute';
      container.style.display = 'block';
    }

    const viewMode = qs('#gantt-view').value || 'week';
    const daysCount = viewMode === 'week' ? 7 : 30;
    
    // Inicjalizuj offset dat jeśli nie istnieje
    if(typeof state.ganttDateOffset === 'undefined') {
      state.ganttDateOffset = 0;
    }
    
    // Znajdź bazową datę (najwcześniejsze zadanie lub dzisiaj)
    const now = new Date(); // Aktualna data z godzinami
    const today = new Date();
    today.setHours(0,0,0,0);
    let baseDate = new Date(today);
    (state.tasks||[]).forEach(t => {
      if(t.startPlanned && t.startPlanned < baseDate.getTime()) {
        baseDate = new Date(t.startPlanned);
        baseDate.setHours(0,0,0,0);
      }
    });
    
    // Zaokrąglij do początku tygodnia (niedziela)
    baseDate.setDate(baseDate.getDate() - baseDate.getDay());
    
    // Zastosuj offset (przesunięcie w dniach)
    const startDate = new Date(baseDate);
    startDate.setDate(baseDate.getDate() + state.ganttDateOffset);
    
    console.log('Gantt: baseDate:', baseDate.toISOString().slice(0,10), 'offset:', state.ganttDateOffset, 'startDate:', startDate.toISOString().slice(0,10));

    // Generate timeline header
    const timelineEl = qs('#gantt-timeline');
    timelineEl.innerHTML = '';

    for(let i = 0; i < daysCount; i++){
      const date = new Date(startDate);
      date.setDate(startDate.getDate() + i);
      const dayEl = document.createElement('div');
      dayEl.className = 'gantt-time-slot';
      
      // Format daty z nazwą miesiąca
      const dayName = date.toLocaleDateString('pl-PL', {weekday: 'short'});
      const dayNumber = date.getDate();
      const monthName = date.toLocaleDateString('pl-PL', {month: 'short'});
      
      // W widoku tygodniowym pokaż dzień tygodnia + datę + miesiąc
      // W widoku miesięcznym pokaż tylko datę + miesiąc
      if (viewMode === 'week') {
        dayEl.innerHTML = `<div style="font-size:10px">${dayName}</div><div style="font-weight:600">${dayNumber} ${monthName}</div>`;
      } else {
        dayEl.innerHTML = `<div style="font-size:10px;font-weight:600">${dayNumber}</div><div style="font-size:9px">${monthName}</div>`;
      }
      
      if(date.toDateString() === now.toDateString()){
        dayEl.style.background = 'rgba(239, 68, 68, 0.1)';
        dayEl.style.borderRight = '2px solid #ef4444';
      }
      timelineEl.appendChild(dayEl);
    }

    // Generate resource rows
    const bodyEl = qs('#gantt-body');
    bodyEl.innerHTML = '';

    // Re-add dependencies SVG layer if not exists
    let svg = qs('#gantt-dependencies');
    if (!svg) {
      svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.id = 'gantt-dependencies';
      svg.className = 'gantt-dependency';
      svg.style.cssText = 'position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10;';
      bodyEl.appendChild(svg);
    } else {
      // Clear existing dependencies and ensure correct z-index
      svg.innerHTML = '';
      svg.style.zIndex = '10';
    }

    // Get container width for calculations
    const containerWidth = container.offsetWidth || 1000; // Fallback width
    const timelineWidth = containerWidth - 200;

    console.log('Container width:', containerWidth, 'Timeline width:', timelineWidth);

    // Migracja / uzupełnienie pól z nowego generatora (jeśli jeszcze nie zrobiona)
    (state.tasks||[]).forEach(t=>{
      if(typeof t.status === 'undefined') t.status='todo';
      if(!t.opName) t.opName = t.name || t.operationId || 'Zadanie';
      if(typeof t.estMin === 'undefined') t.estMin = t.duration || 0;
      if(!Array.isArray(t.assignees)) t.assignees = [];
    });

    // Nie przeliczaj automatycznie w widoku Gantt

  console.log('[gantt] state.tasks total=', (state.tasks||[]).length);
  // Group tasks by employee (tylko te które mają przypisania)
    const tasksByEmployee = new Map();
    const allTasks = (state.tasks || []).slice();
    allTasks.forEach(task => {
      let assignees = task.assignees || (task.assignee ? [task.assignee] : []);
      // Support employeeId for assembly/montaż tasks
      if ((!Array.isArray(assignees) || assignees.length === 0) && task.employeeId) {
        assignees = [task.employeeId];
      }
      if(assignees && assignees.length){
        assignees.forEach(assignee => {
          const empId = assignee.id || assignee;
            if(!tasksByEmployee.has(empId)) tasksByEmployee.set(empId, []);
            tasksByEmployee.get(empId).push(task);
        });
      }
    });

    const unassigned = allTasks.filter(t=>{
      let a = t.assignees || (t.assignee?[t.assignee]:[]);
      // Support employeeId for assembly/montaż tasks
      if ((!Array.isArray(a) || a.length === 0) && t.employeeId) {
        a = [t.employeeId];
      }
      return !a || a.length===0;
    });
    console.log('[gantt] employees=', (state.employees||[]).length, 'withAssignedRows=', tasksByEmployee.size, 'unassigned=', unassigned.length);
    if(!(state.employees||[]).length && unassigned.length){
      // Fallback: sztuczny pracownik aby zobaczyć zadania
      console.warn('[gantt] Brak pracowników – renderuję wszystkie jako (Niezaplanowane)');
    }

    // Add rows for each employee
    (state.employees || []).forEach(employee => {
      const rowEl = document.createElement('div');
      rowEl.className = 'gantt-row';

      const resourceCell = document.createElement('div');
      resourceCell.className = 'gantt-resource-cell';
      resourceCell.textContent = employee.name;
      rowEl.appendChild(resourceCell);

      const taskCell = document.createElement('div');
      taskCell.className = 'gantt-task-cell';
      taskCell.setAttribute('data-employee-id', employee.id);

      // Add tasks for this employee - time-based positioning
      const employeeTasks = tasksByEmployee.get(employee.id) || [];
      console.log('Employee', employee.name, 'has', employeeTasks.length, 'tasks');

      // Calculate slot width dynamically based on view mode
      const slotWidth = timelineWidth / daysCount;
      console.log('SlotWidth:', slotWidth, 'for', daysCount, 'days, timeline width:', timelineWidth);
      let renderedCount = 0;
      employeeTasks.forEach((task, taskIndex) => {
        if(!task.startPlanned) {
          console.log('Task without startPlanned:', task.id, task.opName);
          return; // Skip if no start time
        }
        renderedCount++;
        const taskEl = document.createElement('div');
        taskEl.className = `gantt-task ${task.status || 'todo'}`;
        taskEl.setAttribute('data-task-id', task.id);
        taskEl.setAttribute('data-task-id', task.id);

        // Smart text formatting for task names
        let displayName = task.opName || 'Zadanie';
        let fontSize = '11px';
        
        // Calculate task duration in days
        let durationDays = 1; // Default to 1 day
        if (task.endPlanned && task.startPlanned) {
          durationDays = Math.max(1, Math.ceil((task.endPlanned - task.startPlanned) / (24 * 3600 * 1000)));
        } else if (task.hours) {
          durationDays = Math.max(1, Math.ceil(task.hours / 8)); // 8h work day
        }
        
        // Calculate task width based on duration and slot width
        let taskWidth = Math.max(slotWidth * durationDays - 10, slotWidth * 0.8);

        // Adjust text based on available width
        if (taskWidth < 60) {
          displayName = displayName.substring(0, 3) + '...';
          fontSize = '9px';
        } else if (displayName.length > 15) {
          displayName = displayName.substring(0, Math.floor(taskWidth / 8)) + '...';
          fontSize = '10px';
        }

        taskEl.textContent = displayName;
        taskEl.style.fontSize = fontSize;
        taskEl.style.width = taskWidth + 'px';
        taskEl.style.position = 'absolute';

        // Calculate position based on start date
        const taskDate = new Date(task.startPlanned);
        const daysDiff = Math.floor((taskDate - startDate) / (24 * 3600 * 1000));
        const leftPos = daysDiff * slotWidth + 5;
        taskEl.style.left = leftPos + 'px';

        console.log('Task:', displayName, 'start:', taskDate.toISOString().slice(0,10), 'startDate:', startDate.toISOString().slice(0,10), 'daysDiff:', daysDiff, 'leftPos:', leftPos);

        // Enhanced tooltip with full name
        taskEl.title = `${task.opName || 'Zadanie'}\nStatus: ${task.status || 'todo'}\nCzas: ${task.estMin || 60}min\nPracownik: ${employee.name}`;

        // Obsługa zaznaczania zadania
        taskEl.addEventListener('click', (e) => {
          e.stopPropagation();
          selectGanttTask(task.id, task, employee.name);
        });

        taskCell.appendChild(taskEl);
      });
      console.log('Rendered', renderedCount, 'tasks for', employee.name);

      rowEl.appendChild(taskCell);
      bodyEl.appendChild(rowEl);
    });

    // Row for unassigned tasks
  if(unassigned.length){
      const rowEl = document.createElement('div');
      rowEl.className = 'gantt-row';
      const resourceCell = document.createElement('div');
      resourceCell.className = 'gantt-resource-cell';
      resourceCell.textContent = '(Niezaplanowane)';
      rowEl.appendChild(resourceCell);
      const taskCell = document.createElement('div');
      taskCell.className = 'gantt-task-cell';
      // Use dynamic slot width based on view mode
      const slotWidth = timelineWidth / daysCount;
      let renderedUnassigned = 0;
      unassigned.slice(0,250).forEach(task=>{
        if(!task.startPlanned) {
          console.log('Unassigned task without startPlanned:', task.id, task.opName);
          return;
        }
        renderedUnassigned++;
        const taskEl = document.createElement('div');
        taskEl.className = `gantt-task ${task.status || 'todo'} unassigned`;
        taskEl.setAttribute('data-task-id', task.id);
        
        // Calculate task duration in days
        let durationDays = 1;
        let dur = 0;  // Deklaracja tutaj, aby była dostępna w całej funkcji
        
        if (task.endPlanned && task.startPlanned) {
          durationDays = Math.max(1, Math.ceil((task.endPlanned - task.startPlanned) / (24 * 3600 * 1000)));
          dur = durationDays * 8 * 60;  // Przybliżony czas w minutach
        } else if (task.hours) {
          durationDays = Math.max(1, Math.ceil(task.hours / 8));
          dur = task.hours * 60;  // Godziny na minuty
        } else {
          dur = task.estMin || task.duration || 0;
          durationDays = Math.max(1, Math.ceil(dur / (8 * 60)));
        }
        
        // Calculate task width based on duration and dynamic slot width
        let taskWidth = Math.max(slotWidth * durationDays - 10, slotWidth * 0.8);
        let displayName = (task.opName || task.name || 'Zadanie');
        
        // Adjust text based on width
        if (taskWidth < 60) {
          displayName = displayName.substring(0, 3) + '...';
        } else {
          displayName = displayName.slice(0, Math.floor(taskWidth / 8));
        }
        
        taskEl.textContent = displayName;
        // Calculate position based on start date
        const taskDate = new Date(task.startPlanned);
        const daysDiff = Math.floor((taskDate - startDate) / (24 * 3600 * 1000));
        const leftPos = daysDiff * slotWidth + 5;
        taskEl.style.left = leftPos + 'px';
        taskEl.style.width = taskWidth + 'px';
        taskEl.style.position = 'absolute';
        taskEl.title = `${task.opName||task.name||'Zadanie'}\nStatus: ${task.status||'-'}\nCzas: ${dur} min`;
        
        // Obsługa zaznaczania zadania
        taskEl.addEventListener('click', (e) => {
          e.stopPropagation();
          selectGanttTask(task.id, task, '(Niezaplanowane)');
        });
        
        console.log('Unassigned task:', displayName, 'start:', taskDate.toISOString().slice(0,10), 'daysDiff:', daysDiff, 'leftPos:', leftPos);
        taskCell.appendChild(taskEl);
      });
      console.log('Rendered', renderedUnassigned, 'unassigned tasks');
      if(unassigned.length>250){
        const more = document.createElement('div');
        more.style.cssText='position:absolute;left:'+(renderedUnassigned * 50 + 10)+'px;font-size:11px;color:#94a3b8;padding:2px';
        more.textContent = '+'+(unassigned.length-250)+' ...';
        taskCell.appendChild(more);
      }
      rowEl.appendChild(taskCell);
      bodyEl.appendChild(rowEl);
    }

    // Remove ALL old current time indicators if exist
    const oldTimeIndicators = document.querySelectorAll('.gantt-current-time');
    console.log('🗑️ Removing', oldTimeIndicators.length, 'old time indicators');
    oldTimeIndicators.forEach(indicator => indicator.remove());
    
    // Add current time indicator - tylko jeśli "dzisiaj" jest w widocznym zakresie
    const todayMidnight = new Date(now);
    todayMidnight.setHours(0, 0, 0, 0);
    const daysSinceStart = Math.floor((todayMidnight - startDate) / (24 * 3600 * 1000));
    
    console.log('📍 Checking time indicator: now=', now.toLocaleString('pl-PL'), 'todayMidnight=', todayMidnight.toLocaleDateString('pl-PL'), 'startDate=', startDate.toLocaleDateString('pl-PL'), 'daysSinceStart=', daysSinceStart, 'daysCount=', daysCount);
    
    // Pokaż linię tylko jeśli dzisiaj jest w widocznym zakresie
    if (daysSinceStart >= 0 && daysSinceStart < daysCount) {
      const currentTimeEl = document.createElement('div');
      currentTimeEl.className = 'gantt-current-time';
      
      // Oblicz pozycję jako: dzień + procent godzin w dniu
      const hoursFraction = (now.getHours() * 60 + now.getMinutes()) / (24 * 60);
      const slotWidth = timelineWidth / daysCount; // Szerokość jednego dnia
      const currentTimePosition = (daysSinceStart + hoursFraction) * slotWidth;
      
      // 200px dla kolumny zasobów (timeline zaczyna się po tej kolumnie)
      currentTimeEl.style.left = (200 + currentTimePosition) + 'px';
      currentTimeEl.style.height = '100%'; // Pełna wysokość body
      currentTimeEl.style.pointerEvents = 'none'; // Nie blokuj kliknięć
      bodyEl.appendChild(currentTimeEl);
      console.log('✅ Current time indicator added at day', daysSinceStart, 'hours:', now.getHours(), 'minutes:', now.getMinutes(), 'hoursFraction:', hoursFraction.toFixed(3), 'position:', (200 + currentTimePosition).toFixed(1) + 'px', 'slotWidth:', slotWidth.toFixed(1));
    } else {
      console.log('❌ Current time indicator hidden - today not in view range');
    }

    // Restore visibility if it was hidden
    if(wasHidden) {
      container.style.visibility = '';
      container.style.position = '';
      container.style.display = '';
    }

    if(!(state.employees||[]).length && !unassigned.length){
      bodyEl.innerHTML = '<div style="padding:12px;color:#94a3b8;font-size:13px">Brak pracowników i brak zadań do wyświetlenia.</div>';
    }
    console.log('Gantt chart rendered');

    // Initialize drag & drop functionality
    initGanttDragDrop();

    // Initialize visualization state - ZAWSZE false przy renderowaniu
    // (użytkownik musi kliknąć przycisk żeby pokazać)
    if (typeof window.ganttShowDependencies === 'undefined') {
      window.ganttShowDependencies = false;
      window.ganttShowCriticalPath = false;
    }

    // Update button states
    updateGanttButtons();

    // Render dependencies if enabled - with delay to ensure DOM is fully laid out
    if (window.ganttShowDependencies) {
      setTimeout(() => renderDependencies(), 50);
    }

    // Kliknięcie w tło Gantta odznacza zadanie
    container.addEventListener('click', (e) => {
      if (e.target === container || e.target.classList.contains('gantt-task-cell') || e.target.classList.contains('gantt-body')) {
        clearGanttTaskSelection();
      }
    });
  }

  // Make functions available globally for event handlers
  window.renderGantt = renderGantt;
  window.autoAssignEmployeesToTasks = autoAssignEmployeesToTasks;

  function generateGanttTestData(){
    // Generate some test data for Gantt chart demonstration (without overwriting existing data)
    console.log('Dodaję dane testowe dla harmonogramu...');

    // Add test employees if none exist
    if((state.employees || []).length === 0){
      state.employees = [
        {id: 'emp1', name: 'Jan Kowalski'},
        {id: 'emp2', name: 'Anna Nowak'},
        {id: 'emp3', name: 'Piotr Wiśniewski'},
        {id: 'emp4', name: 'Maria Zielińska'}
      ];
    }

    // Add test orders if none exist
    if((state.orders || []).length === 0){
      state.orders = [
        {id: 'order_test_1', name: 'Drzwi wejściowe dąb', client: 'Firma ABC', model: 'Dąb Classic', quantity: 5, startDate: '2025-10-01', endDate: '2025-10-15', processId: 'proc1'},
        {id: 'order_test_2', name: 'Drzwi wewnętrzne sosna', client: 'Dom prywatny', model: 'Sosna Light', quantity: 3, startDate: '2025-09-20', endDate: '2025-10-05', processId: 'proc2'},
        {id: 'order_test_3', name: 'Drzwi balkonowe', client: 'Blok mieszkalny', model: 'Balkon Plus', quantity: 8, startDate: '2025-10-01', endDate: '2025-10-20', processId: 'proc1'}
      ];
    }

    // Add test processes if none exist
    if((state.processes || []).length === 0){
      state.processes = [
        {id: 'proc1', name: 'Proces standardowy', operations: [
          {name: 'Frezowanie na CNC', assignee: {id: 'emp1', name: 'Jan Kowalski'}},
          {name: 'Malowanie', assignee: {id: 'emp2', name: 'Anna Nowak'}},
          {name: 'Okuwanie', assignee: {id: 'emp4', name: 'Maria Zielińska'}}
        ]},
        {id: 'proc2', name: 'Proces uproszczony', operations: [
          {name: 'Szlifowanie', assignee: {id: 'emp3', name: 'Piotr Wiśniewski'}},
          {name: 'Przygotowanie powierzchni do malowania z dodatkowymi zabiegami', assignee: {id: 'emp1', name: 'Jan Kowalski'}}
        ]}
      ];
    }

    // Add test tasks (always add, don't overwrite)
    const testTasks = [
      {id: 'task_test_1', orderId: 'order_test_1', opName: 'Frezowanie na CNC (test)', status: 'run', elapsedMin: 30, estMin: 60, assignees: [{id: 'emp1', name: 'Jan Kowalski'}]},
      {id: 'task_test_2', orderId: 'order_test_1', opName: 'Malowanie (test)', status: 'todo', elapsedMin: 0, estMin: 45, assignees: [{id: 'emp2', name: 'Anna Nowak'}]},
      {id: 'task_test_3', orderId: 'order_test_2', opName: 'Szlifowanie (test)', status: 'done', elapsedMin: 25, estMin: 25, assignees: [{id: 'emp3', name: 'Piotr Wiśniewski'}]},
      {id: 'task_test_4', orderId: 'order_test_2', opName: 'Okuwanie (test)', status: 'run', elapsedMin: 15, estMin: 30, assignees: [{id: 'emp4', name: 'Maria Zielińska'}]},
      {id: 'task_test_5', orderId: 'order_test_3', opName: 'Przygotowanie powierzchni do malowania z dodatkowymi zabiegami', status: 'todo', elapsedMin: 0, estMin: 90, assignees: [{id: 'emp1', name: 'Jan Kowalski'}]}
    ];

    // Add test tasks only if they don't already exist
    testTasks.forEach(testTask => {
      if(!(state.tasks || []).some(t => t.id === testTask.id)){
        state.tasks = state.tasks || [];
        state.tasks.push(testTask);
      }
    });

    save();
    renderGantt();
    console.log('Dodano dane testowe dla harmonogramu! Oryginalne dane zostały zachowane.');
  }

  // Function to auto-assign employees to existing tasks based on processes
  function autoAssignEmployeesToTasks(){
    console.log('Auto-assigning employees to existing tasks...');
    let updatedCount = 0;

    (state.tasks || []).forEach(task => {
      // Skip if task already has assignees
      if(task.assignees && task.assignees.length > 0) return;

      // Find the order and its process
      const order = (state.orders || []).find(o => o.id === task.orderId);
      if(!order || !order.processId) return;

      const process = (state.processes || []).find(p => p.id === order.processId);
      if(!process) return;

      // Find the operation in the process
      const operation = (process.operations || []).find(op => op.name === task.opName);
      if(!operation) return;

      // Assign employee from operation
      let assignees = [];
      if(operation.assignee){
        assignees = [operation.assignee];
      } else {
        // Try to find default assignees from catalog
        const catalogOp = (state.operationsCatalog || []).find(co => co.name === operation.name);
        if(catalogOp && catalogOp.defaultAssignees && catalogOp.defaultAssignees.length > 0){
          assignees = catalogOp.defaultAssignees;
        }
      }

      if(assignees.length > 0){
        task.assignees = assignees;
        updatedCount++;
        console.log(`Assigned ${assignees.map(a => a.name || a.id).join(', ')} to task ${task.opName}`);
      }
    });

    if(updatedCount > 0){
      save();
      console.log(`Auto-assigned employees to ${updatedCount} tasks`);
    } else {
      console.log('No tasks needed auto-assignment');
    }

    renderGantt();
  }

  function renderCapacityAnalysis(){
    const period = qs('#capacity-period').value || 'week';

    // Calculate resource utilization
    const resourceUtilization = calculateResourceUtilization(period);
    renderResourceUtilization(resourceUtilization);

    // Calculate bottlenecks
    const bottlenecks = calculateBottlenecks();
    renderBottlenecks(bottlenecks);

    // Calculate efficiency metrics
    const efficiency = calculateEfficiencyMetrics(period);
    renderEfficiencyMetrics(efficiency);

    // Calculate optimization suggestions
    const optimization = calculateOptimizationSuggestions();
    renderOptimizationSuggestions(optimization);
  }

  function calculateResourceUtilization(period){
    const employees = state.employees || [];
    const tasks = state.tasks || [];
    const utilization = [];

    employees.forEach(emp => {
      const empTasks = tasks.filter(t => t.assignees && t.assignees.some(a => a.id === emp.id));
      const totalTime = empTasks.reduce((sum, t) => sum + (t.estMin || 0), 0);
      const availableTime = period === 'day' ? emp.hoursPerDay * 60 : period === 'week' ? emp.hoursPerDay * 60 * 7 : emp.hoursPerDay * 60 * 30;
      const utilizationPercent = availableTime > 0 ? Math.round((totalTime / availableTime) * 100) : 0;

      utilization.push({
        employee: emp.name,
        totalTasks: empTasks.length,
        totalTime: totalTime,
        availableTime: availableTime,
        utilization: utilizationPercent,
        status: utilizationPercent > 100 ? 'overloaded' : utilizationPercent > 80 ? 'high' : utilizationPercent > 50 ? 'normal' : 'low'
      });
    });

    return utilization;
  }

  function renderResourceUtilization(utilization){
    const container = qs('#capacity-resources');
    container.innerHTML = '';

    if(utilization.length === 0){
      container.innerHTML = '<div class="empty">Brak danych do analizy</div>';
      return;
    }

    utilization.forEach(item => {
      const div = document.createElement('div');
      div.className = 'capacity-item';
      div.innerHTML = `
        <div class="capacity-employee">${item.employee}</div>
        <div class="capacity-metrics">
          <div>Zadań: ${item.totalTasks}</div>
          <div>Czas: ${Math.round(item.totalTime / 60 * 10) / 10}h / ${Math.round(item.availableTime / 60 * 10) / 10}h</div>
          <div class="capacity-bar">
            <div class="capacity-fill ${item.status}" style="width: ${Math.min(item.utilization, 100)}%"></div>
            <span>${item.utilization}%</span>
          </div>
        </div>
      `;
      container.appendChild(div);
    });
  }

  function calculateOptimizationSuggestions(){
    const employees = state.employees || [];
    const tasks = state.tasks || [];
    const suggestions = [];

    // Calculate current workload for each employee
    const workloads = employees.map(emp => {
      const empTasks = tasks.filter(t => t.assignees && t.assignees.some(a => a.id === emp.id));
      const totalTime = empTasks.reduce((sum, t) => sum + (t.estMin || 0), 0);
      const availableTime = emp.hoursPerDay * 60 * 7; // Weekly available time
      const utilization = availableTime > 0 ? (totalTime / availableTime) * 100 : 0;

      return {
        employee: emp,
        tasks: empTasks,
        totalTime,
        availableTime,
        utilization,
        status: utilization > 100 ? 'overloaded' : utilization > 80 ? 'high' : utilization > 50 ? 'normal' : 'low'
      };
    });

    // Find overloaded employees
    const overloaded = workloads.filter(w => w.status === 'overloaded');
    if(overloaded.length > 0){
      suggestions.push({
        type: 'overload',
        priority: 'high',
        title: 'Przeładowani pracownicy',
        description: `${overloaded.map(w => w.employee.name).join(', ')} mają obciążenie >100%. Rozważ przełożenie zadań.`,
        actions: overloaded.map(w => ({
          employee: w.employee.name,
          tasksToMove: w.tasks.filter(t => t.status === 'todo').slice(0, 2)
        }))
      });
    }

    // Find underutilized employees
    const underutilized = workloads.filter(w => w.status === 'low');
    if(underutilized.length > 0){
      suggestions.push({
        type: 'underload',
        priority: 'medium',
        title: 'Niedowykorzystani pracownicy',
        description: `${underutilized.map(w => w.employee.name).join(', ')} mają obciążenie <50%. Można im przypisać więcej zadań.`,
        actions: underutilized.map(w => ({
          employee: w.employee.name,
          availableCapacity: Math.round(w.availableTime - w.totalTime)
        }))
      });
    }

    // Find skill mismatches
    const skillMismatches = [];
    tasks.forEach(task => {
      if(task.assignees && task.assignees.length > 0){
        const operation = (state.operationsCatalog || []).find(op => op.name === task.opName);
        if(operation && operation.skills && operation.skills.length > 0){
          task.assignees.forEach(assignee => {
            // For now, assume all employees can do all tasks
            // In a real system, we'd check employee skills
          });
        }
      }
    });

    // Suggest task redistribution
    const highWorkload = workloads.filter(w => w.utilization > 80);
    const lowWorkload = workloads.filter(w => w.utilization < 60);

    if(highWorkload.length > 0 && lowWorkload.length > 0){
      suggestions.push({
        type: 'redistribution',
        priority: 'medium',
        title: 'Przeniesienie zadań',
        description: `Rozważ przeniesienie zadań z ${highWorkload.map(w => w.employee.name).join(', ')} do ${lowWorkload.map(w => w.employee.name).join(', ')}`,
        actions: []
      });
    }

    // Suggest parallel processing for bottlenecks
    const bottlenecks = calculateBottlenecks();
    if(bottlenecks.length > 0){
      suggestions.push({
        type: 'parallel',
        priority: 'high',
        title: 'Przetwarzanie równoległe',
        description: `Operacje ${bottlenecks.map(b => b.operation).join(', ')} są wąskimi gardłami. Rozważ zatrudnienie dodatkowych pracowników.`,
        actions: bottlenecks.map(b => ({
          operation: b.operation,
          currentWorkers: b.countRun + b.countTodo,
          suggestedWorkers: Math.min(b.countRun + b.countTodo + 1, 3)
        }))
      });
    }

    return suggestions;
  }

  function renderOptimizationSuggestions(suggestions){
    const container = qs('#capacity-optimization');
    container.innerHTML = '';

    if(suggestions.length === 0){
      container.innerHTML = '<div class="empty">Brak sugestii optymalizacji - obciążenie jest zrównoważone! 🎉</div>';
      return;
    }

    suggestions.forEach(suggestion => {
      const div = document.createElement('div');
      div.className = `card ${suggestion.priority === 'high' ? 'err' : suggestion.priority === 'medium' ? 'warn' : ''}`;
      div.style.marginBottom = '8px';

      let actionsHtml = '';
      if(suggestion.actions && suggestion.actions.length > 0){
        actionsHtml = '<div style="margin-top: 8px;"><strong>Sugerowane działania:</strong><ul style="margin: 4px 0; padding-left: 20px;">';
        suggestion.actions.forEach(action => {
          if(action.tasksToMove){
            actionsHtml += `<li>Przenieś zadania: ${action.tasksToMove.map(t => t.opName).join(', ')} od ${action.employee}</li>`;
          } else if(action.availableCapacity){
            actionsHtml += `<li>${action.employee} ma dostępną pojemność: ${Math.round(action.availableCapacity/60)}h</li>`;
          } else if(action.suggestedWorkers){
            actionsHtml += `<li>${action.operation}: zwiększ liczbę pracowników do ${action.suggestedWorkers}</li>`;
          }
        });
        actionsHtml += '</ul></div>';
      }

      div.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: flex-start;">
          <div>
            <strong>${suggestion.title}</strong>
            <div style="margin-top: 4px; color: #94a3b8;">${suggestion.description}</div>
            ${actionsHtml}
          </div>
          <div style="font-size: 12px; color: ${suggestion.priority === 'high' ? '#ef4444' : suggestion.priority === 'medium' ? '#f59e0b' : '#10b981'}; font-weight: bold;">
            ${suggestion.priority === 'high' ? 'WYSOKI' : suggestion.priority === 'medium' ? 'ŚREDNI' : 'NISKI'}
          </div>
        </div>
      `;

      container.appendChild(div);
    });
  }

  function calculateBottlenecks(){
    const bottlenecks = [];
    const operations = state.operations || [];
    const tasks = state.tasks || [];

    operations.forEach(op => {
      const opTasks = tasks.filter(t => t.opName === op.name);
      const totalTime = opTasks.reduce((sum, t) => sum + (t.estMin || 0), 0);
      const workerCount = op.workers || 1;
      const availableTime = workerCount * 8 * 60; // 8 hours per worker per day

      if(totalTime > availableTime * 1.2){ // 20% over capacity
        bottlenecks.push({
          operation: op.name,
          totalTime: totalTime,
          availableTime: availableTime,
          overload: Math.round((totalTime / availableTime - 1) * 100)
        });
      }
    });

    return bottlenecks.sort((a, b) => b.overload - a.overload);
  }

  function renderBottlenecks(bottlenecks){
    const container = qs('#capacity-bottlenecks');
    container.innerHTML = '';

    if(bottlenecks.length === 0){
      container.innerHTML = '<div class="empty">Brak wąskich gardeł</div>';
      return;
    }

    bottlenecks.forEach(item => {
      const div = document.createElement('div');
      div.className = 'bottleneck-item';
      div.innerHTML = `
        <div class="bottleneck-name">${item.operation}</div>
        <div class="bottleneck-metrics">
          <div>Przeciążenie: ${item.overload}%</div>
          <div>Czas: ${Math.round(item.totalTime / 60 * 10) / 10}h / ${Math.round(item.availableTime / 60 * 10) / 10}h</div>
        </div>
      `;
      container.appendChild(div);
    });
  }

  function calculateEfficiencyMetrics(period){
    const tasks = state.tasks || [];
    const totalTasks = tasks.length;
    const completedTasks = tasks.filter(t => t.status === 'done').length;
    const runningTasks = tasks.filter(t => t.status === 'run').length;
    const todoTasks = tasks.filter(t => t.status === 'todo').length;

    const totalEstimatedTime = tasks.reduce((sum, t) => sum + (t.estMin || 0), 0);
    const totalActualTime = tasks.reduce((sum, t) => sum + (t.elapsedMin || 0), 0);

    const efficiency = totalEstimatedTime > 0 ? Math.round((totalActualTime / totalEstimatedTime) * 100) : 0;

    return {
      totalTasks,
      completedTasks,
      runningTasks,
      todoTasks,
      totalEstimatedTime,
      totalActualTime,
      efficiency: efficiency > 0 ? efficiency : 0,
      completionRate: totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0
    };
  }

  function renderEfficiencyMetrics(efficiency){
    const container = qs('#capacity-efficiency');
    container.innerHTML = '';

    const metrics = [
      {label: 'Razem zadań', value: efficiency.totalTasks},
      {label: 'Ukończonych', value: `${efficiency.completedTasks} (${efficiency.completionRate}%)`},
      {label: 'W trakcie', value: efficiency.runningTasks},
      {label: 'Do wykonania', value: efficiency.todoTasks},
      {label: 'Szacowany czas', value: `${Math.round(efficiency.totalEstimatedTime / 60 * 10) / 10}h`},
      {label: 'Rzeczywisty czas', value: `${Math.round(efficiency.totalActualTime / 60 * 10) / 10}h`},
      {label: 'Efektywność', value: `${efficiency.efficiency}%`}
    ];

    metrics.forEach(metric => {
      const div = document.createElement('div');
      div.className = 'efficiency-metric';
      div.innerHTML = `
        <span class="metric-label">${metric.label}:</span>
        <span class="metric-value">${metric.value}</span>
      `;
      container.appendChild(div);
    });
  }

  function exportCapacityAnalysis(){
    const period = qs('#capacity-period').value || 'week';
    const utilization = calculateResourceUtilization(period);
    const bottlenecks = calculateBottlenecks();
    const efficiency = calculateEfficiencyMetrics(period);

    let csv = 'Analiza Przepustowości Produkcji\n';
    csv += `Okres: ${period === 'day' ? 'Dzień' : period === 'week' ? 'Tydzień' : 'Miesiąc'}\n\n`;

    csv += 'Wykorzystanie Zasobów\n';
    csv += 'Pracownik,Zadań,Czas szacowany,Czas dostępny,Wykorzystanie\n';
    utilization.forEach(item => {
      csv += `${item.employee},${item.totalTasks},${Math.round(item.totalTime / 60 * 10) / 10},${Math.round(item.availableTime / 60 * 10) / 10},${item.utilization}%\n`;
    });

    csv += '\nWąskie Gardła\n';
    csv += 'Operacja,Czas całkowity,Czas dostępny,Przeciążenie\n';
    bottlenecks.forEach(item => {
      csv += `${item.operation},${Math.round(item.totalTime / 60 * 10) / 10},${Math.round(item.availableTime / 60 * 10) / 10},${item.overload}%\n`;
    });

    csv += '\nEfektywność Produkcji\n';
    csv += `Razem zadań,${efficiency.totalTasks}\n`;
    csv += `Ukończonych,${efficiency.completedTasks} (${efficiency.completionRate}%)\n`;
    csv += `W trakcie,${efficiency.runningTasks}\n`;
    csv += `Do wykonania,${efficiency.todoTasks}\n`;
    csv += `Szacowany czas,${Math.round(efficiency.totalEstimatedTime / 60 * 10) / 10}h\n`;
    csv += `Rzeczywisty czas,${Math.round(efficiency.totalActualTime / 60 * 10) / 10}h\n`;
    csv += `Efektywność,${efficiency.efficiency}%\n`;

    const blob = new Blob([csv], {type: 'text/csv;charset=utf-8;'});
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `analiza-przepustowosci-${new Date().toISOString().slice(0, 10)}.csv`;
    link.click();
  }

  // === BACKUP SYSTEM ===

  // Backup storage using localStorage with versioning
  const BACKUP_STORAGE_KEY = 'production_planner_backups';
  const MAX_BACKUPS_DEFAULT = 10;

  // Initialize backup system
  function initBackupSystem() {
    if (!localStorage.getItem(BACKUP_STORAGE_KEY)) {
      localStorage.setItem(BACKUP_STORAGE_KEY, JSON.stringify([]));
    }
    renderBackupList();
    updateBackupStats();
  }

  // Create a new backup
  function createBackup(name = null) {
    try {
      const backupName = name || `Backup ${new Date().toLocaleString('pl-PL')}`;
      const backupData = {
        id: uid(),
        name: backupName,
        timestamp: Date.now(),
        version: '1.0',
        data: JSON.parse(JSON.stringify(state)), // Deep copy
        metadata: {
          employeesCount: (state.employees || []).length,
          operationsCount: (state.operationsCatalog || []).length,
          processesCount: (state.processes || []).length,
          ordersCount: (state.orders || []).length,
          tasksCount: (state.tasks || []).length,
          size: JSON.stringify(state).length
        }
      };

      // Compress if enabled
      if (qs('#backup-compress') && qs('#backup-compress').checked) {
        // Simple compression using LZString if available, otherwise just store as is
        try {
          if (window.LZString) {
            backupData.compressed = true;
            backupData.data = window.LZString.compressToUTF16(JSON.stringify(state));
          }
        } catch (e) {
          console.warn('Compression failed, storing uncompressed:', e);
        }
      }

      const backups = getBackups();
      backups.unshift(backupData); // Add to beginning

      // Apply cleanup policy
      const maxBackups = parseInt(qs('#backup-max-count').value) || MAX_BACKUPS_DEFAULT;
      if (backups.length > maxBackups) {
        backups.splice(maxBackups);
      }

      localStorage.setItem(BACKUP_STORAGE_KEY, JSON.stringify(backups));
      renderBackupList();
      updateBackupStats();

      console.log('Backup created:', backupName);
      return backupData.id;
    } catch (e) {
      console.error('Failed to create backup:', e);
      alert('Błąd podczas tworzenia backupu: ' + e.message);
      return null;
    }
  }

  // Get all backups
  function getBackups() {
    try {
      return JSON.parse(localStorage.getItem(BACKUP_STORAGE_KEY) || '[]');
    } catch (e) {
      console.error('Failed to load backups:', e);
      return [];
    }
  }

  // Restore from backup
  window.restoreFromBackup = function restoreFromBackup(backupId) {
    try {
      const backups = getBackups();
      const backup = backups.find(b => b.id === backupId);

      if (!backup) {
        alert('Backup nie został znaleziony!');
        return false;
      }

      // Confirm restoration
      if (!confirm(`Czy na pewno chcesz przywrócić dane z backupu "${backup.name}"?\n\nTo działanie nadpisze wszystkie bieżące dane!`)) {
        return false;
      }

      let backupData = backup.data;

      // Decompress if needed
      if (backup.compressed && window.LZString) {
        try {
          backupData = JSON.parse(window.LZString.decompressFromUTF16(backupData));
        } catch (e) {
          console.error('Failed to decompress backup:', e);
          alert('Błąd podczas dekompresji backupu!');
          return false;
        }
      }

      // Restore data
      Object.assign(state, backupData);
      save();

      // Refresh all views
      renderEmployees();
      renderOps();
      renderProcPage();
      renderOrderPage();
      renderTasks();
      renderGantt();
      renderCapacityAnalysis();
      renderASPage();
      renderDash(window.state || state);

      console.log('Restored from backup:', backup.name);
      alert(`✅ Dane zostały przywrócone z backupu "${backup.name}"!`);

      return true;
    } catch (e) {
      console.error('Failed to restore backup:', e);
      alert('Błąd podczas przywracania backupu: ' + e.message);
      return false;
    }
  }

  // Delete backup
  window.deleteBackup = function deleteBackup(backupId) {
    try {
      const backups = getBackups();
      const index = backups.findIndex(b => b.id === backupId);

      if (index === -1) {
        alert('Backup nie został znaleziony!');
        return false;
      }

      const backup = backups[index];
      if (!confirm(`Czy na pewno chcesz usunąć backup "${backup.name}"?`)) {
        return false;
      }

      backups.splice(index, 1);
      localStorage.setItem(BACKUP_STORAGE_KEY, JSON.stringify(backups));
      renderBackupList();
      updateBackupStats();

      console.log('Backup deleted:', backup.name);
      return true;
    } catch (e) {
      console.error('Failed to delete backup:', e);
      alert('Błąd podczas usuwania backupu: ' + e.message);
      return false;
    }
  }

  // Export backup to file
  function exportBackup(backupId) {
    try {
      const backups = getBackups();
      const backup = backups.find(b => b.id === backupId);

      if (!backup) {
        alert('Backup nie został znaleziony!');
        return;
      }

      const exportData = {
        exportedAt: new Date().toISOString(),
        app: 'Production Planner',
        version: '1.0',
        backup: backup
      };

      const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `backup_${backup.name.replace(/[^a-zA-Z0-9]/g, '_')}_${new Date(backup.timestamp).toISOString().slice(0, 10)}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      console.log('Backup exported:', backup.name);
    } catch (e) {
      console.error('Failed to export backup:', e);
      alert('Błąd podczas eksportu backupu: ' + e.message);
    }
  }

  // Import backup from file
  function importBackupFromFile(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);

          // Validate backup format
          if (!data.backup || !data.backup.id || !data.backup.data) {
            throw new Error('Nieprawidłowy format pliku backupu');
          }

          const backup = data.backup;
          const backups = getBackups();

          // Check if backup with same ID already exists
          if (backups.some(b => b.id === backup.id)) {
            if (!confirm('Backup o tym samym ID już istnieje. Czy chcesz go nadpisać?')) {
              resolve(false);
              return;
            }
            // Remove existing backup
            const index = backups.findIndex(b => b.id === backup.id);
            backups.splice(index, 1);
          }

          // Add new backup
          backups.unshift(backup);
          localStorage.setItem(BACKUP_STORAGE_KEY, JSON.stringify(backups));
          renderBackupList();
          updateBackupStats();

          alert(`Backup "${backup.name}" został zaimportowany!`);
          console.log('Backup imported:', backup.name);
          resolve(true);
        } catch (e) {
          console.error('Failed to import backup:', e);
          alert('Błąd podczas importu backupu: ' + e.message);
          resolve(false);
        }
      };
      reader.onerror = () => reject(new Error('Failed to read file'));
      reader.readAsText(file);
    });
  }

  // Render backup list
  function renderBackupList() {
    const container = qs('#backup-list');
    if (!container) return;

    const backups = getBackups();

    if (backups.length === 0) {
      container.innerHTML = '<div class="muted">Brak dostępnych backupów. Utwórz pierwszy backup.</div>';
      return;
    }

    const html = backups.map(backup => {
      const date = new Date(backup.timestamp).toLocaleString('pl-PL');
      const size = backup.metadata ? `${Math.round(backup.metadata.size / 1024)} KB` : 'N/A';

      return `
        <div class="backup-item card" style="margin-bottom: 8px;">
          <div class="backup-header" style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 8px;">
            <div>
              <strong>${backup.name}</strong>
              <div class="muted" style="font-size: 12px;">${date}</div>
            </div>
            <div style="font-size: 12px; color: #94a3b8;">
              ${size} ${backup.compressed ? '🗜️' : ''}
            </div>
          </div>

          <div class="backup-meta" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(80px, 1fr)); gap: 8px; margin-bottom: 8px; font-size: 12px;">
            <div>👥 ${backup.metadata?.employeesCount || 0}</div>
            <div>🔧 ${backup.metadata?.operationsCount || 0}</div>
            <div>📋 ${backup.metadata?.processesCount || 0}</div>
            <div>📦 ${backup.metadata?.ordersCount || 0}</div>
            <div>✅ ${backup.metadata?.tasksCount || 0}</div>
          </div>

          <div class="backup-actions" style="display: flex; gap: 6px; flex-wrap: wrap;">
            <button class="btn" onclick="restoreFromBackup('${backup.id}')" title="Przywróć dane z tego backupu">
              🔄 Przywróć
            </button>
            <button class="btn" onclick="exportBackup('${backup.id}')" title="Eksportuj backup do pliku">
              💾 Eksport
            </button>
            <button class="btn red" onclick="deleteBackup('${backup.id}')" title="Usuń backup">
              🗑️ Usuń
            </button>
          </div>
        </div>
      `;
    }).join('');

    container.innerHTML = html;
  }

  // Update backup statistics
  function updateBackupStats() {
    const backups = getBackups();

    // Update counts
    qs('#backup-count').textContent = backups.length;

    // Update latest backup
    if (backups.length > 0) {
      const latest = new Date(backups[0].timestamp);
      qs('#backup-latest').textContent = latest.toLocaleString('pl-PL');
    } else {
      qs('#backup-latest').textContent = '-';
    }

    // Calculate total size
    const totalSize = backups.reduce((sum, b) => sum + (b.metadata?.size || 0), 0);
    qs('#backup-size').textContent = `${Math.round(totalSize / 1024)} KB`;
  }

  // Auto-backup functionality
  function setupAutoBackup() {
    // Create backup before major operations
    const originalSave = window.save;
    window.save = function() {
      // Create auto-backup if enabled and it's been more than 1 hour since last backup
      const lastBackup = localStorage.getItem('last_auto_backup');
      const now = Date.now();

      if (qs('#backup-auto-cleanup') && qs('#backup-auto-cleanup').checked) {
        if (!lastBackup || (now - parseInt(lastBackup)) > 3600000) { // 1 hour
          createBackup(`Auto-backup ${new Date().toLocaleString('pl-PL')}`);
          localStorage.setItem('last_auto_backup', now.toString());
        }
      }

      return originalSave.apply(this, arguments);
    };
  }

  // Save backup settings
  function saveBackupSettings() {
    const settings = {
      includeSettings: qs('#backup-include-settings').checked,
      includeLogs: qs('#backup-include-logs').checked,
      compress: qs('#backup-compress').checked,
      autoCleanup: qs('#backup-auto-cleanup').checked,
      maxCount: parseInt(qs('#backup-max-count').value) || MAX_BACKUPS_DEFAULT
    };

    localStorage.setItem('backup_settings', JSON.stringify(settings));
    console.log('Backup settings saved');
  }

  // Load backup settings
  function loadBackupSettings() {
    try {
      const settings = JSON.parse(localStorage.getItem('backup_settings') || '{}');

      if (qs('#backup-include-settings')) qs('#backup-include-settings').checked = settings.includeSettings !== false;
      if (qs('#backup-include-logs')) qs('#backup-include-logs').checked = settings.includeLogs !== false;
      if (qs('#backup-compress')) qs('#backup-compress').checked = settings.compress !== false;
      if (qs('#backup-auto-cleanup')) qs('#backup-auto-cleanup').checked = settings.autoCleanup === true;
      if (qs('#backup-max-count')) qs('#backup-max-count').value = settings.maxCount || MAX_BACKUPS_DEFAULT;
    } catch (e) {
      console.warn('Failed to load backup settings:', e);
    }
  }

  // Initialize backup system when page loads
  // Initialize Gantt controls event listeners
  function initGanttControls() {
    // Event listeners for Gantt controls
    const ganttRefreshBtn = qs('#gantt-refresh');
    if(ganttRefreshBtn){ ganttRefreshBtn.addEventListener('click', () => renderGantt()); }
    
    // Nawigacja datami
    const ganttPrevBtn = qs('#gantt-prev-period');
    if(ganttPrevBtn){
      ganttPrevBtn.addEventListener('click', () => {
        const viewMode = qs('#gantt-view').value || 'week';
        const daysToMove = viewMode === 'week' ? 7 : 30;
        state.ganttDateOffset = (state.ganttDateOffset || 0) - daysToMove;
        renderGantt();
      });
    }
    
    const ganttTodayBtn = qs('#gantt-today');
    if(ganttTodayBtn){
      ganttTodayBtn.addEventListener('click', () => {
        state.ganttDateOffset = 0;
        renderGantt();
      });
    }
    
    const ganttNextBtn = qs('#gantt-next-period');
    if(ganttNextBtn){
      ganttNextBtn.addEventListener('click', () => {
        const viewMode = qs('#gantt-view').value || 'week';
        const daysToMove = viewMode === 'week' ? 7 : 30;
        state.ganttDateOffset = (state.ganttDateOffset || 0) + daysToMove;
        renderGantt();
      });
    }
    
    // Przyciski do przesuwania zaznaczonego zadania
    const ganttMoveBackBtn = qs('#gantt-move-task-back');
    if(ganttMoveBackBtn){
      ganttMoveBackBtn.addEventListener('click', () => {
        moveSelectedTask(-1);
      });
    }
    
    const ganttMoveForwardBtn = qs('#gantt-move-task-forward');
    if(ganttMoveForwardBtn){
      ganttMoveForwardBtn.addEventListener('click', () => {
        moveSelectedTask(1);
      });
    }
    
    const ganttClearSelectionBtn = qs('#gantt-clear-selection');
    if(ganttClearSelectionBtn){
      ganttClearSelectionBtn.addEventListener('click', () => {
        clearGanttTaskSelection();
      });
    }
    
    const ganttReplanAll = qs('#gantt-replan-all');
    if(ganttReplanAll){
      ganttReplanAll.addEventListener('click', ()=>{
        console.log('[replan] window.scheduleCore exists:', !!window.scheduleCore);
        if(!window.scheduleCore) return;
        if(typeof updateScheduleConfigFromUI==='function') updateScheduleConfigFromUI();
        if(!confirm('Przeliczyć wszystkie zadania od nowa? Spowoduje to reset ich start/end.')) return;
        (window.logDev||console.log)('[replan] starting global replan');
        try{
          window.scheduleCore.generateSchedule(state,{force:true});
          save(); renderGantt(); renderOrderPage();
          (window.logDev||console.log)('[replan] global completed');
        }catch(e){ console.error('[replan] error', e); }
      });
    }

    const ganttAutoAssignBtn = qs('#gantt-auto-assign');
    if(ganttAutoAssignBtn){ ganttAutoAssignBtn.addEventListener('click', () => autoAssignEmployeesToTasks()); }

    const ganttGenerateBtn = qs('#gantt-generate-test');
    if(ganttGenerateBtn){ ganttGenerateBtn.addEventListener('click', () => generateGanttTestData()); }

    const ganttViewSelect = qs('#gantt-view');
    if(ganttViewSelect){ ganttViewSelect.addEventListener('change', () => renderGantt()); }

    const ganttShowDependenciesBtn = qs('#gantt-show-dependencies');
    if(ganttShowDependenciesBtn){ ganttShowDependenciesBtn.addEventListener('click', () => toggleDependencies()); }

    const ganttCreateDependencyBtn = qs('#gantt-create-dependency');
    if(ganttCreateDependencyBtn){ ganttCreateDependencyBtn.addEventListener('click', () => toggleDependencyCreation()); }

    const ganttManageDependenciesBtn = qs('#gantt-manage-dependencies');
    if(ganttManageDependenciesBtn){ ganttManageDependenciesBtn.addEventListener('click', () => showDependencyManager()); }

    const ganttShowCriticalPathBtn = qs('#gantt-show-critical-path');
    if(ganttShowCriticalPathBtn){ ganttShowCriticalPathBtn.addEventListener('click', () => toggleCriticalPath()); }

    // Capacity Analysis event handlers
    const capacityRefreshBtn = qs('#capacity-refresh');
    if(capacityRefreshBtn){ capacityRefreshBtn.addEventListener('click', () => renderCapacityAnalysis()); }

    const capacityPeriodSelect = qs('#capacity-period');
    if(capacityPeriodSelect){ capacityPeriodSelect.addEventListener('change', () => renderCapacityAnalysis()); }

    const capacityExportBtn = qs('#capacity-export');
    if(capacityExportBtn){ capacityExportBtn.addEventListener('click', () => exportCapacityAnalysis()); }

    qs('#emp-add').addEventListener('click',()=>{
      const name = prompt('Imię i nazwisko');
      if (!name || !name.trim()) return;

      const trimmedName = name.trim();
      if (trimmedName.length < 2) {
        alert('Imię i nazwisko musi mieć co najmniej 2 znaki');
        return;
      }

      state.employees.push({id:uid(),name:trimmedName,cap:100,hoursPerDay:8});
      save();
      renderEmployees();
    });
  }

  document.addEventListener('DOMContentLoaded', function() {
    initBackupSystem();
    loadBackupSettings();
    setupAutoBackup();

    // Initialize Gantt controls event listeners
    initGanttControls();
  });

  // Event listeners for backup UI
  qs('#backup-create').addEventListener('click', () => {
    const name = prompt('Nazwa backupu (opcjonalnie):');
    if (name === null) return; // Cancelled

    const backupId = createBackup(name.trim() || null);
    if (backupId) {
      alert('Backup został utworzony pomyślnie!');
    }
  });

  qs('#export-data').addEventListener('click', () => {
    if (typeof window.exportDataToFile === 'function') {
      window.exportDataToFile();
    } else {
      // Fallback to old method
      const dataStr = JSON.stringify(state, null, 2);
      const dataBlob = new Blob([dataStr], {type: 'application/json'});
      const url = URL.createObjectURL(dataBlob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `doors-planner-data-${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      alert('Dane zostały wyeksportowane do pliku!');
    }
  });

  qs('#import-data').addEventListener('click', () => {
    if (typeof window.importDataFromFile === 'function') {
      window.importDataFromFile();
    } else {
      // Fallback to old method
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json';
      input.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const importedData = JSON.parse(e.target.result);
            if (confirm('Czy na pewno chcesz zaimportować dane? To nadpisze obecne dane.')) {
              Object.assign(state, importedData);
              save();
              location.reload(); // Reload to apply changes
            }
          } catch (err) {
            alert('Błąd podczas importu danych: ' + err.message);
          }
        };
        reader.readAsText(file);
      };
      input.click();
    }
  });

  qs('#backup-refresh').addEventListener('click', () => {
    renderBackupList();
    updateBackupStats();
  });

  qs('#backup-cleanup').addEventListener('click', () => {
    const removed = cleanupOldBackups();
    if (removed > 0) {
      alert(`Wyczyszczono ${removed} starych backupów!`);
    } else {
      alert('Brak starych backupów do wyczyszczenia.');
    }
  });

  const backupImportEl = qs('#backup-import');
  if (backupImportEl) {
    backupImportEl.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;

      try {
        await importBackupFromFile(file);
      } catch (error) {
        console.error('Import failed:', error);
        alert('Błąd podczas importu: ' + error.message);
      }

      // Reset input
      e.target.value = '';
    });
  }

  // Cleanup old backups
  function cleanupOldBackups() {
    try {
      const backups = getBackups();
      const maxCount = parseInt(qs('#backup-max-count').value) || MAX_BACKUPS_DEFAULT;

      if (backups.length <= maxCount) {
        console.log('No cleanup needed');
        return 0;
      }

      const removed = backups.splice(maxCount);
      localStorage.setItem(BACKUP_STORAGE_KEY, JSON.stringify(backups));
      renderBackupList();
      updateBackupStats();

      console.log(`Cleaned up ${removed.length} old backups`);
      return removed.length;
    } catch (e) {
      console.error('Failed to cleanup backups:', e);
      return 0;
    }
  }

  function showReportsProgress(show = true, text = 'Generowanie raportu...', percent = 0){
    const progressEl = qs('#reports-progress');
    const textEl = qs('#reports-progress-text');
    const percentEl = qs('#reports-progress-percent');
    const barEl = qs('#reports-progress-bar');
    
    if(show){
      progressEl.classList.remove('hidden');
      textEl.textContent = text;
      percentEl.textContent = percent + '%';
      barEl.style.width = percent + '%';
    } else {
      progressEl.classList.add('hidden');
    }
  }

  function buildEmployeeText(empId){
    const emp = (state.employees||[]).find(e=>e.id===empId) || {id:empId,name:empId};
    const lines = [];
    lines.push(`${emp.name} — Zadania`);
    lines.push(`Data: ${new Date().toLocaleDateString()}`);
    lines.push('');
    const tasks = [];
    (state.processes||[]).forEach(proc=>{ (proc.operations||[]).forEach(op=>{ if(op.assignee && (op.assignee.id||op.assignee)===empId){ tasks.push({title:op.name,ctx:proc.name,time:op.time||0}); } }); });
    (state.tasks||[]).forEach(t=>{ const as = t.assignees || (t.assignee ? [t.assignee] : []); if(Array.isArray(as) && as.some(a=> (a.id||a)===empId)){ tasks.push({title:t.opName,ctx:(state.orders||[]).find(o=>o.id===t.orderId)?.name||t.orderId,time:t.estMin||t.elapsedMin||0}); } });
    if(tasks.length===0){ lines.push('Brak przypisanych zadań.'); }
    else{ tasks.forEach((tk,i)=>{ lines.push(`${i+1}. ${tk.title} — ${tk.ctx} — ${tk.time}m`); }); }
    lines.push(''); lines.push('Powodzenia!');
    return lines.join('\n');
  }

  function copyToClipboard(text){ if(navigator.clipboard && navigator.clipboard.writeText){ navigator.clipboard.writeText(text).catch(()=>{ const ta=document.createElement('textarea'); ta.value=text; document.body.appendChild(ta); ta.select(); document.execCommand('copy'); ta.remove(); }); } else { const ta=document.createElement('textarea'); ta.value=text; document.body.appendChild(ta); ta.select(); document.execCommand('copy'); ta.remove(); } }

  function renderReports(){
    showReportsProgress(true, 'Przygotowywanie danych...', 10);
    
    setTimeout(() => {
      showReportsProgress(true, 'Filtrowanie danych...', 30);
      
      setTimeout(() => {
        showReportsProgress(true, 'Obliczanie statystyk...', 60);
        
        setTimeout(() => {
          showReportsProgress(true, 'Generowanie wykresów...', 80);
          
          setTimeout(() => {
            showReportsProgress(true, 'Finalizowanie...', 100);
            
            setTimeout(() => {
              // Tutaj wykonaj rzeczywistą logikę
              const period = qs('#report-period').value || 'month';
              const now = new Date();
              let startDate, endDate;

              // Oblicz zakres dat na podstawie wybranego okresu
              switch(period){
                case 'week':
                  startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                  endDate = now;
                  break;
                case 'month':
                  startDate = new Date(now.getFullYear(), now.getMonth(), 1);
                  endDate = new Date(now.getFullYear(), now.getMonth() + 1, 0);
                  break;
                case 'quarter':
                  const quarterStart = Math.floor(now.getMonth() / 3) * 3;
                  startDate = new Date(now.getFullYear(), quarterStart, 1);
                  endDate = new Date(now.getFullYear(), quarterStart + 3, 0);
                  break;
                case 'year':
                  startDate = new Date(now.getFullYear(), 0, 1);
                  endDate = new Date(now.getFullYear(), 11, 31);
                  break;
              }

              // Filtruj dane dla wybranego okresu
              const filteredTasks = state.tasks.filter(task => {
                if(!task.createdAt) return true; // zadania bez daty traktuj jako aktualne
                const taskDate = new Date(task.createdAt);
                return taskDate >= startDate && taskDate <= endDate;
              });

              const filteredOrders = state.orders.filter(order => {
                if(!order.startDate) return true;
                const orderDate = new Date(order.startDate);
                return orderDate >= startDate && orderDate <= endDate;
              });

              // Generuj statystyki
              generateReportStats(filteredTasks, filteredOrders, period);
              generateEmployeePerformance(filteredTasks, period);
              generateCostReport(filteredTasks, period);
              generateDetailedStats(filteredTasks, filteredOrders, period);
              
              showReportsProgress(false);
            }, 200);
          }, 300);
        }, 300);
      }, 300);
    }, 200);
  }

  function generateReportStats(tasks, orders, period){
    const totalOrders = orders.length;
    const completedTasks = tasks.filter(t => t.status === 'done').length;
    const totalTasks = tasks.length;
    const totalEstimatedTime = tasks.reduce((sum, t) => sum + (t.estMin || 0), 0);
    const totalActualTime = tasks.reduce((sum, t) => sum + (t.elapsedMin || 0), 0);
    const efficiency = totalEstimatedTime > 0 ? Math.round((totalActualTime / totalEstimatedTime) * 100) : 0;

    qs('#stat-total-orders').textContent = totalOrders;
    qs('#stat-completed-tasks').textContent = completedTasks;
    qs('#stat-efficiency').textContent = `${efficiency}%`;
  }

  function generateEmployeePerformance(tasks, period){
    const container = qs('#report-employee-performance');
    const employees = state.employees || [];

    if(employees.length === 0){
      container.innerHTML = '<div class="empty">Brak danych o pracownikach</div>';
      return;
    }

    // Oblicz wydajność dla każdego pracownika
    const performance = employees.map(emp => {
      const empTasks = tasks.filter(t => t.assignees && t.assignees.some(a => a.id === emp.id));
      const completedTasks = empTasks.filter(t => t.status === 'done').length;
      const totalTasks = empTasks.length;
      const totalTime = empTasks.reduce((sum, t) => sum + (t.elapsedMin || 0), 0);
      const efficiency = totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0;

      return {
        name: emp.name,
        completedTasks,
        totalTasks,
        totalTime: Math.round(totalTime / 60 * 10) / 10, // w godzinach
        efficiency
      };
    }).sort((a, b) => b.efficiency - a.efficiency);

    // Generuj HTML
    let html = '<div style="display:flex;flex-direction:column;gap:8px">';
    performance.forEach(emp => {
      const barWidth = Math.min(emp.efficiency, 100);
      html += `
        <div style="display:flex;align-items:center;gap:12px">
          <div style="width:120px;font-weight:500">${emp.name}</div>
          <div style="flex:1;background:#e5e7eb;border-radius:4px;height:20px;overflow:hidden">
            <div style="width:${barWidth}%;height:100%;background:${emp.efficiency >= 80 ? 'var(--ok)' : emp.efficiency >= 60 ? 'var(--warn)' : 'var(--err)'};transition:width 0.3s"></div>
          </div>
          <div style="width:80px;text-align:right;font-size:12px;color:#94a3b8">${emp.efficiency}%</div>
          <div style="width:100px;text-align:right;font-size:12px;color:#94a3b8">${emp.completedTasks}/${emp.totalTasks} zadań</div>
        </div>
      `;
    });
    html += '</div>';

    container.innerHTML = html;
  }

  function generateCostReport(tasks, period){
    const container = qs('#report-costs');

    // Proste obliczenia kosztów (można rozszerzyć o rzeczywiste stawki)
    const hourlyRate = 25; // zł/h - przykładowa stawka
    const totalHours = tasks.reduce((sum, t) => sum + (t.elapsedMin || 0), 0) / 60;
    const totalCost = Math.round(totalHours * hourlyRate);

    const completedTasks = tasks.filter(t => t.status === 'done').length;
    const costPerTask = completedTasks > 0 ? Math.round(totalCost / completedTasks) : 0;

    container.innerHTML = `
      <div class="grid3">
        <div class="card" style="text-align:center">
          <div style="font-size:20px;font-weight:bold;color:var(--acc)">${Math.round(totalHours)}h</div>
          <div style="color:var(--text-secondary)">Całkowity czas pracy</div>
        </div>
        <div class="card" style="text-align:center">
          <div style="font-size:20px;font-weight:bold;color:var(--ok)">${totalCost} zł</div>
          <div style="color:var(--text-secondary)">Całkowity koszt</div>
        </div>
        <div class="card" style="text-align:center">
          <div style="font-size:20px;font-weight:bold;color:var(--warn)">${costPerTask} zł</div>
          <div style="color:var(--text-secondary)">Średni koszt zadania</div>
        </div>
      </div>
    `;
  }

  function generateDetailedStats(tasks, orders, period){
    const container = qs('#report-details');

    // Grupuj zadania według statusu
    const statusStats = {
      todo: tasks.filter(t => t.status === 'todo').length,
      run: tasks.filter(t => t.status === 'run').length,
      done: tasks.filter(t => t.status === 'done').length
    };

    // Oblicz średnie czasy
    const completedTasks = tasks.filter(t => t.status === 'done' && t.elapsedMin > 0);
    const avgCompletionTime = completedTasks.length > 0
      ? Math.round(completedTasks.reduce((sum, t) => sum + t.elapsedMin, 0) / completedTasks.length / 60 * 10) / 10
      : 0;

    const html = `
      <table>
        <thead>
          <tr>
            <th>Metryka</th>
            <th>Wartość</th>
            <th>Opis</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Całkowita liczba zleceń</td>
            <td>${orders.length}</td>
            <td>Zlecenia w wybranym okresie</td>
          </tr>
          <tr>
            <td>Zadania do wykonania</td>
            <td>${statusStats.todo}</td>
            <td>Zadania oczekujące</td>
          </tr>
          <tr>
            <td>Zadania w trakcie</td>
            <td>${statusStats.run}</td>
            <td>Zadania aktualnie wykonywane</td>
          </tr>
          <tr>
            <td>Zadania ukończone</td>
            <td>${statusStats.done}</td>
            <td>Zadania zakończone</td>
          </tr>
          <tr>
            <td>Średni czas wykonania</td>
            <td>${avgCompletionTime}h</td>
            <td>Średni czas na ukończone zadanie</td>
          </tr>
          <tr>
            <td>Łączny szacowany czas</td>
            <td>${Math.round(tasks.reduce((sum, t) => sum + (t.estMin || 0), 0) / 60)}h</td>
            <td>Całkowity planowany czas pracy</td>
          </tr>
        </tbody>
      </table>
    `;

    container.innerHTML = html;
  }

  function exportReportToPDF(){
    showReportsProgress(true, 'Przygotowywanie danych do eksportu...', 20);
    
    setTimeout(() => {
      showReportsProgress(true, 'Generowanie zawartości PDF...', 60);
      
      setTimeout(() => {
        showReportsProgress(true, 'Otwieranie okna drukowania...', 90);
        
        setTimeout(() => {
          // Prosta implementacja eksportu - otwórz w nowym oknie i użyj drukowania do PDF
          const reportWindow = window.open('', '_blank');
          const reportContent = qs('#reports-content').innerHTML;
          
          const html = `<html>
            <head>
              <title>Raport produkcyjny - ${new Date().toLocaleDateString('pl-PL')}</title>
              <style>
                body { font-family: Arial, sans-serif; margin: 20px; }
                .card { border: 1px solid #ddd; padding: 16px; margin-bottom: 16px; border-radius: 8px; }
                h4 { margin-top: 0; color: #333; }
                table { width: 100%; border-collapse: collapse; margin-top: 16px; }
                th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
                th { background-color: #f5f5f5; }
                .grid3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; }
                .card { text-align: center; }
                @media print { body { margin: 0; } }
              </style>
              <style>
              /* === High contrast warning callout === */
              .callout-warn{background:#fef3c7;border:1px solid #f59e0b;color:#1f2937;}
              .callout-warn h4{margin-top:0;color:#92400e;}
              .callout-warn strong{color:#92400e;}
              .callout-warn.high-contrast{background:#1e293b;border-color:#fbbf24;color:#f8fafc;}
              .callout-warn.high-contrast h4{color:#fbbf24;}
              .callout-warn.high-contrast strong{color:#fbbf24;}
              .callout-warn.high-contrast a, .callout-warn.high-contrast code{color:#fde68a;}
              #high-contrast-toggle-wrapper{margin:8px 0 16px;}
              #high-contrast-toggle-wrapper label{display:flex;align-items:center;gap:6px;font-size:13px;color:#cbd5e1;cursor:pointer;}
              </style>
            </head>
            <body>
              <h2>Raport produkcyjny</h2>
              <p>Okres: ${qs('#report-period').value} | Data wygenerowania: ${new Date().toLocaleString('pl-PL')}</p>
              ${reportContent}
            </body>
          </html>`;
          
          reportWindow.document.write(html);
          
          reportWindow.document.close();
          reportWindow.print();
          
          showReportsProgress(false);
        }, 300);
      }, 300);
    }, 200);
  }
  
  function renderASPage(){
  const sel=qs('#as-order'); if(sel){ sel.innerHTML=''; (state.orders||[]).forEach(o=>{ const opt=document.createElement('option'); opt.value=o.id; opt.textContent=(o.name?(''+o.name):o.id); sel.appendChild(opt); });
      // populate employee multi-select
      const empSel=qs('#as-employees'); 
      if(empSel){ 
        empSel.innerHTML=''; 
        (state.employees||[]).forEach(e=>{ 
          const opt=document.createElement('option'); 
          opt.value=e.id; 
          opt.textContent=e.name||e.id; 
          empSel.appendChild(opt); 
        }); 
      }
      // when order selection changes, copy phone/placecode automatically
      sel.addEventListener('change',()=>{
        const oid = sel.value; const ord = (state.orders||[]).find(x=>x.id===oid) || {};
        if(ord){
          // automatycznie wypełnij dane montażu z zlecenia
          qs('#as-placecode').value = ord.postalCode || ord.post || '';
          qs('#as-phone').value = ord.phone || ord.orderPhone || '';
          qs('#as-address').value = ord.address || '';
          // pozostałe pola jak wcześniej
          const leadEmp = (state.employees||[]).find(e=>e.id===ord.leadEmployeeId);
          qs('#as-lead').value = leadEmp ? leadEmp.name : '';
          qs('#as-desc').value = ord.notes || '';
          qs('#as-install').value = ord.installDate || '';
          qs('#as-employee').value = '';
        }
      });
    }
    const host=qs('#as-list'); if(!host) return; host.innerHTML='';
    (state.after||[]).slice().reverse().forEach(a=>{
      const d=document.createElement('div'); d.className='card';
      const orderObj = (state.orders||[]).find(o=>o.id===a.order) || {};
      const placeCode = a.postalCode || orderObj.postalCode || orderObj.placeCode || orderObj.placecode || '';
      const phoneNumber = a.phone || orderObj.phone || '';
      const address = a.address || orderObj.address || '';
      // Support both old (employeeId) and new (employeeIds array) format
      const empIds = a.employeeIds || (a.employeeId ? [a.employeeId] : []);
      const empNames = empIds.length > 0 
        ? empIds.map(eid => (state.employees||[]).find(e=>e.id===eid)?.name || eid).join(', ')
        : '-';
      const hoursText = a.hours ? `${a.hours}h` : '-';
      d.innerHTML=`<div class="row" style="justify-content:space-between"><div><b>${a.type}</b> • ${a.status} • ${orderObj.name||a.order||''}
      <div class="muted">Montaż: ${a.installDate||'-'} • wyjazd: ${a.departTime||'-'} • wizyta: ${a.visitTime||'-'} • czas: ${hoursText}</div>
      <div class="muted">Adres: ${address || '-'} • Kod: ${placeCode || '-'} • Tel: ${phoneNumber || '-'}</div>
      <div class="muted">Pracownicy: ${empNames}</div>
      <div class="muted">${a.desc||''}</div></div><div><button class="btn" data-as-ed="${a.id}">Edytuj</button> <button class="btn red" data-as-del="${a.id}">Usuń</button></div></div>`;
      host.appendChild(d);
    });
  }
  qs('#as-form').addEventListener('submit',(ev)=>{
    ev.preventDefault(); const id=qs('#as-id').value||uid(); const type=qs('#as-type').value; const order=qs('#as-order').value||''; const status=qs('#as-status').value; const desc=qs('#as-desc').value||''; const install=qs('#as-install').value||''; const depart=qs('#as-go').value||''; const visit=qs('#as-visit').value||'';
    // get selected employees from multi-select
    const empSel = qs('#as-employees');
    const selectedEmployees = empSel ? Array.from(empSel.selectedOptions).map(opt => opt.value) : [];
    // get phone, placecode and address from form fields
    const asPhone = qs('#as-phone').value || '';
    const asPlace = qs('#as-placecode').value || '';
    const asAddress = qs('#as-address').value || '';
    const asHours = parseFloat(qs('#as-hours').value) || 0;
    const orderObj = (state.orders||[]).find(o=>o.id===order);
    const ex=state.after.find(x=>x.id===id); 
    const payload={id,type,order,status,desc,installDate:install,departTime:depart,visitTime:visit,phone:asPhone,postalCode:asPlace,address:asAddress,employeeIds:selectedEmployees,hours:asHours};
    if(ex) Object.assign(ex,payload); else state.after.push(payload);
    // optional immediate save after AS save
    maybeAutoSave('as-save');
    save(); ev.target.reset(); renderASPage();
    
    // Block time for all selected employees during assembly
    if(selectedEmployees.length > 0 && install && asHours > 0){
      console.log('🔧 Tworzenie montażu dla pracowników:', selectedEmployees, 'Godziny:', asHours);
      // Remove old blocking tasks for this assembly
      state.tasks = (state.tasks||[]).filter(t => t.assemblyId !== id);
      
      selectedEmployees.forEach(employeeId => {
        const emp = (state.employees||[]).find(e=>e.id===employeeId);
        console.log('👷 Pracownik:', employeeId, emp ? emp.name : 'nie znaleziono');
        if(emp){
          // Calculate start and end time based on install date and hours
          const installDate = new Date(install);
          // If departure time exists, use it, otherwise default to 8:00
          let startHour = 8, startMin = 0;
          if(depart){
            const [h, m] = depart.split(':').map(Number);
            startHour = h; startMin = m;
          }
          installDate.setHours(startHour, startMin, 0, 0);
          const startTime = installDate.getTime();
          const endTime = startTime + (asHours * 60 * 60 * 1000); // Convert hours to milliseconds
          
          // Create blocking task
          const blockTask = { 
            id: uid(), 
            operationId: 'montaż-block', 
            opName: `Montaż: ${orderObj?.name || order}`,
            name: `Montaż: ${orderObj?.name || order}`,
            employeeId, 
            startPlanned: startTime, 
            endPlanned: endTime, 
            status: 'planned', 
            orderId: order,
            assemblyId: id,
            hours: asHours
          };
          console.log('✅ Dodano zadanie montażu:', blockTask.opName, 'dla', emp.name);
          state.tasks.push(blockTask);
        }
      });
      console.log('📊 Wszystkie zadania montażowe:', state.tasks.filter(t => t.operationId === 'montaż-block').length);
      save();
      renderTasks();
      renderGantt();
    }
  });

  function renderMRPPage(){
    const list = qs('#mrp-list');
    if (!list) return;
    list.innerHTML = '';
    const mrp = new Map();

    (state.orders || []).forEach(order => {
      if (order.processId && order.quantity > 0) {
        const process = state.processes.find(p => p.id === order.processId);
        if (process) {
          (process.operations || []).forEach(procOp => {
            const opCatEntry = state.operationsCatalog.find(op => op.name === procOp.name);
            if (opCatEntry && opCatEntry.skills) {
              opCatEntry.skills.forEach(skill => {
                const currentQty = mrp.get(skill) || 0;
                mrp.set(skill, currentQty + order.quantity);
              });
            }
          });
        }
      }
    });

    if (mrp.size === 0) {
      list.innerHTML = '<div class="muted">Brak komponentów do zamówienia. Sprawdź, czy zlecenia mają przypisany proces i operacje zawierają komponenty.</div>';
      return;
    }

    const mrpItems = Array.from(mrp.entries()).sort((a, b) => a[0].localeCompare(b[0]));
    const tableHtml = `
      <div class="table">
        <table>
          <thead><tr><th>Komponent</th><th>Ilość</th></tr></thead>
          <tbody>
            ${mrpItems.map(([item, qty]) => `<tr><td>${item}</td><td>${qty}</td></tr>`).join('')}
          </tbody>
        </table>
      </div>
    `;
    list.innerHTML = tableHtml;
  }

  // Monitoring: show simple metrics and detect candidate bottlenecks
  function renderMonitor(){
    const host = qs('#p-monitor'); if(!host) return;
    host.innerHTML = '';
  const header = document.createElement('div'); header.className='row'; header.style.justifyContent='space-between';
  const title = document.createElement('div'); title.innerHTML = '<h3>Monitoring postępów</h3>'; header.appendChild(title);
  const ctrl = document.createElement('div'); ctrl.className='row';
  const refreshBtn = document.createElement('button'); refreshBtn.className='btn'; refreshBtn.textContent='Odśwież'; refreshBtn.addEventListener('click', ()=>{ renderMonitor(); });
  const exportBtn = document.createElement('button'); exportBtn.className='btn'; exportBtn.textContent='Eksport CSV'; exportBtn.style.marginLeft='6px';
  exportBtn.addEventListener('click', ()=>{ exportMonitorCSV(); });
  const filterInput = document.createElement('input'); filterInput.id='monitor-filter-input'; filterInput.placeholder='Filtruj operacje...'; filterInput.style.width='220px'; filterInput.style.marginLeft='8px';
  filterInput.value = qs('#monitor-filter-input')? qs('#monitor-filter-input').value : '';
  filterInput.addEventListener('input', ()=>{ renderMonitor(); });
  ctrl.appendChild(filterInput); ctrl.appendChild(refreshBtn); ctrl.appendChild(exportBtn);
  header.appendChild(ctrl);
  host.appendChild(header);

    const totalOrders = (state.orders||[]).length;
    const totalTasks = (state.tasks||[]).length;
    const running = (state.tasks||[]).filter(t=>t.status==='run').length;
    const todo = (state.tasks||[]).filter(t=>!t.status || t.status==='todo').length;

    const metrics = document.createElement('div'); metrics.className='grid3'; metrics.style.marginTop='8px';
    metrics.innerHTML = `<div class="card"><div><b>Zlecenia</b></div><div class="pill">${totalOrders}</div></div><div class="card"><div><b>Zadania</b></div><div class="pill">${totalTasks}</div></div><div class="card"><div><b>W toku / oczekujące</b></div><div class="muted">run: ${running} • todo: ${todo}</div></div>`;
    host.appendChild(metrics);

    const opStats = new Map();
    (state.operationsCatalog||[]).forEach(op=>{ opStats.set(op.name, { name: op.name, id: op.id, countTodo:0, countRun:0, totalEst:0, totalElapsed:0, avgElapsed:0 }); });
    (state.tasks||[]).forEach(t=>{
      const key = t.opName || '(unknown)';
      if(!opStats.has(key)) opStats.set(key, { name:key, id:null, countTodo:0, countRun:0, totalEst:0, totalElapsed:0, avgElapsed:0 });
      const s = opStats.get(key);
      if(t.status==='run') s.countRun++; else s.countTodo++;
      s.totalEst += (t.estMin||0);
      s.totalElapsed += (t.elapsedMin||0);
    });
    opStats.forEach(s=>{ const totalCount = s.countRun + s.countTodo; s.avgElapsed = totalCount? Math.round(s.totalElapsed/Math.max(1,totalCount)) : 0; });
    const statArr = Array.from(opStats.values()).filter(s=> (s.countRun + s.countTodo) > 0 );
    statArr.sort((a,b)=> (b.countRun + b.countTodo) - (a.countRun + a.countTodo) || b.avgElapsed - a.avgElapsed);
  const filterVal = (qs('#monitor-filter-input') && qs('#monitor-filter-input').value) ? (qs('#monitor-filter-input').value||'').toLowerCase() : '';
  const filtered = filterVal ? statArr.filter(s=> (s.name||'').toLowerCase().indexOf(filterVal)!==-1) : statArr;
  const top = filtered.slice(0,10);
    const tableWrap = document.createElement('div'); tableWrap.className='table'; tableWrap.style.marginTop='12px';
    const tbl = document.createElement('table'); tbl.innerHTML = `<thead><tr><th>Operacja</th><th>W kolejce</th><th>W toku</th><th>Est. sum</th><th>Śr. elapsed [m]</th></tr></thead><tbody></tbody>`;
    const tb = tbl.querySelector('tbody');
    top.forEach(s=>{ const tr=document.createElement('tr'); tr.innerHTML = `<td>${s.name}</td><td>${s.countTodo}</td><td>${s.countRun}</td><td>${s.totalEst}</td><td>${s.avgElapsed}</td>`; tb.appendChild(tr); });
    tableWrap.appendChild(tbl);
    host.appendChild(tableWrap);
    tableWrap.appendChild(tbl);
    host.appendChild(tableWrap);

    const sugg = document.createElement('div'); sugg.style.marginTop='10px';
    const threshold = (state.storage && state.storage.monitorThreshold) ? Number(state.storage.monitorThreshold) : 5;
    const heavy = statArr.filter(s=> (s.countTodo + s.countRun) >= threshold );
    if(heavy.length){
      sugg.innerHTML = `<div class="card err"><b>Potencjalne wąskie gardła:</b><div style="margin-top:6px">${heavy.map(s=>`${s.name} — ${s.countTodo + s.countRun} zadań`).join('<br>')}</div></div>`;
    } else {
      sugg.innerHTML = `<div class="card"><div class="muted">Brak wyraźnych wąskich gardeł (brak operacji z ≥${threshold} zadaniami).</div></div>`;
    }
    host.appendChild(sugg);

    // export CSV helper captures current heavy list
    function exportMonitorCSV(){
      const rows = heavy.map(s=>({operation:s.name, count: s.countTodo + s.countRun, totalEst: s.totalEst, avgElapsed: s.avgElapsed}));
      if(rows.length===0){ alert('Brak wąskich gardeł do eksportu.'); return; }
      const csv = ['operation,count,totalEst,avgElapsed'].concat(rows.map(r=>`"${(r.operation||'').replace(/"/g,'""')}",${r.count},${r.totalEst},${r.avgElapsed}`)).join('\n');
      const blob = new Blob([csv], {type:'text/csv'});
      const url = URL.createObjectURL(blob);
      const pad = n=>String(n).padStart(2,'0');
      const d = new Date();
      const ts = `${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
      const th = state.storage && state.storage.monitorThreshold ? state.storage.monitorThreshold : 'x';
      const filename = `monitor_bottlenecks_${ts}_th${th}.csv`;
      const a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); a.remove();
      try{
        const existing = qs('#monitor-export-toast'); if(existing) existing.remove();
  const t = document.createElement('div'); t.id = 'monitor-export-toast'; t.className = 'card'; t.style.position='fixed'; t.style.right='12px'; t.style.top='80px'; t.style.zIndex='99999'; t.style.padding='8px 12px';
  t.innerHTML = `<div style="display:flex;gap:8px;align-items:center"><div>Eksport monitoringu utworzony:</div><div style="font-weight:700">${filename}</div><button id="monitor-export-copy" class="btn" style="margin-left:8px">Kopiuj nazwę</button></div>`;
  t.setAttribute('data-filename', filename);
  document.body.appendChild(t);
  try{ const copyBtn = qs('#monitor-export-copy'); if(copyBtn){ copyBtn.addEventListener('click', async ()=>{ try{ await navigator.clipboard.writeText(filename); copyBtn.textContent='Skopiowano'; setTimeout(()=>copyBtn.textContent='Kopiuj nazwę',1000); }catch(_){ try{ const ta=document.createElement('textarea'); ta.value = filename; document.body.appendChild(ta); ta.select(); document.execCommand('copy'); ta.remove(); copyBtn.textContent='Skopiowano'; setTimeout(()=>copyBtn.textContent='Kopiuj nazwę',1000); }catch(__){} } }); } }catch(_){ }
  setTimeout(()=>{ const el = qs('#monitor-export-toast'); if(el) el.remove(); }, 3500);
      }catch(_){ }
      setTimeout(()=>{ try{ URL.revokeObjectURL(url); }catch(_){ } }, 2000);
    }

    // alerts banner
    if((state.storage && state.storage.monitorAlertsEnabled) !== false && heavy.length){
      const banner = document.createElement('div'); banner.className='card err'; banner.style.marginTop='8px'; banner.innerHTML = `<b>ALERT:</b> Zidentyfikowano ${heavy.length} operacji przekraczających threshold (${state.storage.monitorThreshold||5}).`;
      host.appendChild(banner);
    }

    // clickable rows: clicking shows detail list for that operation
    tb.querySelectorAll('tr').forEach((tr, idx)=>{
      tr.style.cursor = 'pointer';
      tr.addEventListener('click', ()=>{
        const existing = qs('#monitor-op-detail'); if(existing) existing.remove();
        const op = top[idx];
        const detail = document.createElement('div'); detail.id = 'monitor-op-detail'; detail.className = 'card'; detail.style.marginTop = '8px';
        const tasks = (state.tasks||[]).filter(t=> (t.opName||'') === op.name );
        if(tasks.length===0){ detail.innerHTML = `<div class="muted">Brak konkretnych zadań dla operacji: ${op.name}</div>`; }
        else{
          detail.innerHTML = `<div><b>Szczegóły: ${op.name}</b> • zadań: ${tasks.length}</div><div style="margin-top:8px">` + tasks.map(t=>`<div>${t.opName} • ${ (state.orders||[]).find(o=>o.id===t.orderId)?.name || t.orderId } • status: ${t.status||'todo'} • est:${t.estMin||0}m • elapsed:${Math.round(t.elapsedMin||0)}m</div>`).join('') + '</div>';
        }
        host.appendChild(detail);
      });
    });
  }

  async function loadScript(src){
    return new Promise((res,rej)=>{
      console.log('Ładowanie skryptu:', src);
      const s=document.createElement('script');
      s.src=src;
      s.onload=()=>{ console.log('Skrypt załadowany:', src); res(); };
      s.onerror=(e)=>{ console.error('Błąd ładowania skryptu:', src, e); rej(new Error('Load fail '+src)); };
      document.head.appendChild(s);
    });
  }
  async function ensureFirebase(){
    if(window.firebase&&firebase.apps&&firebase.apps.length){return true;}
    try{
      const cfg=state.storage.fbConfig||{}; if(!cfg.apiKey) throw new Error('Brak config');
      
      // Sprawdź czy jesteśmy na localhost - jeśli tak, ostrzeż o potencjalnych problemach
      const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
      if(isLocalhost && window.location.protocol !== 'https:'){
        console.warn('Firebase może nie działać poprawnie na HTTP localhost. Rozważ użycie HTTPS lub trybu offline.');
        // Na localhost automatycznie przełącz na localStorage dla lepszego UX
        if(state.storage.mode === 'firebase'){
          console.log('Wykryto localhost - automatycznie przełączam na localStorage dla lepszego działania');
          state.storage.mode = 'localStorage';
          qs('#set-mode').value = 'localStorage';
          save();
          updateConnectionStatus();
          return false;
        }
      }
      
      await loadScript('https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js');
      await loadScript('https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js');
      await loadScript('https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js');
      if(!firebase.apps.length){firebase.initializeApp(cfg);}
      return true;
    }catch(e){
      console.warn('Firebase load/init error:',e.message);
      qs('#set-info').textContent='⚠️ Firebase niedostępny - przełączono na tryb offline (localStorage)';
      
      // Automatycznie przełącz na localStorage gdy Firebase nie działa
      if(state.storage.mode === 'firebase'){
        state.storage.mode = 'localStorage';
        qs('#set-mode').value = 'localStorage';
        save();
        updateConnectionStatus();
        console.log('Automatycznie przełączono na tryb localStorage');
      }
      
      return false;
    }
  }
  function fbRoot(){return firebase.firestore().collection('planner').doc(state.storage.appId).collection('users').doc(state.storage.userId);}
  async function saveToDB(){
    if(state.storage.mode!=='firebase'){qs('#set-info').textContent='Tryb localStorage (offline)';return;}
    const ok=await ensureFirebase(); if(!ok){return;}
    try {
      const db=firebase.firestore(); const batch=db.batch(); const r=fbRoot();
      const up=(name,arr)=> (arr||[]).forEach(x=>{if(!x.id) x.id=uid(); batch.set(r.collection(name).doc(x.id), JSON.parse(JSON.stringify(x)), {merge:true});});
      up('employees',state.employees); up('operationsCatalog',state.operationsCatalog); up('processes',state.processes);
      up('orders',state.orders); up('tasks',state.tasks); up('after',state.after);
      await batch.commit();
      qs('#set-info').textContent='✅ Zapisano kolekcje do DB.';
    } catch(e) {
      qs('#set-info').textContent='❌ Błąd zapisu do DB: '+e.message;
    }
  }
  // Save single task document to Firestore (merge)
  async function _saveTaskToDB_once(taskId){
    const ok = await ensureFirebase(); if(!ok) throw new Error('Firebase not ready');
    const t = (state.tasks||[]).find(x=>x.id===taskId); if(!t) throw new Error('task not found');
    const payload = JSON.parse(JSON.stringify(t));
    await fbRoot().collection('tasks').doc(taskId).set(payload, { merge: true });
  }

  async function saveTaskToDB(taskId, opts){
    if(!taskId) return;
    if(state.storage.mode !== 'firebase') return;
    const attempts = (opts && opts.attempts) || 3;
    const base = (opts && opts.baseDelayMs) || 500;
    const t = (state.tasks||[]).find(x=>x.id===taskId);
    if(!t) return;
    t._syncPending = true; t._syncError = false; save(); try{ renderTasks(); }catch(_){ }
    let lastErr = null;
    for(let i=0;i<attempts;i++){
      try{ await _saveTaskToDB_once(taskId); t._syncPending = false; t._lastSync = Date.now(); t._syncError = false; save(); try{ renderTasks(); }catch(_){ } (window.logDev||console.log)('[saveTaskToDB] saved', taskId, 'attempt', i+1); return; }
      catch(e){ lastErr = e; (window.logDev||console.warn)('saveTaskToDB attempt failed', i+1, e && e.message); if(i < attempts - 1){ const delay = base * Math.pow(2, i); await new Promise(r=>setTimeout(r, delay)); } }
    }
    try{ t._syncPending = false; t._syncError = true; save(); try{ renderTasks(); }catch(_){ } }catch(_){ }
    console.warn('saveTaskToDB all attempts failed', lastErr && lastErr.message);
    throw lastErr;
  }

  // Subscribe to tasks collection updates from Firestore and merge into local state
  async function subscribeToTaskUpdates(){
    if(state.storage.mode !== 'firebase') return;
    let isInitialLoad = true;
    try{
      const ok = await ensureFirebase(); if(!ok) return;
      if(window._tasksUnsub) try{ window._tasksUnsub(); }catch(_){ }
      const col = fbRoot().collection('tasks');
      window._tasksUnsub = col.onSnapshot(snapshot=>{
        try{
          snapshot.docChanges().forEach(ch=>{
            const data = Object.assign({id: ch.doc.id}, ch.doc.data());
            if(ch.type === 'added' || ch.type === 'modified'){
              const idx = (state.tasks||[]).findIndex(t=>t.id === data.id);
              if(idx >= 0){ state.tasks[idx] = Object.assign({}, state.tasks[idx], data); }
              else if(!isInitialLoad || ch.type === 'modified') { state.tasks = state.tasks || []; state.tasks.push(data); }
            } else if(ch.type === 'removed'){
              state.tasks = (state.tasks||[]).filter(t=>t.id !== data.id);
            }
          });
          isInitialLoad = false;
          snapshot.docs.forEach(d=>{
            const id = d.id; const idx = (state.tasks||[]).findIndex(t=>t.id===id);
            if(idx>=0){ state.tasks[idx]._lastSync = Date.now(); state.tasks[idx]._syncPending = false; state.tasks[idx]._syncError = false; }
          });
          save(); try{ renderTasks(); renderMonitor && renderMonitor(); }catch(_){ }
        }catch(e){ console.warn('subscribeToTaskUpdates snapshot error', e && e.message); }
      }, err=>{ console.warn('tasks onSnapshot error', err && err.message); });
      (window.logDev||console.log)('[subscribeToTaskUpdates] subscribed');
    }catch(e){ console.warn('subscribeToTaskUpdates error', e && e.message); }
  }

  (async function autoSubscribeIfNeeded(){ try{ if(state.storage && state.storage.mode==='firebase' && state.storage.autoLoadFromDB){ await subscribeToTaskUpdates(); } }catch(e){ console.warn('autoSubscribeIfNeeded err', e && e.message); } })();
  async function loadFromDB(){
    if(state.storage.mode!=='firebase'){qs('#set-info').textContent='Tryb localStorage (offline)';return;}
    const ok=await ensureFirebase(); if(!ok){return;}
    try {
      const r=fbRoot();
      const getAll=async(name)=>(await r.collection(name).get()).docs.map(d=>({id:d.id,...d.data()}));
      const [employees,operationsCatalog,processes,orders,tasks,after]=await Promise.all([
        getAll('employees'),getAll('operationsCatalog'),getAll('processes'),getAll('orders'),getAll('tasks'),getAll('after')
      ]);

      const remoteCollections = { employees, operationsCatalog, processes, orders, tasks, after };
      const localCollections = {
        employees: state.employees || [],
        operationsCatalog: state.operationsCatalog || [],
        processes: state.processes || [],
        orders: state.orders || [],
        tasks: state.tasks || [],
        after: state.after || []
      };

      const remoteCountTotal = Object.values(remoteCollections)
        .reduce((sum, collection)=> sum + (Array.isArray(collection) ? collection.length : (collection && typeof collection === 'object' ? Object.keys(collection).length : 0)), 0);
      const localCountTotal = Object.values(localCollections)
        .reduce((sum, collection)=> sum + (Array.isArray(collection) ? collection.length : (collection && typeof collection === 'object' ? Object.keys(collection).length : 0)), 0);

      if(remoteCountTotal === 0 && localCountTotal > 0){
        console.warn('[firebase] loadFromDB: zdalne kolekcje są puste – pomijam nadpisanie lokalnych danych.');
        qs('#set-info').textContent='⚠️ Brak danych w Firebase – zachowano lokalne dane.';
        return { skipped: true, reason: 'empty-remote' };
      }

      const skipped = [];
      const updated = [];
      Object.entries(remoteCollections).forEach(([key, collection])=>{
        const remoteLen = Array.isArray(collection) ? collection.length : (collection && typeof collection === 'object' ? Object.keys(collection).length : 0);
        const localLen = Array.isArray(localCollections[key]) ? localCollections[key].length : (localCollections[key] && typeof localCollections[key] === 'object' ? Object.keys(localCollections[key]).length : 0);

        if(remoteLen === 0 && localLen > 0){
          skipped.push(key);
          return;
        }

        state[key] = Array.isArray(collection) ? collection.slice() : (collection ? JSON.parse(JSON.stringify(collection)) : Array.isArray(state[key]) ? [] : {});
        updated.push(key);
      });

      if(updated.length === 0){
        console.log('[firebase] loadFromDB: brak zmian po wczytaniu danych (wszystkie kolekcje puste).');
        qs('#set-info').textContent = skipped.length ? '⚠️ Część kolekcji w Firebase była pusta – zachowano lokalne dane.' : 'ℹ️ Brak zmian – kolekcje Firebase puste.';
        return { skippedCollections: skipped };
      }

      save();
      if(skipped.length){
        console.warn('[firebase] loadFromDB: pominięto puste kolekcje', skipped);
      }
      qs('#set-info').textContent = skipped.length ? '✅ Wczytano dane z Firebase (pominięto puste kolekcje).' : '✅ Wczytano dane z Firebase.';
      if(state.page==='order') renderOrderPage(); if(state.page==='tasks') renderTasks(); if(state.page==='opcat') renderOps();
  if(state.page==='proc') renderProcPage(); if(state.page==='emp') renderEmployees(); if(state.page==='as') renderASPage(); renderDash(); renderGantt();
      return { updatedCollections: updated, skippedCollections: skipped };
    } catch(e) {
      qs('#set-info').textContent='❌ Błąd wczytywania z DB: '+e.message;
      throw e;
    }
  }
  qs('#set-test').addEventListener('click',async()=>{
    try{
  state.storage.mode=qs('#set-mode').value; state.storage.appId=qs('#set-appid').value.trim(); state.storage.userId=qs('#set-userid').value.trim();
  if(typeof updateScheduleConfigFromUI === 'function'){ updateScheduleConfigFromUI(); }
  try{ if(window.scheduleCore){ window.scheduleCore.generateSchedule(state); } }catch(e){ console.warn('regen schedule', e.message); }
  renderGantt();
      try{state.storage.fbConfig=JSON.parse(qs('#set-fb').value||'{}');}catch(e){qs('#set-info').textContent='Błędny JSON';return;}
      save(); updateConnectionStatus(); if(state.storage.mode!=='firebase'){qs('#set-info').textContent='Tryb localStorage (offline)';return;}
      const ok=await ensureFirebase(); if(!ok) throw new Error('Firebase init failed');
      const cred=await firebase.auth().signInAnonymously(); qs('#set-info').textContent='✅ Połączono. UID: '+(cred.user&&cred.user.uid);
    }catch(e){qs('#set-info').textContent='❌ Błąd: '+e.message;}
  });
  qs('#set-save').addEventListener('click',saveToDB);
  qs('#set-load').addEventListener('click',loadFromDB);

  // Export/import tasks and assignments
  function exportTasks(){
    const payload = { exportedAt: new Date().toISOString(), tasks: state.tasks || [], assignments: (state.tasks||[]).map(t=>({id:t.id,assignees:t.assignees||[]})) };
    const blob=new Blob([JSON.stringify(payload,null,2)],{type:'application/json'});
    const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='tasks_export_'+(new Date().toISOString().slice(0,10))+'.json'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  }
  async function importTasksFromFile(file){
    try{
      const text = await file.text(); const obj = JSON.parse(text);
      if(!obj || !Array.isArray(obj.tasks)) { alert('Nieprawidłowy plik'); return; }
      // Merge: replace tasks, but preserve employees and orders mapping
      state.tasks = obj.tasks.map(t=>({id:t.id||uid(), orderId:t.orderId||'', opName:t.opName||'', status:t.status||'todo', elapsedMin:t.elapsedMin||0, estMin:t.estMin||0, assignees:t.assignees||[]}));
      save(); renderTasks(); maybeAutoSave('import-tasks');
      alert('Zaimportowano zadania: '+state.tasks.length);
    }catch(e){ alert('Błąd importu: '+e.message); }
  }
  qs('#export-tasks').addEventListener('click',exportTasks);
  qs('#import-tasks').addEventListener('click',()=>qs('#import-tasks-file').click());
  qs('#import-tasks-file').addEventListener('change',(ev)=>{ const f=ev.target.files&&ev.target.files[0]; if(f) importTasksFromFile(f); });
  qs('#restore-click-delegation').addEventListener('click', () => {
    window.restoreNormalClickDelegation();
    alert('Przywrócono normalną obsługę kliknięć! Spróbuj teraz kliknąć w inne przyciski.');
  });
  qs('#capacity-refresh').addEventListener('click', () => renderCapacityAnalysis());
  qs('#capacity-optimize').addEventListener('click', () => {
    const suggestions = calculateOptimizationSuggestions();
    if(suggestions.length === 0){
      alert('Obciążenie jest już zoptymalizowane! 🎉');
    } else {
      alert(`Znaleziono ${suggestions.length} sugestii optymalizacji. Sprawdź sekcję "Sugestie optymalizacji obciążenia".`);
      renderOptimizationSuggestions(suggestions);
    }
  });
  qs('#capacity-export').addEventListener('click', () => {
    const utilization = calculateResourceUtilization(qs('#capacity-period').value || 'week');
    if(utilization.length === 0){ alert('Brak danych do eksportu.'); return; }
    const csv = ['employee,totalTasks,totalTimeH,availableTimeH,utilizationPercent,status'].concat(
      utilization.map(u => `"${u.employee}","${u.totalTasks}","${(u.totalTime/60).toFixed(1)}","${(u.availableTime/60).toFixed(1)}","${u.utilization}","${u.status}"`)
    ).join('\n');
    const blob = new Blob([csv], {type:'text/csv'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'capacity_analysis_' + new Date().toISOString().slice(0,10) + '.csv';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  });
  qs('#restore-authentic-data').addEventListener('click', () => {
    if (confirm('Czy na pewno chcesz przywrócić autentyczne dane? To nadpisze wszystkie obecne dane w aplikacji.')) {
      restoreAuthenticData();
    }
  });

  // Reports event handlers
  const reportGenerateTestBtn = qs('#report-generate-test');
  if(reportGenerateTestBtn){ 
    reportGenerateTestBtn.addEventListener('click', () => {
      generateGanttTestData(); // Używa istniejącej funkcji
      renderReports();
    });
  }
  
  const reportGenerateBtn = qs('#report-generate');
  if(reportGenerateBtn){ 
    reportGenerateBtn.addEventListener('click', () => {
      renderReports();
    });
  }
  
  const reportExportBtn = qs('#report-export');
  if(reportExportBtn){ 
    reportExportBtn.addEventListener('click', () => {
      exportReportToPDF();
    });
  }

  nav(state.page||'dash'); renderDash(); renderGantt();
})();

  // After initial render, optionally auto-load data from Firebase when configured
  (async function autoLoadIfNeeded(){
    try{
      if(state.storage.mode==='firebase' && state.storage.autoLoadFromDB){
        window.logDev && window.logDev('[auto-load] Wczytywanie danych z Firebase...'); busy(true);
        const loadResult = await loadFromDB();
        if(loadResult && loadResult.skipped){
          window.logDev && window.logDev('[auto-load] Pomiń auto-load – zdalne kolekcje puste.');
        } else if(loadResult && Array.isArray(loadResult.skippedCollections) && loadResult.skippedCollections.length){
          window.logDev && window.logDev('[auto-load] Wczytano dane, pominięto kolekcje:', loadResult.skippedCollections);
        } else {
          window.logDev && window.logDev('[auto-load] Wczytano dane z Firebase.');
        }
      }
    }catch(e){ window.logDev && window.logDev('[auto-load] Błąd:', e && e.message); }
    finally{ busy(false); }
  })();
  console.log('build v5.6.27');

  // Check if backup functions are available before assigning
  if (typeof createBackup !== 'undefined') {
    // Make backup functions globally available
    window.createBackup = createBackup;
    window.restoreFromBackup = restoreFromBackup;
    window.deleteBackup = deleteBackup;
    window.exportBackup = exportBackup;
    window.importBackupFromFile = importBackupFromFile;
    window.cleanupOldBackups = cleanupOldBackups;
  } else {
    console.warn('Backup functions not available - skipping assignment');
  }

  // === ADVANCED GANTT FEATURES ===

  // Global state for Gantt visualization
  window.ganttShowDependencies = false;
  window.ganttShowCriticalPath = false;
  window.ganttCreatingDependency = false;
  window.ganttDependencyFrom = null;

  // Initialize drag & drop functionality for Gantt tasks
  function initGanttDragDrop() {
    const container = qs('#gantt-container');
    if (!container) return;

    let draggedTask = null;
    let dragOffset = { x: 0, y: 0 };
    let dropZone = null;

    // Add drag event listeners to all tasks
    document.querySelectorAll('.gantt-task').forEach(taskEl => {
      taskEl.draggable = true;
      taskEl.addEventListener('dragstart', handleDragStart);
      taskEl.addEventListener('dragend', handleDragEnd);
      taskEl.addEventListener('click', handleTaskClick);
    });

    // Add drop zones to task cells
    document.querySelectorAll('.gantt-task-cell').forEach(cell => {
      cell.addEventListener('dragover', handleDragOver);
      cell.addEventListener('drop', handleDrop);
      cell.addEventListener('dragleave', handleDragLeave);
    });

    function handleDragStart(e) {
      draggedTask = e.target.closest('.gantt-task');
      if (!draggedTask) return;

      draggedTask.classList.add('dragging');

      // Calculate offset for smooth dragging
      const rect = draggedTask.getBoundingClientRect();
      dragOffset.x = e.clientX - rect.left;
      dragOffset.y = e.clientY - rect.top;

      // Create drop zone indicator
      createDropZone(e.clientX, e.clientY);
    }

    function handleDragEnd(e) {
      if (draggedTask) {
        draggedTask.classList.remove('dragging');
      }

      // Remove drop zone
      if (dropZone) {
        dropZone.remove();
        dropZone = null;
      }

      draggedTask = null;
    }

    function handleDragOver(e) {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';

      if (dropZone) {
        updateDropZone(e.clientX, e.clientY);
      }
    }

    function handleDrop(e) {
      e.preventDefault();

      if (!draggedTask || !dropZone) return;

      const taskId = draggedTask.getAttribute('data-task-id');
      const newDate = calculateDropDate(e.clientX);

      console.log('Drop:', taskId, newDate, e.clientX);

      if (newDate && taskId) {
        updateTaskDate(taskId, newDate);
        renderGantt();
      }
    }

    function handleTaskClick(e) {
      // Prevent click when dragging
      if (draggedTask) return;

      const taskId = e.currentTarget.getAttribute('data-task-id');
      if (taskId) {
        handleTaskClickForDependency(taskId);
      }
    }

    function handleDragLeave(e) {
      // Optional: handle drag leave effects
      // This function is required by the event listener but may be empty
    }

    function createDropZone(x, y) {
      const timeline = qs('#gantt-timeline');
      const timelineWidth = timeline.getBoundingClientRect().width;
      const viewMode = qs('#gantt-view').value || 'week';
      const daysCount = viewMode === 'week' ? 7 : 30;
      const slotWidth = timelineWidth / daysCount;

      dropZone = document.createElement('div');
      dropZone.className = 'gantt-drop-zone';
      dropZone.style.width = slotWidth + 'px';
      dropZone.style.height = draggedTask.offsetHeight + 'px';
      dropZone.addEventListener('drop', handleDrop);
      document.body.appendChild(dropZone);
      updateDropZone(x, y);
    }

    function updateDropZone(x, y) {
      if (!dropZone) return;

      const rect = container.getBoundingClientRect();
      const relativeX = x - rect.left - dragOffset.x;
      const relativeY = y - rect.top - dragOffset.y;

      dropZone.style.left = (rect.left + relativeX) + 'px';
      dropZone.style.top = (rect.top + relativeY) + 'px';

      // Validate drop position - always valid for now (show as valid)
      const isValid = true; // Simplified - allow dropping anywhere
      dropZone.className = 'gantt-drop-zone ' + (isValid ? 'valid' : 'invalid');
    }

    function calculateDropDate(clientX) {
      const timeline = qs('#gantt-timeline');
      const container = qs('#gantt-container');
      const rect = container.getBoundingClientRect();
      const timelineRect = timeline.getBoundingClientRect();

      // Calculate relative position in timeline
      const relativeX = clientX - timelineRect.left;
      const timelineWidth = timelineRect.width;

      if (relativeX < 0 || relativeX > timelineWidth) return null;

      // Get timeline start date
      const viewMode = qs('#gantt-view').value || 'week';
      const daysCount = viewMode === 'week' ? 7 : 30;
      const slotWidth = timelineWidth / daysCount;

      // Calculate which day was clicked with snap-to-center
      const positionInSlot = relativeX % slotWidth;
      let dayIndex = Math.floor(relativeX / slotWidth);
      
      // Snap to center of slot for better precision
      if (positionInSlot > slotWidth * 0.5) {
        // If in right half of slot, snap to next day
        dayIndex += 1;
      }
      
      const startDate = getGanttStartDate();

      const newDate = new Date(startDate);
      newDate.setDate(startDate.getDate() + dayIndex);
      // Set to middle of day for consistency
      newDate.setHours(12, 0, 0, 0);

      console.log('CalculateDropDate:', clientX, timelineRect.left, relativeX, slotWidth, dayIndex, 'posInSlot:', positionInSlot, startDate.toISOString(), newDate.toISOString());

      return newDate.getTime();
    }

    function isValidDropPosition(x, y) {
      // More lenient validation - allow dropping anywhere in timeline area
      const timeline = qs('#gantt-timeline');
      const body = qs('#gantt-body');
      if (!timeline || !body) return true; // Allow if elements not found
      
      const timelineRect = timeline.getBoundingClientRect();
      const bodyRect = body.getBoundingClientRect();
      
      // Allow if within reasonable bounds (with some tolerance)
      return x >= -50 && x <= timelineRect.width + 50 && y >= -20 && y <= bodyRect.height + 20;
    }

    function updateTaskDate(taskId, newTimestamp) {
      const task = (state.tasks || []).find(t => t.id === taskId);
      if (!task) return;

      // Update task start date
      task.startPlanned = newTimestamp;

      // Recalculate end date based on duration
      const durationMs = (task.estMin || 60) * 60 * 1000; // Convert minutes to milliseconds
      task.endPlanned = newTimestamp + durationMs;

      console.log('Updated task', taskId, 'to', new Date(newTimestamp).toLocaleDateString('pl-PL'), 'old was', task.startPlanned ? new Date(task.startPlanned).toLocaleDateString('pl-PL') : 'none');

      save();
    }

    function getGanttStartDate() {
      let minDate = new Date();
      (state.tasks || []).forEach(t => {
        if (t.startPlanned && t.startPlanned < minDate.getTime()) {
          minDate = new Date(t.startPlanned);
        }
      });

      const startDate = new Date(minDate);
      startDate.setDate(startDate.getDate() - startDate.getDay());
      startDate.setHours(0, 0, 0, 0);
      return startDate;
    }
  }

  // Update Gantt button states
  function updateGanttButtons() {
    const depBtn = qs('#gantt-show-dependencies');
    const createDepBtn = qs('#gantt-create-dependency');
    const critBtn = qs('#gantt-show-critical-path');

    if (depBtn) {
      depBtn.classList.toggle('primary', window.ganttShowDependencies);
    }
    if (createDepBtn) {
      createDepBtn.classList.toggle('primary', window.ganttCreatingDependency);
    }
    if (critBtn) {
      critBtn.classList.toggle('primary', window.ganttShowCriticalPath);
    }
  }

  // Toggle dependencies visualization
  function toggleDependencies() {
    console.log('🔵 toggleDependencies called! Current state:', window.ganttShowDependencies);
    window.ganttShowDependencies = !window.ganttShowDependencies;
    console.log('🔵 New state:', window.ganttShowDependencies);
    updateGanttButtons();

    if (window.ganttShowDependencies) {
      console.log('🔵 Calling renderDependencies()...');
      renderDependencies();
    } else {
      console.log('🔵 Calling clearDependencies()...');
      clearDependencies();
    }
  }

  // Toggle critical path visualization
  function toggleCriticalPath() {
    window.ganttShowCriticalPath = !window.ganttShowCriticalPath;
    updateGanttButtons();

    if (window.ganttShowCriticalPath) {
      calculateAndShowCriticalPath();
    } else {
      clearCriticalPath();
    }
  }

  // Toggle dependency creation mode
  function toggleDependencyCreation() {
    window.ganttCreatingDependency = !window.ganttCreatingDependency;
    window.ganttDependencyFrom = null;
    updateGanttButtons();

    if (window.ganttCreatingDependency) {
      alert('Tryb tworzenia zależności włączony. Kliknij na pierwsze zadanie, a następnie na zadanie docelowe.');
    } else {
      alert('Tryb tworzenia zależności wyłączony.');
    }
  }

  // Handle task click for dependency creation
  function handleTaskClickForDependency(taskId) {
    if (!window.ganttCreatingDependency) return;

    if (!window.ganttDependencyFrom) {
      // First task selected
      window.ganttDependencyFrom = taskId;
      const taskEl = document.querySelector(`[data-task-id="${taskId}"]`);
      if (taskEl) {
        taskEl.classList.add('dependency-from');
      }
      alert('Wybrano pierwsze zadanie. Teraz kliknij na zadanie docelowe.');
    } else if (window.ganttDependencyFrom === taskId) {
      // Same task clicked - cancel
      const taskEl = document.querySelector(`[data-task-id="${taskId}"]`);
      if (taskEl) {
        taskEl.classList.remove('dependency-from');
      }
      window.ganttDependencyFrom = null;
      alert('Anulowano wybór. Kliknij ponownie na pierwsze zadanie.');
    } else {
      // Second task selected - create dependency
      createManualDependency(window.ganttDependencyFrom, taskId);

      // Reset state
      const fromEl = document.querySelector(`[data-task-id="${window.ganttDependencyFrom}"]`);
      if (fromEl) {
        fromEl.classList.remove('dependency-from');
      }
      window.ganttDependencyFrom = null;
      window.ganttCreatingDependency = false;
      updateGanttButtons();
    }
  }

  // Create manual dependency between two tasks
  function createManualDependency(fromTaskId, toTaskId) {
    if (!state.taskDependencies) {
      state.taskDependencies = [];
    }

    // Check if dependency already exists
    const existing = state.taskDependencies.find(dep =>
      dep.from === fromTaskId && dep.to === toTaskId
    );

    if (existing) {
      alert('Ta zależność już istnieje!');
      return;
    }

    // Add new dependency
    state.taskDependencies.push({
      id: uid(),
      from: fromTaskId,
      to: toTaskId,
      type: 'finish-to-start',
      manual: true
    });

    save();
    renderGantt();
    if (window.ganttShowDependencies) {
      renderDependencies();
    }
    alert('Zależność została utworzona!');
  }

  // Delete manual dependency
  function deleteManualDependency(dependencyId) {
    if (!state.taskDependencies) return;

    const index = state.taskDependencies.findIndex(dep => dep.id === dependencyId);
    if (index !== -1) {
      state.taskDependencies.splice(index, 1);
      save();
      renderGantt();
      if (window.ganttShowDependencies) {
        renderDependencies();
      }
    }
  }

  // Show dependency management dialog
  function showDependencyManager() {
    const dependencies = state.taskDependencies || [];
    const tasks = state.tasks || [];

    let html = '<div style="max-height: 400px; overflow-y: auto;">';
    html += '<h4>Ręczne zależności między zadaniami</h4>';

    if (dependencies.length === 0) {
      html += '<p>Brak ręcznych zależności. Użyj przycisku "Utwórz zależność" aby dodać pierwszą.</p>';
    } else {
      html += '<div style="display: grid; gap: 8px;">';
      dependencies.forEach(dep => {
        const fromTask = tasks.find(t => t.id === dep.from);
        const toTask = tasks.find(t => t.id === dep.to);

        const fromName = fromTask ? (fromTask.opName || fromTask.name || 'Zadanie') : 'Nieznane';
        const toName = toTask ? (toTask.opName || toTask.name || 'Zadanie') : 'Nieznane';

        html += `
          <div style="display: flex; align-items: center; justify-content: space-between; padding: 8px; border: 1px solid var(--b); border-radius: 4px;">
            <div>
              <strong>${fromName}</strong> → <strong>${toName}</strong>
              <div style="font-size: 12px; color: var(--text-secondary);">${dep.type}</div>
            </div>
            <button class="btn red tiny" onclick="deleteManualDependency('${dep.id}')" title="Usuń zależność">🗑️</button>
          </div>
        `;
      });
      html += '</div>';
    }

    html += '</div>';

    // Show modal dialog
    showModal('Zarządzanie zależnościami', html, [
      { text: 'Zamknij', action: () => {} }
    ]);
  }

  // Render task dependencies
  function renderDependencies() {
    console.log('📊 renderDependencies() WYWOŁANA!');
    const svg = qs('#gantt-dependencies');
    if (!svg) {
      console.error('❌ SVG gantt-dependencies not found!');
      return;
    }
    console.log('✅ SVG element found:', svg);

    // Clear existing dependencies
    svg.innerHTML = '';

    const tasks = state.tasks || [];
    console.log('📋 Total tasks:', tasks.length);
    console.log('📋 Tasks:', tasks.map(t => ({id: t.id, name: t.opName, opIndex: t.opIndex, orderId: t.orderId})));
    
    const dependencies = calculateTaskDependencies(tasks);
    
    console.log('🔗 Dependencies found:', dependencies.length);
    console.log('🔗 Dependencies:', dependencies);
    console.log('📅 Tasks with startPlanned:', tasks.filter(t => t.startPlanned).length);

    dependencies.forEach(dep => {
      const fromTask = tasks.find(t => t.id === dep.from);
      const toTask = tasks.find(t => t.id === dep.to);

      if (fromTask && toTask && fromTask.startPlanned && toTask.startPlanned) {
        console.log('✅ Drawing dependency from', fromTask.opName, 'to', toTask.opName);
        drawDependencyLine(svg, fromTask, toTask, dep.type, dep.manual);
      } else {
        console.log('⚠️ Skipping dependency - missing data:', {
          from: fromTask?.opName || 'NOT FOUND',
          to: toTask?.opName || 'NOT FOUND',
          fromStartPlanned: !!fromTask?.startPlanned,
          toStartPlanned: !!toTask?.startPlanned
        });
      }
    });
  }

  // Calculate task dependencies based on process order and manual dependencies
  function calculateTaskDependencies(tasks) {
    const dependencies = [];

    // Add automatic dependencies based on process order
    const tasksByOrder = {};
    tasks.forEach(task => {
      if (!tasksByOrder[task.orderId]) {
        tasksByOrder[task.orderId] = [];
      }
      tasksByOrder[task.orderId].push(task);
    });

    // For each order, create dependencies based on process operations
    Object.values(tasksByOrder).forEach(orderTasks => {
      // Sort tasks by their position in the process
      orderTasks.sort((a, b) => {
        const orderA = a.opIndex || 0;
        const orderB = b.opIndex || 0;
        return orderA - orderB;
      });

      // Create finish-to-start dependencies
      for (let i = 0; i < orderTasks.length - 1; i++) {
        dependencies.push({
          from: orderTasks[i].id,
          to: orderTasks[i + 1].id,
          type: 'finish-to-start',
          manual: false
        });
      }
    });

    // Add manual dependencies
    if (state.taskDependencies) {
      state.taskDependencies.forEach(dep => {
        dependencies.push({
          from: dep.from,
          to: dep.to,
          type: dep.type || 'finish-to-start',
          manual: true,
          id: dep.id
        });
      });
    }

    return dependencies;
  }

  // Draw dependency line between two tasks
  function drawDependencyLine(svg, fromTask, toTask, type, isManual = false) {
    console.log('drawDependencyLine called for:', fromTask.id, '->', toTask.id);
    
    const ganttContainer = qs('#gantt-container');
    const ganttBody = qs('#gantt-body');
    if (!ganttContainer || !ganttBody) {
      console.log('Gantt containers not found');
      return;
    }

    // Get task elements
    const fromEl = document.querySelector(`[data-task-id="${fromTask.id}"]`);
    const toEl = document.querySelector(`[data-task-id="${toTask.id}"]`);

    if (!fromEl || !toEl) {
      console.log('Task elements not found:', {
        fromEl: !!fromEl,
        toEl: !!toEl,
        fromTaskId: fromTask.id,
        toTaskId: toTask.id
      });
      return;
    }

    // Get the parent task cells (which contain positioning)
    const fromCell = fromEl.closest('.gantt-task-cell');
    const toCell = toEl.closest('.gantt-task-cell');
    
    if (!fromCell || !toCell) {
      console.log('Task cells not found:', {
        fromCell: !!fromCell,
        toCell: !!toCell
      });
      return;
    }

    // Calculate positions using getBoundingClientRect for accurate positioning
    const ganttBodyRect = ganttBody.getBoundingClientRect();
    const fromRect = fromEl.getBoundingClientRect();
    const toRect = toEl.getBoundingClientRect();
    
    const fromX = fromRect.right - ganttBodyRect.left;
    const fromY = fromRect.top + fromRect.height / 2 - ganttBodyRect.top;
    const toX = toRect.left - ganttBodyRect.left;
    const toY = toRect.top + toRect.height / 2 - ganttBodyRect.top;

    console.log('Calculated positions:', {
      fromX, fromY, toX, toY
    });

    // Set SVG size to match gantt body
    svg.setAttribute('width', ganttBody.scrollWidth);
    svg.setAttribute('height', ganttBody.scrollHeight);
    svg.style.width = ganttBody.scrollWidth + 'px';
    svg.style.height = ganttBody.scrollHeight + 'px';

    // Create SVG path
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.className = `gantt-dependency-line ${isManual ? 'manual' : ''}`;
    path.setAttribute('stroke', isManual ? '#3b82f6' : '#94a3b8');
    path.setAttribute('stroke-width', isManual ? '3' : '2');
    path.setAttribute('fill', 'none');
    path.setAttribute('stroke-linecap', 'round');

    // Calculate path - use simple elbow connection
    const deltaX = toX - fromX;
    const deltaY = toY - fromY;
    
    let d;
    if (Math.abs(deltaY) < 5) {
      // Same row - direct horizontal line
      d = `M ${fromX} ${fromY} L ${toX} ${toY}`;
    } else if (deltaX > 20) {
      // Forward dependency - elbow connection
      const midX = fromX + Math.max(20, deltaX / 2);
      d = `M ${fromX} ${fromY} L ${midX} ${fromY} L ${midX} ${toY} L ${toX} ${toY}`;
    } else {
      // Backward dependency - curved connection
      const controlX1 = fromX + 40;
      const controlY1 = fromY;
      const controlX2 = toX - 40;
      const controlY2 = toY;
      d = `M ${fromX} ${fromY} C ${controlX1} ${controlY1}, ${controlX2} ${controlY2}, ${toX} ${toY}`;
    }
    
    console.log('SVG path:', d);
    path.setAttribute('d', d);
    svg.appendChild(path);

    // Add arrow
    const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
    arrow.className = `gantt-dependency-arrow ${isManual ? 'manual' : ''}`;
    
    // Arrow pointing to the target task
    const arrowSize = 8;
    let arrowPoints;
    
    if (Math.abs(deltaY) < 5) {
      // Horizontal arrow
      arrowPoints = `${toX-arrowSize},${toY-arrowSize/2} ${toX},${toY} ${toX-arrowSize},${toY+arrowSize/2}`;
    } else {
      // Vertical component exists
      if (deltaX > 20) {
        // Forward dependency - horizontal arrow
        arrowPoints = `${toX-arrowSize},${toY-arrowSize/2} ${toX},${toY} ${toX-arrowSize},${toY+arrowSize/2}`;
      } else {
        // Backward dependency - curved arrow
        const angle = Math.atan2(deltaY, -40); // Direction from control point
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const p1x = toX - arrowSize * cos - (arrowSize/2) * sin;
        const p1y = toY - arrowSize * sin + (arrowSize/2) * cos;
        const p2x = toX - arrowSize * cos + (arrowSize/2) * sin;
        const p2y = toY - arrowSize * sin - (arrowSize/2) * cos;
        arrowPoints = `${p1x},${p1y} ${toX},${toY} ${p2x},${p2y}`;
      }
    }
    
    console.log('Arrow points:', arrowPoints);
    arrow.setAttribute('points', arrowPoints);
    arrow.setAttribute('fill', isManual ? '#3b82f6' : '#94a3b8');
    svg.appendChild(arrow);
    
    console.log('Dependency line added to SVG');
  }

  // Clear dependencies visualization
  function clearDependencies() {
    const svg = qs('#gantt-dependencies');
    if (svg) {
      svg.innerHTML = '';
    }
  }

  // Calculate and show critical path
  function calculateAndShowCriticalPath() {
    const tasks = state.tasks || [];
    const criticalTasks = calculateCriticalPath(tasks);

    // Highlight critical tasks
    criticalTasks.forEach(taskId => {
      const taskEl = document.querySelector(`[data-task-id="${taskId}"]`);
      if (taskEl) {
        taskEl.classList.add('critical-path');
      }
    });

    // Show float indicators for non-critical tasks
    tasks.forEach(task => {
      if (!criticalTasks.includes(task.id)) {
        const float = calculateTaskFloat(task, tasks);
        showFloatIndicator(task, float);
      }
    });
  }

  // Calculate critical path using CPM (Critical Path Method)
  function calculateCriticalPath(tasks) {
    if (!tasks || tasks.length === 0) return [];

    // Create task map for easy lookup
    const taskMap = {};
    tasks.forEach(task => {
      taskMap[task.id] = {
        ...task,
        predecessors: [],
        successors: [],
        earlyStart: 0,
        earlyFinish: 0,
        lateStart: Infinity,
        lateFinish: Infinity
      };
    });

    // Build dependency graph
    const dependencies = calculateTaskDependencies(tasks);
    dependencies.forEach(dep => {
      if (taskMap[dep.from] && taskMap[dep.to]) {
        taskMap[dep.from].successors.push(dep.to);
        taskMap[dep.to].predecessors.push(dep.from);
      }
    });

    // Forward pass - calculate early start/finish
    const visited = new Set();
    function forwardPass(taskId) {
      if (visited.has(taskId)) return;
      visited.add(taskId);

      const task = taskMap[taskId];
      const duration = task.estMin || 60; // minutes

      // Process predecessors first
      task.predecessors.forEach(predId => {
        forwardPass(predId);
        const pred = taskMap[predId];
        task.earlyStart = Math.max(task.earlyStart, pred.earlyFinish);
      });

      task.earlyFinish = task.earlyStart + duration;
    }

    // Start from tasks with no predecessors
    Object.values(taskMap).forEach(task => {
      if (task.predecessors.length === 0) {
        forwardPass(task.id);
      }
    });

    // Backward pass - calculate late start/finish
    const reverseVisited = new Set();
    function backwardPass(taskId) {
      if (reverseVisited.has(taskId)) return;
      reverseVisited.add(taskId);

      const task = taskMap[taskId];

      // If no successors, late finish equals early finish
      if (task.successors.length === 0) {
        task.lateFinish = task.earlyFinish;
      } else {
        // Process successors first
        task.successors.forEach(succId => {
          backwardPass(succId);
          const succ = taskMap[succId];
          task.lateFinish = Math.min(task.lateFinish, succ.lateStart);
        });
      }

      task.lateStart = task.lateFinish - (task.estMin || 60);
    }

    // Start from tasks with no successors
    Object.values(taskMap).forEach(task => {
      if (task.successors.length === 0) {
        backwardPass(task.id);
      }
    });

    // Find critical path (tasks with zero float)
    const criticalPath = [];
    Object.values(taskMap).forEach(task => {
      const float = task.lateFinish - task.earlyFinish;
      if (Math.abs(float) < 1) { // Consider float < 1 minute as critical
        criticalPath.push(task.id);
      }
    });

    console.log('Critical path calculated:', criticalPath.length, 'tasks');
    return criticalPath;
  }

  // Calculate float for a task
  function calculateTaskFloat(task, allTasks) {
    // Simplified float calculation
    const duration = task.estMin || 60;
    const successors = findTaskSuccessors(task, allTasks);

    if (successors.length === 0) {
      return 0; // End task has no float
    }

    // Calculate minimum slack to successors
    let minSlack = Infinity;
    successors.forEach(succ => {
      const succStart = succ.startPlanned || Date.now();
      const taskEnd = (task.startPlanned || Date.now()) + (duration * 60 * 1000);
      const slack = succStart - taskEnd;
      minSlack = Math.min(minSlack, slack);
    });

    return minSlack > 0 ? Math.round(minSlack / (60 * 1000)) : 0; // Convert to minutes
  }

  // Find successor tasks
  function findTaskSuccessors(task, allTasks) {
    const successors = [];
    const dependencies = calculateTaskDependencies(allTasks);

    dependencies.forEach(dep => {
      if (dep.from === task.id) {
        const succTask = allTasks.find(t => t.id === dep.to);
        if (succTask) {
          successors.push(succTask);
        }
      }
    });

    return successors;
  }

  // Show float indicator for task
  function showFloatIndicator(task, floatMinutes) {
    const taskEl = document.querySelector(`[data-task-id="${task.id}"]`);
    if (!taskEl) return;

    // Remove existing indicator
    const existing = taskEl.querySelector('.gantt-float-indicator');
    if (existing) existing.remove();

    const indicator = document.createElement('div');
    indicator.className = 'gantt-float-indicator';

    if (floatMinutes > 60) {
      indicator.classList.add('positive');
      indicator.textContent = `+${Math.round(floatMinutes / 60)}h`;
    } else if (floatMinutes > 0) {
      indicator.classList.add('positive');
      indicator.textContent = `+${floatMinutes}m`;
    } else if (floatMinutes === 0) {
      indicator.classList.add('zero');
      indicator.textContent = '0';
    } else {
      indicator.classList.add('negative');
      indicator.textContent = `${floatMinutes}m`;
    }

    taskEl.appendChild(indicator);
  }

  // Clear critical path visualization
  function clearCriticalPath() {
    // Remove critical path highlighting
    document.querySelectorAll('.gantt-task.critical-path').forEach(el => {
      el.classList.remove('critical-path');
    });

    // Remove float indicators
    document.querySelectorAll('.gantt-float-indicator').forEach(el => {
      el.remove();
    });
  }

  // Make advanced Gantt functions globally available
  window.toggleDependencies = toggleDependencies;
  window.toggleCriticalPath = toggleCriticalPath;
  window.renderDependencies = renderDependencies;
  window.calculateAndShowCriticalPath = calculateAndShowCriticalPath;
  window.deleteManualDependency = deleteManualDependency;

  // Add scroll listener to update dependencies when gantt is scrolled
  function initGanttScrollListener() {
    const ganttBody = qs('#gantt-body');
    if (ganttBody) {
      ganttBody.addEventListener('scroll', () => {
        if (window.ganttShowDependencies) {
          // Debounce the rendering to avoid too many updates
          if (window.ganttScrollTimeout) {
            clearTimeout(window.ganttScrollTimeout);
          }
          window.ganttScrollTimeout = setTimeout(() => {
            renderDependencies();
          }, 100);
        }
      });
    }
  }

  // Initialize scroll listener when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initGanttScrollListener);
  } else {
    initGanttScrollListener();
  }

  // Simple modal dialog function
  function showModal(title, content, buttons = []) {

    // Ensure we never stack duplicate modal elements
    document.querySelectorAll('#custom-modal').forEach(existing => existing.remove());

    // Create modal elements
    const modal = document.createElement('div');
    modal.id = 'custom-modal';
    modal.style.cssText = `
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.5); z-index: 10000; display: flex;
      align-items: center; justify-content: center;
    `;

    const modalContent = document.createElement('div');
    modalContent.style.cssText = `
      background: var(--panel); border-radius: 8px; padding: 20px;
      max-width: 800px; max-height: 85vh; overflow-y: auto;
      box-shadow: 0 10px 25px rgba(0,0,0,0.3);
      cursor: default !important;
    `;
    
    // Wymuszenie domyślnego kursora dla wszystkich elementów w modalu
    modalContent.addEventListener('DOMNodeInserted', () => {
      const allElements = modalContent.querySelectorAll('*');
      allElements.forEach(el => {
        if (!el.style.cursor || el.style.cursor === 'not-allowed') {
          el.style.cursor = 'default';
        }
      });
    });

    const titleEl = document.createElement('h3');
    titleEl.textContent = title;
    titleEl.style.marginTop = '0';

    const contentEl = document.createElement('div');
    contentEl.innerHTML = content;

    const buttonsEl = document.createElement('div');
    buttonsEl.style.cssText = 'display: flex; gap: 8px; justify-content: flex-end; margin-top: 20px;';

    buttons.forEach(btn => {
      const buttonEl = document.createElement('button');
      buttonEl.className = 'btn';
      buttonEl.textContent = btn.text;
      buttonEl.addEventListener('click', async () => {
        let shouldClose = true;
        try {
          if (btn.action) {
            const result = btn.action();
            if (result instanceof Promise) {
              const awaited = await result;
              if (awaited === false) {
                shouldClose = false;
              }
            } else if (result === false) {
              shouldClose = false;
            }
          }
        } catch (error) {
          console.error('[modal] action error', error);
        } finally {
          if (shouldClose) {
            modal.remove();
          }
        }
      });
      buttonsEl.appendChild(buttonEl);
    });

    modalContent.appendChild(titleEl);
    modalContent.appendChild(contentEl);
    modalContent.appendChild(buttonsEl);
    modal.appendChild(modalContent);

    // Close on background click
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        modal.remove();
      }
    });

    document.body.appendChild(modal);
  }

  // Enable/disable browser spellcheck and set language (pl) for user-editable fields
  (function(){
  try{
    const queryFields = () => Array.from(document.querySelectorAll('input:not([type="hidden"]), textarea, [contenteditable]'));

    const enableSpellAndLang = () => {
      queryFields().forEach(el=>{
        try{ el.setAttribute('spellcheck','true'); }catch(_){/* ignore */}
        try{ el.setAttribute('lang','pl'); }catch(_){/* ignore */}
      });
    };

    const disableSpellAndLang = () => {
      Array.from(document.querySelectorAll('input, textarea, [contenteditable]')).forEach(el=>{
        try{ el.removeAttribute('spellcheck'); }catch(_){/* ignore */}
        try{ if(el.getAttribute('lang') === 'pl') el.removeAttribute('lang'); }catch(_){/* ignore */}
      });
    };

    const obsCb = (mutationsList) => {
      try{
        if(!!state.storage.spellcheckEnforce) enableSpellAndLang(); else disableSpellAndLang();
      }catch(_){/* ignore */}
    };

    const obs = new MutationObserver(obsCb);
    obs.observe(document.body, { childList:true, subtree:true });

    if(!!state.storage.spellcheckEnforce) enableSpellAndLang(); else disableSpellAndLang();
  }catch(e){console.warn('spellcheck/lang init error', e);} 
})();

// Kod magazynu przywrócony jako adapter do nowych funkcji

function ensureWarehouseArrays() {
  if (!Array.isArray(window.warehouseItems)) {
    window.warehouseItems = [];
  }
  if (!Array.isArray(window.warehouseTransactions)) {
    window.warehouseTransactions = [];
  }
  if (!Array.isArray(window.warehouseReservations)) {
    window.warehouseReservations = [];
  }
  if (!Array.isArray(window.materialTemplates)) {
    window.materialTemplates = [];
  }
}

function findWarehouseItemIndexById(itemId) {
  ensureWarehouseArrays();
  return window.warehouseItems.findIndex(item => item && item.id === itemId);
}

function findWarehouseItemById(itemId) {
  const index = findWarehouseItemIndexById(itemId);
  return index >= 0 ? { index, item: window.warehouseItems[index] } : { index: -1, item: null };
}

if (!window.simpleWarehouse) {
  window.simpleWarehouse = {
    render() {
      try {
        renderWarehouse();
      } catch (error) {
        console.warn('[warehouse] render fallback error', error);
      }
    },
    showAddItemModal() {
      try {
        showAddWarehouseModal();
      } catch (error) {
        console.warn('[warehouse] add item modal error', error);
      }
    },
    exportData() {
      try {
        exportWarehouseToCSV();
      } catch (error) {
        console.warn('[warehouse] export fallback error', error);
      }
    },
    editItem(itemId) {
      const { index } = findWarehouseItemById(itemId);
      if (index === -1) {
        alert('Nie znaleziono pozycji magazynowej do edycji.');
        return;
      }
      try {
        showEditWarehouseModal(index);
      } catch (error) {
        console.error('[warehouse] edit fallback error', error);
      }
    },
    adjustQuantity(itemId) {
      const { index, item } = findWarehouseItemById(itemId);
      if (index === -1 || !item) {
        alert('Nie znaleziono pozycji magazynowej do korekty.');
        return;
      }
      try {
        showAdjustQuantityModal(index);
      } catch (error) {
        console.error('[warehouse] adjust quantity error', error);
      }
    },
    deleteItem(itemId) {
      const { index } = findWarehouseItemById(itemId);
      if (index === -1) {
        alert('Nie znaleziono pozycji magazynowej do usunięcia.');
        return;
      }
      try {
        deleteWarehouseItem(index);
      } catch (error) {
        console.error('[warehouse] delete fallback error', error);
      }
    }
  };
}

function setupWarehouseButtons() {
  console.log('[warehouse] setupWarehouseButtons invoked');

  ensureWarehouseArrays();

  const addBtn = document.getElementById('wh-add');
  if (addBtn) {
    addBtn.onclick = null;
    addBtn.addEventListener('click', (event) => {
      if (window.disableGlobalClickDelegation) {
        event.preventDefault();
        event.stopPropagation();
      }
      addWarehouseItem();
    });
  } else {
    console.warn('[warehouse] add button not found');
  }

  const searchInput = document.getElementById('wh-search');
  if (searchInput && !searchInput.dataset.whBound) {
    searchInput.dataset.whBound = 'true';
    searchInput.addEventListener('input', () => {
      renderWarehouse();
    });
  }

  updateShoppingListBadge();
}

// Automatyczne renderowanie magazynu
setTimeout(() => {
  if (window.simpleWarehouse) {
    console.log('Magazyn: Automatyczne renderowanie listy pozycji');
    window.simpleWarehouse.render();
  }
}, 1500);

// Jednorazowa inicjalizacja przy wejściu na zakładkę magazynu
let __warehouseInitialized = false;
function initWarehouse(){
  if(__warehouseInitialized){
    // Przywracamy normalną delegację kliknięć przy powrocie
    window.restoreNormalClickDelegation();
    // odśwież widok przy powrocie
    if(window.simpleWarehouse){
      try { window.simpleWarehouse.render(); } catch(e){ console.warn('[warehouse] re-render error', e); }
    }
    return;
  }
  console.log('[warehouse] initializing...');
  // Przywracamy normalną delegację kliknięć przy pierwszej inicjalizacji
  window.restoreNormalClickDelegation();
  
  // Upewnij się, że dane magazynu są załadowane
  if (!window.warehouseItems) {
    loadWarehouseFromStorage();
  }
  
  // Synchronizuj zadania magazynowe ze zleceniami
  if (typeof window.syncWarehouseTasks === 'function') {
    window.syncWarehouseTasks();
  }
  
  // Aktualizuj badge zadań
  if (typeof window.updateTasksBadge === 'function') {
    window.updateTasksBadge();
  }
  
  // upewnij się że sekcja jest widoczna (usuwamy ewentualnie hidden dopiero po listenerach)
  const section = document.getElementById('p-wh');
  if(section) section.classList.remove('hidden');
  // konfiguracja przycisków
  try { setupWarehouseButtons(); } catch(e){ console.warn('[warehouse] setup buttons error', e); }
  // pierwsze renderowanie
  if(window.simpleWarehouse){
    try { window.simpleWarehouse.render(); } catch(e){ console.warn('[warehouse] first render error', e); }
  } else {
    console.warn('[warehouse] simpleWarehouse not yet ready, retry in 500ms');
    setTimeout(()=>{
      if(window.simpleWarehouse){
        try { window.simpleWarehouse.render(); } catch(e){ console.warn('[warehouse] delayed render error', e); }
      }
    },500);
  }
  __warehouseInitialized = true;
  console.log('[warehouse] initialized');
}

// Globalne funkcje pomocnicze dla przycisków
function showAddItemModal() {
  showAddWarehouseModal();
}

function exportWarehouseData() {
  exportWarehouseToCSV();
}

// Kod DOMContentLoaded dla magazynu usunięty

function saveWarehouseToStorage() {
  localStorage.setItem('warehouseItems', JSON.stringify(window.warehouseItems));
  localStorage.setItem('warehouseTransactions', JSON.stringify(window.warehouseTransactions || []));
  localStorage.setItem('warehouseReservations', JSON.stringify(window.warehouseReservations || []));
  localStorage.setItem('materialTemplates', JSON.stringify(window.materialTemplates || []));
}

function loadWarehouseFromStorage() {
  const stored = localStorage.getItem('warehouseItems');
  if (stored) {
    window.warehouseItems = JSON.parse(stored);
  } else {
    window.warehouseItems = [];
  }
  
  // Historia transakcji (PZ/WZ)
  const transactions = localStorage.getItem('warehouseTransactions');
  if (transactions) {
    window.warehouseTransactions = JSON.parse(transactions);
  } else {
    window.warehouseTransactions = [];
  }
  
  // Rezerwacje pod zlecenia
  const reservations = localStorage.getItem('warehouseReservations');
  if (reservations) {
    window.warehouseReservations = JSON.parse(reservations);
  } else {
    window.warehouseReservations = [];
  }
  
  // Szablony materiałowe
  const templates = localStorage.getItem('materialTemplates');
  if (templates) {
    window.materialTemplates = JSON.parse(templates);
  } else {
    window.materialTemplates = [];
  }
  
  // Lista zakupów
  const shoppingList = localStorage.getItem('shoppingList');
  if (shoppingList) {
    window.shoppingList = JSON.parse(shoppingList);
  } else {
    window.shoppingList = [];
  }
  
  // Zaktualizuj badge listy zakupów
  updateShoppingListBadge();
}

// Napraw checklisty w zleceniach - znajdź itemId po nazwie materiału
window.fixChecklistItemIds = function() {
  const state = window.STATE || JSON.parse(localStorage.getItem('production_planner_state') || '{}');
  const orders = state.orders || [];
  
  // Wczytaj magazyn
  const warehouseItems = JSON.parse(localStorage.getItem('warehouseItems') || '[]');
  
  let fixedCount = 0;
  let totalChecked = 0;
  
  orders.forEach(order => {
    if (!order.materialChecklist) return;
    
    order.materialChecklist.forEach(item => {
      totalChecked++;
      
      // Jeśli itemId już istnieje, pomiń
      if (item.itemId) return;
      
      // Znajdź w magazynie po nazwie
      const warehouseItem = warehouseItems.find(w => 
        w.name.toLowerCase().trim() === item.itemName.toLowerCase().trim()
      );
      
      if (warehouseItem) {
        item.itemId = warehouseItem.id;
        fixedCount++;
        console.log(`✅ Naprawiono: ${item.itemName} → ${warehouseItem.id}`);
      } else {
        console.warn(`⚠️ Nie znaleziono w magazynie: ${item.itemName}`);
      }
    });
  });
  
  // Zapisz stan
  if (fixedCount > 0) {
    state.orders = orders;
    window.STATE = state;
    localStorage.setItem('production_planner_state', JSON.stringify(state));
  }
  
  console.log(`🔧 Sprawdzono ${totalChecked} pozycji w checklistach, naprawiono ${fixedCount}`);
  alert(`Naprawiono ${fixedCount} pozycji w checklistach zleceń.\n\nTeraz uruchom window.cleanupShoppingList() żeby usunąć stare pozycje z listy zakupów.`);
};

// Uruchom wszystkie naprawy ID w systemie
window.fixAllItemIds = function() {
  console.log('🚀 Rozpoczynam kompleksową naprawę systemu ID...');
  
  try {
    // 1. Napraw istniejące pozycje w magazynie
    console.log('\n📦 Krok 1: Naprawa ID w magazynie...');
    window.fixWarehouseIds();
    
    // 2. Napraw szablony materiałowe
    console.log('\n📋 Krok 2: Naprawa szablonów materiałowych...');
    window.fixTemplateItemIds();
    
    // 3. Napraw checklisty w zleceniach
    console.log('\n✅ Krok 3: Naprawa checklist w zleceniach...');
    window.fixChecklistItemIds();
    
    // 4. Wyczyść nieprawidłowe pozycje z listy zakupów
    console.log('\n🧹 Krok 4: Czyszczenie listy zakupów...');
    window.cleanupShoppingList();
    
    // 5. Sprawdź diagnozę
    console.log('\n🔍 Krok 5: Końcowa diagnoza systemu...');
    setTimeout(() => {
      window.diagnoseItemIdProblem();
      console.log('\n🎉 Wszystkie naprawy zostały zakończone!');
      alert('🎉 Wszystkie naprawy systemu ID zostały zakończone!\n\nOdśwież stronę (F5) aby zobaczyć efekty.');
    }, 1000);
    
  } catch (error) {
    console.error('❌ Błąd podczas napraw:', error);
    alert('❌ Wystąpił błąd podczas napraw: ' + error.message);
  }
};

// Diagnostyka problemu z itemId
window.diagnoseItemIdProblem = function() {
  console.log('🔍 DIAGNOZA PROBLEMU Z ITEMID');
  console.log('=====================================');
  
  // 1. Sprawdź szablony materiałowe
  const templates = window.materialTemplates || [];
  console.log(`📋 SZABLONY (${templates.length}):`);
  templates.forEach((tmpl, idx) => {
    console.log(`  ${idx + 1}. "${tmpl.name}" (${tmpl.materials?.length || 0} materiałów):`);
    (tmpl.materials || []).forEach((mat, matIdx) => {
      const status = mat.itemId ? '✅' : '❌';
      console.log(`    ${matIdx + 1}. ${status} ${mat.itemName}: itemId=${mat.itemId}`);
    });
  });
  
  // 2. Sprawdź checklisty w zleceniach
  const state = window.STATE || JSON.parse(localStorage.getItem('production_planner_state') || '{}');
  const orders = state.orders || [];
  console.log(`\n📝 CHECKLISTY W ZLECENIACH (${orders.filter(o => o.materialChecklist).length}):`);
  orders.forEach(order => {
    if (!order.materialChecklist) return;
    console.log(`  Zlecenie "${order.name}" (${order.materialChecklist.length} pozycji):`);
    order.materialChecklist.forEach((item, idx) => {
      const status = item.itemId ? '✅' : '❌';
      console.log(`    ${idx + 1}. ${status} ${item.itemName}: itemId=${item.itemId}`);
    });
  });
  
  // 3. Sprawdź listę zakupów
  const shoppingList = window.shoppingList || [];
  const pending = shoppingList.filter(item => item.status === 'pending');
  console.log(`\n🛒 LISTA ZAKUPÓW (${shoppingList.length} łącznie, ${pending.length} oczekujących):`);
  pending.forEach((item, idx) => {
    const status = item.itemId ? '✅' : '❌';
    console.log(`    ${idx + 1}. ${status} ${item.itemName}: itemId=${item.itemId}, order=${item.orderName}`);
  });
  
  // 4. Sprawdź magazyn
  const warehouseItems = window.warehouseItems || [];
  console.log(`\n📦 MAGAZYN (${warehouseItems.length} pozycji):`);
  warehouseItems.forEach((item, idx) => {
    console.log(`    ${idx + 1}. ${item.name}: id=${item.id}`);
  });
  
  console.log('\n=====================================');
  console.log('🔍 KONIEC DIAGNOZY');
};

// Napraw istniejące pozycje w magazynie - dodaj brakujące ID
window.fixWarehouseIds = function() {
  const warehouseItems = window.warehouseItems || [];
  let fixedCount = 0;
  
  warehouseItems.forEach(item => {
    if (!item.id) {
      item.id = generateId();
      fixedCount++;
      console.log(`✅ Dodano ID dla: ${item.name} → ${item.id}`);
    }
  });
  
  if (fixedCount > 0) {
    localStorage.setItem('warehouseItems', JSON.stringify(window.warehouseItems));
    console.log(`🔧 Naprawiono ${fixedCount} pozycji w magazynie`);
  } else {
    console.log(`✅ Wszystkie pozycje w magazynie mają ID`);
  }
  
  alert(`Naprawiono ${fixedCount} pozycji w magazynie.\n\nTeraz uruchom window.fixTemplateItemIds() żeby naprawić szablony.`);
};

// Napraw szablony materiałowe - znajdź itemId po nazwie materiału
window.fixTemplateItemIds = function() {
  const templates = window.materialTemplates || [];
  const warehouseItems = window.warehouseItems || [];
  
  let fixedCount = 0;
  let totalChecked = 0;
  
  templates.forEach(template => {
    if (!template.materials) return;
    
    template.materials.forEach(material => {
      totalChecked++;
      
      // Jeśli itemId już istnieje i jest prawidłowy, pomiń
      if (material.itemId && warehouseItems.find(w => w.id === material.itemId)) return;
      
      // Znajdź w magazynie po nazwie
      const warehouseItem = warehouseItems.find(w => 
        w.name.toLowerCase().trim() === material.itemName.toLowerCase().trim()
      );
      
      if (warehouseItem) {
        material.itemId = warehouseItem.id;
        fixedCount++;
        console.log(`✅ Naprawiono szablon "${template.name}": ${material.itemName} → ${warehouseItem.id}`);
      } else {
        console.warn(`⚠️ Nie znaleziono w magazynie dla szablonu "${template.name}": ${material.itemName}`);
      }
    });
  });
  
  // Zapisz szablony
  if (fixedCount > 0) {
    localStorage.setItem('materialTemplates', JSON.stringify(window.materialTemplates));
  }
  
  console.log(`🔧 Sprawdzono ${totalChecked} materiałów w szablonach, naprawiono ${fixedCount}`);
  alert(`Naprawiono ${fixedCount} materiałów w szablonach.\n\nTeraz uruchom window.fixChecklistItemIds() żeby naprawić checklisty w zleceniach.`);
};

// Wyczyść nieprawidłowe pozycje z listy zakupów (bez itemId)
window.cleanupShoppingList = function() {
  if (!window.shoppingList) return;
  
  const before = window.shoppingList.length;
  window.shoppingList = window.shoppingList.filter(item => item.itemId);
  const after = window.shoppingList.length;
  
  localStorage.setItem('shoppingList', JSON.stringify(window.shoppingList));
  updateShoppingListBadge();
  
  console.log(`🧹 Wyczyszczono listę zakupów: ${before - after} pozycji bez itemId usuniętych`);
  alert(`Wyczyszczono ${before - after} nieprawidłowych pozycji z listy zakupów.\n\nOdśwież stronę (F5) aby zobaczyć zmiany.`);
};

// Aktualizuj badge listy zakupów
function updateShoppingListBadge() {
  const badge = document.getElementById('shopping-badge');
  if (!badge) return;
  
  if (!window.shoppingList) {
    window.shoppingList = [];
  }
  
  // Zlicz unikalne materiały (itemId) z statusem pending
  const pending = window.shoppingList.filter(item => item.status === 'pending');
  const uniqueItems = new Set(pending.map(item => item.itemId));
  const pendingCount = uniqueItems.size;
  
  console.log('🔢 Badge update:', { 
    totalPending: pending.length, 
    uniqueMaterials: pendingCount,
    itemIds: Array.from(uniqueItems)
  });
  
  if (pendingCount > 0) {
    badge.textContent = pendingCount;
    badge.style.display = 'block';
  } else {
    badge.style.display = 'none';
  }
}

// Przełączanie zakładek magazynu
function switchWarehouseTab(tab) {
  // Ukryj wszystkie widoki
  const views = ['items', 'transactions', 'reservations', 'tasks', 'templates'];
  views.forEach(v => {
    const viewEl = document.getElementById(`wh-view-${v}`);
    const tabBtn = document.getElementById(`wh-tab-${v}`);
    if (viewEl) viewEl.classList.add('hidden');
    if (tabBtn) tabBtn.classList.remove('amber');
  });
  
  // Pokaż wybrany widok
  const activeView = document.getElementById(`wh-view-${tab}`);
  const activeBtn = document.getElementById(`wh-tab-${tab}`);
  if (activeView) activeView.classList.remove('hidden');
  if (activeBtn) activeBtn.classList.add('amber');
  
  // Renderuj odpowiednią zawartość
  if (tab === 'items') {
    renderWarehouse();
  } else if (tab === 'transactions') {
    renderTransactions();
  } else if (tab === 'reservations') {
    renderReservations();
  } else if (tab === 'tasks') {
    renderWarehouseTasks();
  } else if (tab === 'templates') {
    renderTemplates();
  }
}

// Udostępnij globalnie
window.switchWarehouseTab = switchWarehouseTab;

// Generowanie unikalnego ID
function generateId() {
  return 'wh_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
}

function showEditWarehouseModal(index) {
  const item = window.warehouseItems[index];
  if (!item) return;

  const content = `
    <div style="display: flex; flex-direction: column; gap: 16px;">
      <div>
        <label style="display: block; margin-bottom: 4px; font-weight: bold;">Nazwa pozycji:</label>
        <input type="text" id="wh-edit-modal-name" value="${item.name}" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
      </div>
      <div style="display: flex; gap: 16px;">
        <div style="flex: 1;">
          <label style="display: block; margin-bottom: 4px; font-weight: bold;">Ilość:</label>
          <input type="number" id="wh-edit-modal-quantity" value="${item.quantity}" min="0" step="0.01" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
        </div>
        <div style="flex: 1;">
          <label style="display: block; margin-bottom: 4px; font-weight: bold;">Jednostka:</label>
          <select id="wh-edit-modal-unit" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
            <option value="szt" ${item.unit === 'szt' ? 'selected' : ''}>szt</option>
            <option value="kg" ${item.unit === 'kg' ? 'selected' : ''}>kg</option>
            <option value="m" ${item.unit === 'm' ? 'selected' : ''}>m</option>
            <option value="m²" ${item.unit === 'm²' ? 'selected' : ''}>m²</option>
            <option value="m³" ${item.unit === 'm³' ? 'selected' : ''}>m³</option>
            <option value="l" ${item.unit === 'l' ? 'selected' : ''}>l</option>
            <option value="opak" ${item.unit === 'opak' ? 'selected' : ''}>opak</option>
          </select>
        </div>
      </div>
      <div>
        <label style="display: block; margin-bottom: 4px; font-weight: bold;">Cena (PLN):</label>
        <input type="number" id="wh-edit-modal-price" value="${item.price}" min="0" step="0.01" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
      </div>
      <div>
        <label style="display: block; margin-bottom: 4px; font-weight: bold;">Stan minimalny:</label>
        <input type="number" id="wh-edit-modal-min-stock" value="${item.minStock || 0}" min="0" step="0.01" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
        <small style="color: #666; font-size: 12px;">Poniżej tego poziomu pozycja będzie oznaczona do zamówienia</small>
      </div>
      <hr style="border:none;border-top:1px solid #e2e8f0;margin:8px 0">
      <div style="display:flex;gap:16px;">
        <div style="flex:1">
          <label style="display: block; margin-bottom: 4px; font-weight: bold;">📍 Regał:</label>
          <input type="text" id="wh-edit-modal-shelf" value="${item.location?.shelf || ''}" placeholder="np. R1" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
        </div>
        <div style="flex:1">
          <label style="display: block; margin-bottom: 4px; font-weight: bold;">Półka:</label>
          <input type="text" id="wh-edit-modal-rack" value="${item.location?.rack || ''}" placeholder="np. P3" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
        </div>
        <div style="flex:1">
          <label style="display: block; margin-bottom: 4px; font-weight: bold;">Sektor:</label>
          <input type="text" id="wh-edit-modal-sector" value="${item.location?.sector || ''}" placeholder="np. A" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
        </div>
      </div>
    </div>
  `;

  showModal('✏️ Edytuj pozycję', content, [
    {
      text: 'Anuluj',
      action: () => {}
    },
    {
      text: 'Zapisz',
      action: () => {
        const name = document.getElementById('wh-edit-modal-name').value.trim();
        const quantity = parseFloat(document.getElementById('wh-edit-modal-quantity').value);
        const unit = document.getElementById('wh-edit-modal-unit').value;
        const price = parseFloat(document.getElementById('wh-edit-modal-price').value);
        const minStock = parseFloat(document.getElementById('wh-edit-modal-min-stock').value) || 0;

        if (!name) {
          alert('Nazwa pozycji jest wymagana!');
          return;
        }

        if (isNaN(quantity) || quantity < 0) {
          alert('Podaj prawidłową ilość!');
          return;
        }

        if (isNaN(price) || price < 0) {
          alert('Podaj prawidłową cenę!');
          return;
        }

        if (isNaN(minStock) || minStock < 0) {
          alert('Podaj prawidłowy stan minimalny!');
          return;
        }

        const shelf = document.getElementById('wh-edit-modal-shelf').value.trim();
        const rack = document.getElementById('wh-edit-modal-rack').value.trim();
        const sector = document.getElementById('wh-edit-modal-sector').value.trim();

        window.warehouseItems[index] = { 
          name, 
          quantity, 
          unit, 
          price, 
          minStock,
          location: { shelf, rack, sector }
        };
        saveWarehouseToStorage();
        renderWarehouse();
      }
    }
  ]);
}

// Rozszerzony magazyn z edycją
function editWarehouseItem(index) {
  showEditWarehouseModal(index);
}

function deleteWarehouseItem(index) {
  if (confirm('Usunąć pozycję?')) {
    window.warehouseItems.splice(index, 1);
    saveWarehouseToStorage();
    renderWarehouse();
  }
}

function showAdjustQuantityModal(index) {
  ensureWarehouseArrays();

  const item = window.warehouseItems[index];
  if (!item) {
    alert('Nie znaleziono pozycji magazynowej do korekty.');
    return;
  }

  const modalIds = {
    quantity: `wh-adjust-quantity-${index}`,
    note: `wh-adjust-note-${index}`
  };

  const content = `
    <div style="display:flex;flex-direction:column;gap:16px;">
      <div style="background:#0f172a0d;padding:12px;border-radius:8px;line-height:1.6">
        <div style="font-weight:600;font-size:16px;">${item.name}</div>
        <div style="color:#64748b;font-size:14px;">Aktualny stan: <strong>${item.quantity} ${item.unit}</strong></div>
        <div style="color:#64748b;font-size:14px;">Stan minimalny: ${item.minStock || 0} ${item.unit}</div>
      </div>
      <div>
        <label style="display:block;margin-bottom:4px;font-weight:bold;">Nowy stan magazynowy:</label>
        <input type="number" id="${modalIds.quantity}" value="${item.quantity}" min="0" step="0.01" style="width:100%;padding:8px;border:1px solid #cbd5f5;border-radius:6px;">
        <small style="color:#64748b;font-size:12px;display:block;margin-top:4px;">Podaj stan docelowy po korekcie.</small>
      </div>
      <div>
        <label style="display:block;margin-bottom:4px;font-weight:bold;">Uwagi (opcjonalnie):</label>
        <textarea id="${modalIds.note}" rows="2" placeholder="np. Inwentaryzacja, korekta ręczna" style="width:100%;padding:8px;border:1px solid #cbd5f5;border-radius:6px;"></textarea>
      </div>
    </div>
  `;

  showModal('📊 Korekta stanu magazynowego', content, [
    { text: 'Anuluj', action: () => {} },
    {
      text: 'Zapisz korektę',
      action: () => {
        const targetValue = parseFloat(document.getElementById(modalIds.quantity).value);
        const note = document.getElementById(modalIds.note).value.trim();

        if (Number.isNaN(targetValue) || targetValue < 0) {
          alert('Podaj poprawny docelowy stan magazynowy (≥ 0).');
          return;
        }

        const delta = parseFloat((targetValue - item.quantity).toFixed(2));
        if (Math.abs(delta) < 0.0001) {
          alert('Brak zmian — stan magazynowy pozostaje bez aktualizacji.');
          return;
        }

        const type = delta > 0 ? 'in' : 'out';
        const quantity = Math.abs(delta);

        item.quantity = targetValue;

        const transaction = {
          id: generateId(),
          type,
          itemId: index,
          itemName: item.name,
          quantity,
          unit: item.unit,
          person: 'System',
          notes: note ? `Korekta: ${note}` : 'Korekta stanu magazynowego',
          date: new Date().toISOString(),
          timestamp: Date.now(),
          correction: true,
          previousQuantity: parseFloat((targetValue - delta).toFixed(2)),
          newQuantity: targetValue
        };

        window.warehouseTransactions.push(transaction);
        saveWarehouseToStorage();
        renderWarehouse();
        renderTransactions();

        alert(`✅ Korekta zapisana. Zmiana: ${delta > 0 ? '+' : '-'}${quantity} ${item.unit}.`);
      }
    }
  ]);
}

function showAddWarehouseModal() {
  const content = `
    <div style="display: flex; flex-direction: column; gap: 16px;">
      <div>
        <label style="display: block; margin-bottom: 4px; font-weight: bold;">Nazwa pozycji:</label>
        <input type="text" id="wh-modal-name" placeholder="np. Deska sosnowa 2x4" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
      </div>
      <div style="display: flex; gap: 16px;">
        <div style="flex: 1;">
          <label style="display: block; margin-bottom: 4px; font-weight: bold;">Ilość:</label>
          <input type="number" id="wh-modal-quantity" placeholder="0" min="0" step="0.01" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
        </div>
        <div style="flex: 1;">
          <label style="display: block; margin-bottom: 4px; font-weight: bold;">Jednostka:</label>
          <select id="wh-modal-unit" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
            <option value="szt">szt</option>
            <option value="kg">kg</option>
            <option value="m">m</option>
            <option value="m²">m²</option>
            <option value="m³">m³</option>
            <option value="l">l</option>
            <option value="opak">opak</option>
          </select>
        </div>
      </div>
      <div>
        <label style="display: block; margin-bottom: 4px; font-weight: bold;">Cena (PLN):</label>
        <input type="number" id="wh-modal-price" placeholder="0.00" min="0" step="0.01" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
      </div>
      <div>
        <label style="display: block; margin-bottom: 4px; font-weight: bold;">Stan minimalny:</label>
        <input type="number" id="wh-modal-min-stock" placeholder="0" min="0" step="0.01" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
        <small style="color: #666; font-size: 12px;">Poniżej tego poziomu pozycja będzie oznaczona do zamówienia</small>
      </div>
      <hr style="border:none;border-top:1px solid #e2e8f0;margin:8px 0">
      <div style="display:flex;gap:16px;">
        <div style="flex:1">
          <label style="display: block; margin-bottom: 4px; font-weight: bold;">📍 Regał:</label>
          <input type="text" id="wh-modal-shelf" placeholder="np. R1" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
        </div>
        <div style="flex:1">
          <label style="display: block; margin-bottom: 4px; font-weight: bold;">Półka:</label>
          <input type="text" id="wh-modal-rack" placeholder="np. P3" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
        </div>
        <div style="flex:1">
          <label style="display: block; margin-bottom: 4px; font-weight: bold;">Sektor:</label>
          <input type="text" id="wh-modal-sector" placeholder="np. A" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
        </div>
      </div>
    </div>
  `;

  showModal('➕ Dodaj pozycję do magazynu', content, [
    {
      text: 'Anuluj',
      action: () => {}
    },
    {
      text: 'Dodaj',
      action: () => {
        const name = document.getElementById('wh-modal-name').value.trim();
        const quantity = parseFloat(document.getElementById('wh-modal-quantity').value);
        const unit = document.getElementById('wh-modal-unit').value;
        const price = parseFloat(document.getElementById('wh-modal-price').value);
        const minStock = parseFloat(document.getElementById('wh-modal-min-stock').value) || 0;

        if (!name) {
          alert('Nazwa pozycji jest wymagana!');
          return;
        }

        if (isNaN(quantity) || quantity < 0) {
          alert('Podaj prawidłową ilość!');
          return;
        }

        if (isNaN(price) || price < 0) {
          alert('Podaj prawidłową cenę!');
          return;
        }

        if (isNaN(minStock) || minStock < 0) {
          alert('Podaj prawidłowy stan minimalny!');
          return;
        }

        const shelf = document.getElementById('wh-modal-shelf').value.trim();
        const rack = document.getElementById('wh-modal-rack').value.trim();
        const sector = document.getElementById('wh-modal-sector').value.trim();

        window.warehouseItems.push({ 
          id: generateId(),
          name, 
          quantity, 
          unit, 
          price, 
          minStock,
          location: { shelf, rack, sector }
        });
        saveWarehouseToStorage();
        renderWarehouse();
      }
    }
  ]);
}

function addWarehouseItem() {
  showAddWarehouseModal();
}

// ===== TRANSAKCJE MAGAZYNOWE (PZ/WZ) =====

function showTransactionModal(type) {
  const title = type === 'in' ? '📥 Przyjęcie towaru (PZ)' : '📤 Wydanie towaru (WZ)';
  const action = type === 'in' ? 'Przyjmij' : 'Wydaj';
  
  // Lista pozycji do wyboru
  const itemsOptions = window.warehouseItems.map((item, idx) => 
    `<option value="${idx}">${item.name} (stan: ${item.quantity} ${item.unit})</option>`
  ).join('');
  
  const content = `
    <div style="display: flex; flex-direction: column; gap: 16px;">
      <div>
        <label style="display: block; margin-bottom: 4px; font-weight: bold;">Pozycja:</label>
        <select id="wh-trans-item" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
          ${itemsOptions}
        </select>
      </div>
      <div>
        <label style="display: block; margin-bottom: 4px; font-weight: bold;">Ilość:</label>
        <input type="number" id="wh-trans-quantity" min="0.01" step="0.01" placeholder="np. 10" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
      </div>
      <div>
        <label style="display: block; margin-bottom: 4px; font-weight: bold;">Osoba odpowiedzialna:</label>
        <input type="text" id="wh-trans-person" placeholder="np. Jan Kowalski" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
      </div>
      <div>
        <label style="display: block; margin-bottom: 4px; font-weight: bold;">Uwagi:</label>
        <textarea id="wh-trans-notes" placeholder="Opcjonalne uwagi..." rows="3" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;"></textarea>
      </div>
    </div>
  `;

  showModal(title, content, [
    { text: 'Anuluj', action: () => {} },
    {
      text: action,
      action: () => {
        const itemIdx = parseInt(document.getElementById('wh-trans-item').value);
        const quantity = parseFloat(document.getElementById('wh-trans-quantity').value);
        const person = document.getElementById('wh-trans-person').value.trim();
        const notes = document.getElementById('wh-trans-notes').value.trim();

        if (isNaN(itemIdx) || isNaN(quantity) || quantity <= 0) {
          alert('Podaj poprawną ilość');
          return;
        }

        const item = window.warehouseItems[itemIdx];
        if (!item) {
          alert('Nie znaleziono pozycji');
          return;
        }

        // Dla wydania - sprawdź czy jest wystarczająca ilość
        if (type === 'out' && item.quantity < quantity) {
          if (!confirm(`Niewystarczający stan! Dostępne: ${item.quantity} ${item.unit}. Kontynuować?`)) {
            return;
          }
        }

        // Utwórz transakcję
        const transaction = {
          id: generateId(),
          type: type, // 'in' lub 'out'
          itemId: itemIdx,
          itemName: item.name,
          quantity: quantity,
          unit: item.unit,
          person: person || '—',
          notes: notes,
          date: new Date().toISOString(),
          timestamp: Date.now()
        };

        // Zaktualizuj stan magazynowy
        if (type === 'in') {
          item.quantity += quantity;
        } else {
          item.quantity -= quantity;
        }

        // Zapisz transakcję
        if (!window.warehouseTransactions) {
          window.warehouseTransactions = [];
        }
        window.warehouseTransactions.push(transaction);

        saveWarehouseToStorage();
        alert(`✅ ${type === 'in' ? 'Przyjęto' : 'Wydano'} ${quantity} ${item.unit} - ${item.name}`);
        renderTransactions();
        renderWarehouse(); // Odśwież też listę pozycji
      }
    }
  ]);
}

function renderTransactions() {
  const list = document.getElementById('wh-transactions-list');
  if (!list) return;

  const filter = document.getElementById('wh-transaction-filter')?.value || '';
  let transactions = (window.warehouseTransactions || []).slice().reverse(); // Najnowsze na górze

  if (filter) {
    transactions = transactions.filter(t => t.type === filter);
  }

  if (transactions.length === 0) {
    list.innerHTML = '<div style="text-align:center;padding:40px;color:#999">Brak transakcji</div>';
    return;
  }

  list.innerHTML = transactions.map(trans => {
    const date = new Date(trans.date);
    const dateStr = date.toLocaleDateString('pl-PL');
    const timeStr = date.toLocaleTimeString('pl-PL', { hour: '2-digit', minute: '2-digit' });
    const typeIcon = trans.type === 'in' ? '📥' : '📤';
    const typeLabel = trans.type === 'in' ? 'Przyjęcie (PZ)' : 'Wydanie (WZ)';
    const typeColor = trans.type === 'in' ? '#10b981' : '#f59e0b';

    return `
      <div class="card" style="margin-bottom:8px;border-left:4px solid ${typeColor}">
        <div class="row" style="justify-content:space-between;align-items:flex-start">
          <div style="flex:1">
            <div style="font-weight:600;margin-bottom:4px">
              ${typeIcon} ${typeLabel}
            </div>
            <div style="font-size:14px;color:#64748b">
              <strong>${trans.itemName}</strong> - ${trans.quantity} ${trans.unit}
            </div>
            <div style="font-size:12px;color:#94a3b8;margin-top:4px">
              ${dateStr} ${timeStr} • Osoba: ${trans.person}
            </div>
            ${trans.notes ? `<div style="font-size:12px;color:#94a3b8;margin-top:4px;font-style:italic">${trans.notes}</div>` : ''}
          </div>
          <button class="btn red small" onclick="deleteTransaction('${trans.id}')">Usuń</button>
        </div>
      </div>
    `;
  }).join('');
}

function deleteTransaction(transId) {
  if (!confirm('Usunąć transakcję? To nie cofnie zmian w stanie magazynowym!')) {
    return;
  }
  window.warehouseTransactions = window.warehouseTransactions.filter(t => t.id !== transId);
  saveWarehouseToStorage();
  renderTransactions();
}

// ===== REZERWACJE POD ZLECENIA =====

// Aktualizacja listy materiałów po wyborze zlecenia
function updateMaterialsForOrder() {
  const orderSelect = document.getElementById('wh-res-order');
  const itemSelect = document.getElementById('wh-res-item');
  const orderId = orderSelect.value;
  
  if (!orderId) {
    itemSelect.innerHTML = '<option value="">— najpierw wybierz zlecenie —</option>';
    return;
  }
  
  const order = (state.orders || []).find(o => o.id === orderId);
  
  if (!order || !order.materialChecklist || order.materialChecklist.length === 0) {
    itemSelect.innerHTML = '<option value="">— to zlecenie nie ma checklisty materiałów —</option>';
    return;
  }
  
  // Pokaż tylko materiały z checklisty zlecenia
  const options = order.materialChecklist.map((item, idx) => {
    const warehouseItem = (window.warehouseItems || []).find(w => w.id === item.itemId);
    const available = warehouseItem ? warehouseItem.quantity : 0;
    const checkMark = item.checked ? '✅ ' : '';
    return `<option value="${item.itemId}">${checkMark}${item.itemName} (dostępne: ${available} ${item.unit})</option>`;
  }).join('');
  
  itemSelect.innerHTML = options;
}

function showReservationModal() {
  const itemsOptions = window.warehouseItems.map((item, idx) => 
    `<option value="${idx}">${item.name} (dostępne: ${item.quantity} ${item.unit})</option>`
  ).join('');

  const ordersOptions = (state.orders || []).map(order =>
    `<option value="${order.id}">${order.name}</option>`
  ).join('');

  const content = `
    <div style="display: flex; flex-direction: column; gap: 16px;">
      <div>
        <label style="display: block; margin-bottom: 4px; font-weight: bold;">Zlecenie:</label>
        <select id="wh-res-order" onchange="updateMaterialsForOrder()" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
          <option value="">— wybierz zlecenie —</option>
          ${ordersOptions}
        </select>
      </div>
      <div>
        <label style="display: block; margin-bottom: 4px; font-weight: bold;">Materiał:</label>
        <select id="wh-res-item" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
          <option value="">— najpierw wybierz zlecenie —</option>
        </select>
      </div>
      <div>
        <label style="display: block; margin-bottom: 4px; font-weight: bold;">Ilość do zarezerwowania:</label>
        <input type="number" id="wh-res-quantity" min="0.01" step="0.01" placeholder="np. 5" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
      </div>
      <div>
        <label style="display: block; margin-bottom: 4px; font-weight: bold;">Uwagi:</label>
        <textarea id="wh-res-notes" placeholder="Opcjonalne uwagi..." rows="2" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;"></textarea>
      </div>
    </div>
  `;

  showModal('🔒 Nowa rezerwacja', content, [
    { text: 'Anuluj', action: () => {} },
    {
      text: 'Zarezerwuj',
      action: () => {
        const orderId = document.getElementById('wh-res-order').value;
        const itemId = document.getElementById('wh-res-item').value;
        const quantity = parseFloat(document.getElementById('wh-res-quantity').value);
        const notes = document.getElementById('wh-res-notes').value.trim();

        if (!orderId) {
          alert('Wybierz zlecenie');
          return;
        }

        if (!itemId || isNaN(quantity) || quantity <= 0) {
          alert('Wybierz materiał i podaj poprawną ilość');
          return;
        }

        const item = (window.warehouseItems || []).find(w => w.id === itemId);
        const order = (state.orders || []).find(o => o.id === orderId);
        
        if (!item || !order) {
          alert('Nie znaleziono pozycji lub zlecenia');
          return;
        }

        // Sprawdź dostępność
        const existingReservations = (window.warehouseReservations || [])
          .filter(r => r.itemId === itemId && r.status === 'active')
          .reduce((sum, r) => sum + r.quantity, 0);
        
        const available = item.quantity - existingReservations;

        if (available < quantity) {
          alert(`Niewystarczająca ilość! Dostępne: ${available} ${item.unit} (stan: ${item.quantity}, zarezerwowane: ${existingReservations})`);
          return;
        }

        // Utwórz rezerwację
        const reservation = {
          id: generateId(),
          orderId: order.id,
          orderName: order.name,
          itemId: item.id,
          itemName: item.name,
          quantity: quantity,
          unit: item.unit,
          notes: notes,
          date: new Date().toISOString(),
          timestamp: Date.now(),
          status: 'active' // active, used, cancelled
        };

        if (!window.warehouseReservations) {
          window.warehouseReservations = [];
        }
        window.warehouseReservations.push(reservation);

        saveWarehouseToStorage();
        alert(`✅ Zarezerwowano ${quantity} ${item.unit} - ${item.name} dla zlecenia ${order.name}`);
        renderReservations();
      }
    }
  ]);
}

function getReservedQuantity(itemIdx) {
  if (!window.warehouseReservations) return 0;
  return window.warehouseReservations
    .filter(r => r.itemId === itemIdx && r.status === 'active')
    .reduce((sum, r) => sum + r.quantity, 0);
}

function renderReservations() {
  const list = document.getElementById('wh-reservations-list');
  if (!list) return;

  // Zapamiętaj otwarte szczegóły PRZED renderowaniem
  const openDetails = [];
  document.querySelectorAll('[id^="details-"]').forEach(el => {
    if (el.style.display !== 'none') {
      openDetails.push(el.id);
    }
  });

  const reservations = (window.warehouseReservations || []).filter(r => r.status === 'active');

  if (reservations.length === 0) {
    list.innerHTML = '<div style="text-align:center;padding:40px;color:#999">Brak aktywnych rezerwacji</div>';
    return;
  }

  // Grupuj rezerwacje po orderId (zleceniu)
  const grouped = {};
  reservations.forEach(res => {
    if (!grouped[res.orderId]) {
      grouped[res.orderId] = {
        orderId: res.orderId,
        orderName: res.orderName,
        materials: []
      };
    }
    grouped[res.orderId].materials.push(res);
  });

  // Renderuj zgrupowane rezerwacje po zleceniu
  list.innerHTML = Object.values(grouped).map(group => {
    const detailsId = `details-${group.orderId}`;
    
    // Sprawdź status wszystkich materiałów w zleceniu - na podstawie receivedDate
    let allReceived = true;
    let someReceived = false;
    let allIssued = true;
    
    group.materials.forEach(mat => {
      if (mat.receivedDate) {
        someReceived = true;
      } else {
        allReceived = false;
      }
      
      if (!mat.issuedDate) {
        allIssued = false;
      }
    });
    
    // Określ kolor ramki i status zlecenia
    let borderColor = '#3b82f6'; // niebieski - zarezerwowane
    let statusBadge = '';
    
    if (allIssued) {
      // Wszystko wydane
      borderColor = '#8b5cf6'; // fioletowy - wydane
      statusBadge = `<span style="display:inline-block;padding:4px 8px;background:#8b5cf6;color:white;border-radius:4px;font-size:12px;font-weight:600;margin-right:6px">📦 Wszystko wydane</span>`;
    } else if (allReceived) {
      // Wszystko przyjęte do magazynu
      borderColor = '#10b981'; // zielony - przyjęte
      statusBadge = `<span style="display:inline-block;padding:4px 8px;background:#10b981;color:white;border-radius:4px;font-size:12px;font-weight:600;margin-right:6px">✅ Wszystko przyjęte</span>`;
    } else if (someReceived) {
      // Częściowo przyjęte
      borderColor = '#f59e0b'; // pomarańczowy - częściowo
      statusBadge = `<span style="display:inline-block;padding:4px 8px;background:#f59e0b;color:white;border-radius:4px;font-size:12px;font-weight:600;margin-right:6px">⚠️ Częściowo przyjęte</span>`;
    } else {
      // Nic nie przyjęte
      borderColor = '#ef4444'; // czerwony - oczekuje
      statusBadge = `<span style="display:inline-block;padding:4px 8px;background:#ef4444;color:white;border-radius:4px;font-size:12px;font-weight:600;margin-right:6px">⏳ Oczekuje na przyjęcie</span>`;
    }
    
    // Oblicz daty przyjęcia i wydania dla całego zlecenia
    let earliestReceived = null;
    let latestIssued = null;
    
    group.materials.forEach(mat => {
      if (mat.receivedDate) {
        const rd = new Date(mat.receivedDate);
        if (!earliestReceived || rd < earliestReceived) {
          earliestReceived = rd;
        }
      }
      if (mat.issuedDate) {
        const id = new Date(mat.issuedDate);
        if (!latestIssued || id > latestIssued) {
          latestIssued = id;
        }
      }
    });
    
    // Formatuj daty dla nagłówka
    let orderDateBadges = '';
    if (earliestReceived) {
      const receivedStr = earliestReceived.toLocaleDateString('pl-PL', { 
        year: 'numeric', month: '2-digit', day: '2-digit', 
        hour: '2-digit', minute: '2-digit' 
      });
      orderDateBadges += `<div style="font-size:14px;margin-bottom:4px;padding:4px 8px;background:#d1fae5;border-left:3px solid #10b981;border-radius:4px">
        <span style="color:#065f46;font-weight:600">✅ Przyjęto:</span>
        <span style="color:#000;font-weight:600;margin-left:6px">${receivedStr}</span>
      </div>`;
    }
    if (latestIssued) {
      const issuedStr = latestIssued.toLocaleDateString('pl-PL', { 
        year: 'numeric', month: '2-digit', day: '2-digit', 
        hour: '2-digit', minute: '2-digit' 
      });
      orderDateBadges += `<div style="font-size:14px;margin-bottom:4px;padding:4px 8px;background:#dbeafe;border-left:3px solid #3b82f6;border-radius:4px">
        <span style="color:#1e40af;font-weight:600">📦 Wydano:</span>
        <span style="color:#000;font-weight:600;margin-left:6px">${issuedStr}</span>
      </div>`;
    }
    
    return `
      <div class="card" style="margin-bottom:12px;border-left:4px solid ${borderColor}">
        <div style="margin-bottom:12px">
          <div style="display:flex;justify-content:space-between;align-items:flex-start">
            <div style="flex:1">
              <div style="font-size:16px;margin-bottom:8px;padding:6px 12px;background:#fef3c7;border-left:3px solid #f59e0b;border-radius:4px">
                <span style="color:#92400e;font-weight:600">📋 Nr zlecenia:</span>
                <span style="color:#000;font-weight:700;font-size:18px;margin-left:8px">${group.orderName}</span>
              </div>
              ${orderDateBadges}
              <div style="margin-bottom:8px">
                ${statusBadge}
                <span style="display:inline-block;padding:4px 8px;background:#e2e8f0;color:#334155;border-radius:4px;font-size:12px;font-weight:600">📦 ${group.materials.length} ${group.materials.length === 1 ? 'materiał' : 'materiałów'}</span>
              </div>
            </div>
            <div style="display:flex;flex-direction:column;gap:6px;margin-left:12px">
              <button class="btn small blue" onclick="toggleDetails('${detailsId}')">
                Szczegóły ▼
              </button>
              <button class="btn small" onclick="exportIssuedMaterials('${group.orderId}', '${group.orderName}')" style="background:#10b981;color:white">
                📄 Wydano (Excel)
              </button>
              <button class="btn small" onclick="completeOrder('${group.orderId}')" style="background:#8b5cf6;color:white">
                🏁 Zakończ zlecenie
              </button>
            </div>
          </div>
        </div>
        
        <div id="${detailsId}" style="display:none;border-top:1px solid #e2e8f0;padding-top:12px;margin-top:8px">
          ${group.materials.map(mat => {
            // Formatuj daty
            const reservedDate = mat.date ? new Date(mat.date).toLocaleDateString('pl-PL', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' }) : 'Brak daty';
            const receivedDateStr = mat.receivedDate ? new Date(mat.receivedDate).toLocaleDateString('pl-PL', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' }) : null;
            const issuedDateStr = mat.issuedDate ? new Date(mat.issuedDate).toLocaleDateString('pl-PL', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' }) : null;
            
            // Sprawdź status materiału na podstawie dat
            let statusBadge = '';
            let bgColor = '#f8fafc';
            
            if (mat.issuedDate) {
              statusBadge = `<span style="display:inline-block;padding:3px 6px;background:#3b82f6;color:white;border-radius:3px;font-size:11px;font-weight:600;margin-left:8px">📦 Wydano</span>`;
              bgColor = '#eff6ff';
            } else if (mat.receivedDate) {
              statusBadge = `<span style="display:inline-block;padding:3px 6px;background:#10b981;color:white;border-radius:3px;font-size:11px;font-weight:600;margin-left:8px">✅ Przyjęto</span>`;
              bgColor = '#f0fdf4';
            } else {
              statusBadge = `<span style="display:inline-block;padding:3px 6px;background:#f59e0b;color:white;border-radius:3px;font-size:11px;font-weight:600;margin-left:8px">⏳ Oczekuje</span>`;
              bgColor = '#fffbeb';
            }
            
            return `
              <div style="padding:12px;background:${bgColor};border-radius:6px;margin-bottom:8px">
                <div style="display:flex;justify-content:space-between;align-items:flex-start;gap:12px">
                  <div style="flex:1">
                    <div style="font-size:15px;font-weight:600;color:#334155;margin-bottom:6px">
                      📦 ${mat.itemName}
                      ${statusBadge}
                    </div>
                    <div style="font-size:14px;color:#64748b;margin-bottom:6px">
                      Ilość: <strong style="color:#1e293b;font-size:16px">${mat.quantity} ${mat.unit}</strong>
                    </div>
                    <div style="font-size:13px;color:#64748b;line-height:1.6">
                      📅 <strong>Zarezerwowano:</strong> ${reservedDate}
                      ${receivedDateStr ? `<br>✅ <strong style="color:#059669">Przyjęto:</strong> ${receivedDateStr}` : ''}
                      ${issuedDateStr ? `<br>📦 <strong style="color:#2563eb">Wydano:</strong> ${issuedDateStr}` : ''}
                    </div>
                    ${mat.notes ? `<div style="font-size:12px;color:#94a3b8;margin-top:6px;font-style:italic;padding:6px;background:#f8fafc;border-radius:4px">💬 ${mat.notes}</div>` : ''}
                  </div>
                  <div style="display:flex;flex-direction:column;gap:6px;min-width:140px">
                    ${!mat.receivedDate ? `<button class="btn small green" onclick="markAsReceived('${mat.id}')" style="width:100%;font-size:13px;padding:8px">
                      Przyjmij
                    </button>` : `<button class="btn small" disabled style="width:100%;font-size:13px;padding:8px;background:#d1fae5;color:#065f46;cursor:not-allowed">
                      ✅ Przyjęto
                    </button>`}
                    ${mat.receivedDate && !mat.issuedDate ? `<button class="btn small blue" onclick="markAsIssued('${mat.id}')" style="width:100%;font-size:13px;padding:8px">
                      📦 Wydaj
                    </button>` : mat.issuedDate ? `<button class="btn small" disabled style="width:100%;font-size:13px;padding:8px;background:#dbeafe;color:#1e40af;cursor:not-allowed">
                      📦 Wydano
                    </button>` : ''}
                    <button class="btn small red" onclick="cancelReservation('${mat.id}')" style="width:100%;font-size:13px;padding:8px">
                      ✕ Anuluj
                    </button>
                  </div>
                </div>
              </div>
            `;
          }).join('')}
        </div>
      </div>
    `;
  }).join('');
  
  // Przywróć otwarte szczegóły PO renderowaniu
  requestAnimationFrame(() => {
    openDetails.forEach(detailsId => {
      const details = document.getElementById(detailsId);
      if (details) {
        details.style.display = 'block';
        // Zmień tekst przycisku
        const button = document.querySelector(`button[onclick="toggleDetails('${detailsId}')"]`);
        if (button) {
          button.textContent = 'Ukryj ▲';
        }
      }
    });
  });
}

// Udostępnij globalnie
window.renderReservations = renderReservations;

// Funkcja do przełączania szczegółów
window.toggleDetails = function(detailsId) {
  const details = document.getElementById(detailsId);
  if (!details) return;
  
  const isHidden = details.style.display === 'none';
  details.style.display = isHidden ? 'block' : 'none';
  
  // Zmień tekst przycisku
  const button = document.querySelector(`button[onclick="toggleDetails('${detailsId}')"]`);
  if (button) {
    button.textContent = isHidden ? 'Ukryj ▲' : 'Szczegóły ▼';
  }
};

// Oznacz materiał jako przyjęty (dostępny w magazynie)
window.markAsReceived = function(resId) {
  if (!window.warehouseReservations || !Array.isArray(window.warehouseReservations)) {
    alert('Błąd: Brak danych rezerwacji');
    return;
  }
  
  // Znajdź dokładnie tę jedną rezerwację
  const reservation = window.warehouseReservations.find(r => r.id === resId);
  
  if (!reservation) {
    alert('Błąd: Nie znaleziono rezerwacji');
    return;
  }
  
  // Sprawdź czy już nie jest przyjęta
  if (reservation.receivedDate) {
    alert('Ten materiał jest już oznaczony jako przyjęty');
    return;
  }
  
  if (confirm(`Przyjąć materiał do magazynu?\n\n📦 ${reservation.itemName}\nIlość: ${reservation.quantity} ${reservation.unit}\nZlecenie: ${reservation.orderName}`)) {
    // Oznacz jako przyjęty - dodaj datę
    reservation.receivedDate = new Date().toISOString();
    
    // Zapisz do localStorage
    saveWarehouseToStorage();
    
    // Odśwież widok - NIE zamykaj otwartych szczegółów
    alert(`✅ Przyjęto: ${reservation.itemName}`);
    
    // Zapamiętaj, które szczegóły są otwarte
    window._keepDetailsOpen = true;
    renderReservations();
  }
};

// Oznacz materiał jako wydany (wydano z magazynu do zlecenia)
window.markAsIssued = function(resId) {
  if (!window.warehouseReservations || !Array.isArray(window.warehouseReservations)) {
    alert('Błąd: Brak danych rezerwacji');
    return;
  }
  
  // Znajdź dokładnie tę jedną rezerwację
  const reservation = window.warehouseReservations.find(r => r.id === resId);
  
  if (!reservation) {
    alert('Błąd: Nie znaleziono rezerwacji');
    return;
  }
  
  // Sprawdź czy materiał został przyjęty
  if (!reservation.receivedDate) {
    alert('Najpierw oznacz materiał jako przyjęty');
    return;
  }
  
  // Sprawdź czy już nie jest wydany
  if (reservation.issuedDate) {
    alert('Ten materiał jest już oznaczony jako wydany');
    return;
  }
  
  if (confirm(`Wydać materiał z magazynu?\n\n📦 ${reservation.itemName}\nIlość: ${reservation.quantity} ${reservation.unit}\nZlecenie: ${reservation.orderName}\n\n⚠️ Stan magazynu zostanie zmniejszony`)) {
    // Oznacz jako wydany - dodaj datę
    reservation.issuedDate = new Date().toISOString();
    
    // Zmniejsz stan magazynu
    const warehouseItem = (window.warehouseItems || []).find(w => w.id === reservation.itemId);
    if (warehouseItem) {
      warehouseItem.quantity -= reservation.quantity;
      
      // Utwórz transakcję WZ (wydanie zewnętrzne)
      const transaction = {
        id: generateId(),
        type: 'WZ',
        itemId: reservation.itemId,
        itemName: reservation.itemName,
        quantity: reservation.quantity,
        unit: reservation.unit,
        date: new Date().toISOString(),
        notes: `Wydano dla zlecenia: ${reservation.orderName}`,
        orderId: reservation.orderId,
        orderName: reservation.orderName
      };
      
      if (!window.warehouseTransactions) {
        window.warehouseTransactions = [];
      }
      window.warehouseTransactions.push(transaction);
    }
    
    // Zapisz do localStorage
    saveWarehouseToStorage();
    
    // Odśwież widok - NIE zamykaj otwartych szczegółów
    alert(`📦 Wydano: ${reservation.itemName}\n\nStan magazynu: ${warehouseItem ? warehouseItem.quantity : '?'} ${reservation.unit}`);
    
    // Zapamiętaj, które szczegóły są otwarte
    window._keepDetailsOpen = true;
    renderReservations();
    if (typeof renderWarehouse === 'function') renderWarehouse();
  }
};

// Anuluj rezerwację
window.cancelReservation = function(resId) {
  if (!window.warehouseReservations || !Array.isArray(window.warehouseReservations)) {
    alert('Błąd: Brak danych rezerwacji');
    return;
  }
  
  // Znajdź dokładnie tę jedną rezerwację
  const reservation = window.warehouseReservations.find(r => r.id === resId);
  
  if (!reservation) {
    alert('Błąd: Nie znaleziono rezerwacji');
    return;
  }
  
  if (confirm(`Anulować rezerwację?\n\n📦 ${reservation.itemName}\nIlość: ${reservation.quantity} ${reservation.unit}\nZlecenie: ${reservation.orderName}\n\n⚠️ Rezerwacja zostanie usunięta`)) {
    // Zmień status na 'cancelled'
    reservation.status = 'cancelled';
    reservation.cancelledDate = new Date().toISOString();
    
    // Zapisz do localStorage
    saveWarehouseToStorage();
    
    // Odśwież widok - NIE zamykaj otwartych szczegółów
    alert(`✕ Anulowano rezerwację: ${reservation.itemName}`);
    
    // Zapamiętaj, które szczegóły są otwarte
    window._keepDetailsOpen = true;
    renderReservations();
  }
};

// Zakończ zlecenie - przenieś rezerwacje do archiwum
window.completeOrder = function(orderId) {
  const reservations = (window.warehouseReservations || []).filter(r => r.orderId === orderId && r.status === 'active');
  
  if (reservations.length === 0) {
    alert('Brak aktywnych rezerwacji dla tego zlecenia');
    return;
  }
  
  const orderName = reservations[0].orderName;
  
  if (confirm(`Zakończyć zlecenie "${orderName}"?\n\n✓ Wszystkie rezerwacje zostaną zamknięte\n✓ Zlecenie przejdzie do archiwum\n✓ Historia zostanie zachowana\n\nLiczba rezerwacji: ${reservations.length}`)) {
    // Zmień status wszystkich rezerwacji na 'completed'
    reservations.forEach(res => {
      res.status = 'completed';
      res.completedDate = new Date().toISOString();
    });
    
    saveWarehouseToStorage();
    alert(`🏁 Zlecenie "${orderName}" zakończone!\n\n${reservations.length} rezerwacji przeniesiono do archiwum.`);
    renderReservations();
  }
};

// Eksport wydanych materiałów do Excel/CSV
window.exportIssuedMaterials = function(orderId, orderName) {
  const reservations = (window.warehouseReservations || [])
    .filter(r => r.orderId === orderId && r.status === 'active');
  
  if (reservations.length === 0) {
    alert('Brak materiałów do eksportu dla tego zlecenia');
    return;
  }
  
  // Przygotuj dane do eksportu
  let csvContent = '\uFEFF'; // BOM dla UTF-8
  csvContent += `KARTA WYDANIA MATERIAŁÓW\n`;
  csvContent += `Zlecenie nr: ${orderName}\n`;
  csvContent += `Data wydruku: ${new Date().toLocaleDateString('pl-PL', { 
    year: 'numeric', month: '2-digit', day: '2-digit',
    hour: '2-digit', minute: '2-digit' 
  })}\n\n`;
  
  // Nagłówki tabeli
  csvContent += `Lp.;Materiał;Ilość;Jednostka;Data przyjęcia;Data wydania;Status\n`;
  
  // Dane materiałów
  reservations.forEach((mat, index) => {
    const lp = index + 1;
    const itemName = mat.itemName || '';
    const quantity = mat.quantity || 0;
    const unit = mat.unit || 'szt';
    
    const receivedDate = mat.receivedDate 
      ? new Date(mat.receivedDate).toLocaleDateString('pl-PL', { 
          year: 'numeric', month: '2-digit', day: '2-digit',
          hour: '2-digit', minute: '2-digit' 
        })
      : 'Oczekuje';
    
    const issuedDate = mat.issuedDate 
      ? new Date(mat.issuedDate).toLocaleDateString('pl-PL', { 
          year: 'numeric', month: '2-digit', day: '2-digit',
          hour: '2-digit', minute: '2-digit' 
        })
      : '-';
    
    const status = mat.issuedDate 
      ? 'Wydano' 
      : (mat.receivedDate ? 'Przyjęto' : 'Oczekuje');
    
    csvContent += `${lp};${itemName};${quantity};${unit};${receivedDate};${issuedDate};${status}\n`;
  });
  
  // Podsumowanie
  csvContent += `\n`;
  csvContent += `Razem materiałów: ${reservations.length}\n`;
  csvContent += `Wydanych: ${reservations.filter(r => r.issuedDate).length}\n`;
  csvContent += `Oczekujących: ${reservations.filter(r => !r.issuedDate).length}\n`;
  
  // Podpisy
  csvContent += `\n\n`;
  csvContent += `Wydał: ________________  Data: ________  Podpis: ________________\n`;
  csvContent += `\n`;
  csvContent += `Odebrał: ________________  Data: ________  Podpis: ________________\n`;
  
  // Utwórz plik i pobierz
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);
  
  link.setAttribute('href', url);
  link.setAttribute('download', `Wydanie_materialy_zlecenie_${orderName}_${new Date().toISOString().split('T')[0]}.csv`);
  link.style.visibility = 'hidden';
  
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  
  alert(`📄 Wyeksportowano kartę wydania materiałów\n\nZlecenie: ${orderName}\nMateriałów: ${reservations.length}\n\nPlik CSV można otworzyć w Excel`);
};

// ============ SYSTEM ZADAŃ MAGAZYNIERA ============

// Inicjalizacja zadań magazyniera w localStorage
if (!window.warehouseTasks) {
  window.warehouseTasks = JSON.parse(localStorage.getItem('warehouseTasks') || '[]');
}

  // Synchronizuj zadania magazynowe ze zleceniami (wywoływane po każdym zapisie stanu)
window.syncWarehouseTasks = function() {
  if (!window.state || !window.state.orders) return;
  
  // Dla każdego aktywnego zlecenia sprawdź materiały
  window.state.orders.forEach(order => {
    if (order.materialChecklist && order.materialChecklist.length > 0) {
      generateWarehouseTasksForOrder(order);
    }
  });
  
  // Aktualizuj badge
  if (typeof window.updateTasksBadge === 'function') {
    window.updateTasksBadge();
  }
};// Generuj automatyczne zadania dla zlecenia
window.generateWarehouseTasksForOrder = function(order) {
  if (!order || !order.id) return;
  
  const orderStartDate = order.startDate ? new Date(order.startDate) : null;
  const materialsNeeded = order.materialChecklist || [];
  
  if (materialsNeeded.length === 0) return;
  
  // Oblicz daty ostrzeżeń (3 dni przed start produkcji)
  const warningDate = orderStartDate ? new Date(orderStartDate) : new Date();
  warningDate.setDate(warningDate.getDate() - 3);
  
  // Sprawdź, czy materiały są w magazynie
  materialsNeeded.forEach(material => {
    const warehouseItem = (window.warehouseItems || []).find(w => w.id === material.itemId);
    const inStock = warehouseItem ? warehouseItem.quantity : 0;
    const needed = material.quantity || 0;
    
    if (inStock < needed) {
      // Brakuje materiału - utwórz zadanie zamówienia
      const task = {
        id: 'task_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
        type: 'order_material', // typ: order_material, receive_material, prepare_material, issue_material
        orderId: order.id,
        orderName: order.name,
        itemId: material.itemId,
        itemName: material.itemName,
        unit: material.unit || 'szt.',
        quantityNeeded: needed,
        quantityInStock: inStock,
        quantityToOrder: needed - inStock,
        status: 'pending', // pending, in_progress, completed, cancelled
        priority: 'normal', // normal, urgent
        dueDate: warningDate.toISOString(),
        createdAt: new Date().toISOString(),
        createdBy: 'System',
        assignedTo: 'Magazynier'
      };
      
      // Sprawdź czy nie ma już takiego zadania
      const existingTask = window.warehouseTasks.find(t => 
        t.orderId === order.id && 
        t.itemId === material.itemId && 
        t.type === 'order_material' && 
        t.status !== 'cancelled'
      );
      
      if (!existingTask) {
        window.warehouseTasks.push(task);
      }
    }
  });
  
  // Zapisz zadania
  localStorage.setItem('warehouseTasks', JSON.stringify(window.warehouseTasks));
};

// Renderuj zadania magazyniera - NOWA WERSJA z grupowaniem po zleceniach
window.renderWarehouseTasks = function() {
  const list = document.getElementById('wh-tasks-list');
  if (!list) return;
  
  // Zapamiętaj otwarte szczegóły
  const openDetails = [];
  document.querySelectorAll('[id^="task-details-"]').forEach(el => {
    if (el.style.display !== 'none') {
      openDetails.push(el.id);
    }
  });
  
  const tasks = window.warehouseTasks || [];
  const activeTasks = tasks.filter(t => t.status !== 'cancelled');
  
  if (activeTasks.length === 0) {
    list.innerHTML = '<div style="text-align:center;padding:40px;color:#999">Brak zadań dla magazyniera</div>';
    return;
  }
  
  // Grupuj zadania po zleceniach
  const grouped = {};
  activeTasks.forEach(task => {
    if (!grouped[task.orderId]) {
      grouped[task.orderId] = {
        orderId: task.orderId,
        orderName: task.orderName,
        tasks: []
      };
    }
    grouped[task.orderId].tasks.push(task);
  });
  
  // Sortuj zlecenia: najpilniejsze zadania na górze
  const orderArray = Object.values(grouped).map(group => {
    const urgentCount = group.tasks.filter(t => t.priority === 'urgent' && t.status !== 'completed').length;
    const pendingCount = group.tasks.filter(t => t.status === 'pending').length;
    const inProgressCount = group.tasks.filter(t => t.status === 'in_progress').length;
    const completedCount = group.tasks.filter(t => t.status === 'completed').length;
    
    // Znajdź najpilniejszy termin
    const earliestDueDate = group.tasks
      .filter(t => t.status !== 'completed')
      .map(t => new Date(t.dueDate))
      .sort((a, b) => a - b)[0];
    
    return {
      ...group,
      urgentCount,
      pendingCount,
      inProgressCount,
      completedCount,
      earliestDueDate
    };
  }).sort((a, b) => {
    if (a.urgentCount !== b.urgentCount) return b.urgentCount - a.urgentCount;
    if (a.earliestDueDate && b.earliestDueDate) return a.earliestDueDate - b.earliestDueDate;
    return 0;
  });
  
  list.innerHTML = orderArray.map(group => {
    // Badge z liczbami
    let countBadge = '';
    if (group.urgentCount > 0) {
      countBadge = `<span style="background:#dc2626;color:white;padding:4px 8px;border-radius:6px;font-size:13px;margin-left:8px">⚠️ ${group.urgentCount} pilne</span>`;
    }
    if (group.inProgressCount > 0) {
      countBadge += `<span style="background:#3b82f6;color:white;padding:4px 8px;border-radius:6px;font-size:13px;margin-left:8px">⏳ ${group.inProgressCount} w trakcie</span>`;
    }
    if (group.pendingCount > 0) {
      countBadge += `<span style="background:#6b7280;color:white;padding:4px 8px;border-radius:6px;font-size:13px;margin-left:8px">${group.pendingCount} oczekujące</span>`;
    }
    
    const borderColor = group.urgentCount > 0 ? '#dc2626' : '#3b82f6';
    
    // Sortuj zadania w ramach zlecenia
    const sortedTasks = group.tasks.sort((a, b) => {
      const isUrgentA = new Date(a.dueDate) < new Date();
      const isUrgentB = new Date(b.dueDate) < new Date();
      const statusOrder = { pending: 0, in_progress: 1, completed: 2 };
      
      if (isUrgentA !== isUrgentB) return isUrgentB - isUrgentA;
      if (a.status !== b.status) return statusOrder[a.status] - statusOrder[b.status];
      
      return new Date(a.dueDate) - new Date(b.dueDate);
    });
    
    const taskListHTML = sortedTasks.map(task => {
      const isUrgent = new Date(task.dueDate) < new Date();
      const isCompleted = task.status === 'completed';
      
      let statusBadge = '';
      let borderColor = '#e5e7eb';
      
      if (isCompleted) {
        statusBadge = `<span style="background:#10b981;color:white;padding:2px 8px;border-radius:4px;font-size:12px;margin-left:8px">✅ Zakończone</span>`;
      } else if (isUrgent) {
        statusBadge = `<span style="background:#dc2626;color:white;padding:2px 8px;border-radius:4px;font-size:12px;margin-left:8px">⚠️ PILNE</span>`;
        borderColor = '#dc2626';
      } else if (task.status === 'in_progress') {
        statusBadge = `<span style="background:#3b82f6;color:white;padding:2px 8px;border-radius:4px;font-size:12px;margin-left:8px">⏳ W trakcie</span>`;
      } else {
        statusBadge = `<span style="background:#6b7280;color:white;padding:2px 8px;border-radius:4px;font-size:12px;margin-left:8px">⏸️ Oczekujące</span>`;
      }
      
      const dueDate = new Date(task.dueDate).toLocaleDateString('pl-PL', {
        year: 'numeric', month: '2-digit', day: '2-digit'
      });
      
      let taskIcon = '📦';
      let taskTitle = '';
      let taskDescription = '';
      
      if (task.type === 'order_material') {
        taskIcon = '🛒';
        taskTitle = `Zamówić materiał: ${task.itemName}`;
        taskDescription = `Brakuje: ${task.quantityToOrder} ${task.unit || 'szt.'}<br>W magazynie: ${task.quantityInStock} ${task.unit || 'szt.'}, Potrzeba: ${task.quantityNeeded} ${task.unit || 'szt.'}`;
      } else if (task.type === 'receive_material') {
        taskIcon = '📥';
        taskTitle = `Przyjąć dostawę: ${task.itemName}`;
        taskDescription = `Ilość: ${task.quantity} ${task.unit || 'szt.'}`;
      } else if (task.type === 'prepare_material') {
        taskIcon = '📦';
        taskTitle = `Przygotować materiały`;
        taskDescription = `Wszystkie materiały dla zlecenia`;
      } else if (task.type === 'issue_material') {
        taskIcon = '📤';
        taskTitle = `Wydać materiał: ${task.itemName}`;
        taskDescription = `Ilość: ${task.quantity} ${task.unit || 'szt.'}`;
      }
      
      return `
        <div style="background:#f9fafb;border-left:3px solid ${borderColor};padding:12px;margin-bottom:8px;border-radius:4px">
          <div style="display:flex;align-items:flex-start;justify-content:space-between;gap:12px">
            <div style="flex:1">
              <div style="font-weight:600;font-size:14px;color:#1f2937">
                ${taskIcon} ${taskTitle}${statusBadge}
              </div>
              <div style="font-size:13px;color:#6b7280;margin-top:6px">
                ${taskDescription}
              </div>
              <div style="font-size:12px;color:#9ca3af;margin-top:6px">
                📅 Termin: ${dueDate}
              </div>
            </div>
            <div style="display:flex;flex-direction:column;gap:6px;min-width:120px">
              ${!isCompleted ? `
                <button class="btn small green" onclick="completeWarehouseTask('${task.id}')" style="width:100%;font-size:12px;padding:6px 10px">
                  ✅ Zakończ
                </button>
                <button class="btn small blue" onclick="startWarehouseTask('${task.id}')" style="width:100%;font-size:12px;padding:6px 10px">
                  ▶️ Rozpocznij
                </button>
              ` : ''}
              <button class="btn small red" onclick="cancelWarehouseTask('${task.id}')" style="width:100%;font-size:12px;padding:6px 10px">
                ✕ Anuluj
              </button>
            </div>
          </div>
        </div>
      `;
    }).join('');
    
    return `
      <div style="background:white;border:2px solid ${borderColor};border-radius:8px;padding:16px;margin-bottom:12px">
        <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:12px">
          <div>
            <div style="font-weight:700;font-size:18px;color:#1f2937">
              📋 Zlecenie ${group.orderName}
              ${countBadge}
            </div>
            <div style="color:#6b7280;font-size:13px;margin-top:4px">
              ${group.tasks.length} zadań (${group.completedCount} zakończone)
            </div>
          </div>
          <button onclick="toggleTaskDetails('${group.orderId}')" 
                  id="task-toggle-${group.orderId}"
                  style="background:#3b82f6;color:white;border:none;padding:8px 16px;border-radius:6px;cursor:pointer;font-size:14px">
            ▼ Szczegóły
          </button>
        </div>
        <div id="task-details-${group.orderId}" style="display:none">
          ${taskListHTML}
        </div>
      </div>
    `;
  }).join('');
  
  // Przywróć stan otwartych szczegółów
  requestAnimationFrame(() => {
    openDetails.forEach(detailsId => {
      const details = document.getElementById(detailsId);
      const toggleBtn = document.getElementById(detailsId.replace('task-details-', 'task-toggle-'));
      if (details && toggleBtn) {
        details.style.display = 'block';
        toggleBtn.textContent = '▲ Ukryj';
      }
    });
  });
  
  // Aktualizuj badge z liczbą pilnych zadań
  updateTasksBadge();
};

// Toggle szczegółów zadań dla zlecenia
window.toggleTaskDetails = function(orderId) {
  const details = document.getElementById(`task-details-${orderId}`);
  const toggleBtn = document.getElementById(`task-toggle-${orderId}`);
  
  if (!details || !toggleBtn) return;
  
  const isHidden = details.style.display === 'none';
  details.style.display = isHidden ? 'block' : 'none';
  toggleBtn.textContent = isHidden ? '▲ Ukryj' : '▼ Szczegóły';
};

// Aktualizuj badge z liczbą zadań
window.updateTasksBadge = function() {
  const badge = document.getElementById('tasks-badge');
  if (!badge) return;
  
  const tasks = window.warehouseTasks || [];
  const urgentTasks = tasks.filter(t => {
    if (t.status === 'completed' || t.status === 'cancelled') return false;
    const isUrgent = new Date(t.dueDate) < new Date();
    return isUrgent;
  });
  
  if (urgentTasks.length > 0) {
    badge.textContent = urgentTasks.length;
    badge.style.display = 'block';
  } else {
    badge.style.display = 'none';
  }
};

// Zakończ zadanie
window.completeWarehouseTask = function(taskId) {
  const task = window.warehouseTasks.find(t => t.id === taskId);
  if (!task) return;
  
  if (confirm(`Oznaczyć zadanie jako zakończone?\n\n${task.itemName || 'Zadanie'}`)) {
    task.status = 'completed';
    task.completedAt = new Date().toISOString();
    
    localStorage.setItem('warehouseTasks', JSON.stringify(window.warehouseTasks));
    alert(`✅ Zadanie zakończone`);
    
    window._keepDetailsOpen = true;
    renderWarehouseTasks();
    updateTasksBadge();
  }
};

// Rozpocznij zadanie
window.startWarehouseTask = function(taskId) {
  const task = window.warehouseTasks.find(t => t.id === taskId);
  if (!task) return;
  
  task.status = 'in_progress';
  task.startedAt = new Date().toISOString();
  
  localStorage.setItem('warehouseTasks', JSON.stringify(window.warehouseTasks));
  alert(`▶️ Zadanie rozpoczęte`);
  
  window._keepDetailsOpen = true;
  renderWarehouseTasks();
  updateTasksBadge();
};

// Anuluj zadanie
window.cancelWarehouseTask = function(taskId) {
  const task = window.warehouseTasks.find(t => t.id === taskId);
  if (!task) return;
  
  if (confirm(`Anulować zadanie?\n\n${task.itemName || 'Zadanie'}`)) {
    task.status = 'cancelled';
    task.cancelledAt = new Date().toISOString();
    
    localStorage.setItem('warehouseTasks', JSON.stringify(window.warehouseTasks));
    alert(`✕ Zadanie anulowane`);
    
    window._keepDetailsOpen = true;
    renderWarehouseTasks();
    updateTasksBadge();
  }
};

// Filtruj zadania
window.filterWarehouseTasks = function(filter) {
  // TODO: implementacja filtrowania
  renderWarehouseTasks();
};

function useReservation(resId) {
  const res = window.warehouseReservations.find(r => r.id === resId);
  if (!res) return;

  if (confirm(`Oznaczyć jako wykorzystaną? To wyda ${res.quantity} ${res.unit} z magazynu.`)) {
    res.status = 'used';
    
    // Utwórz transakcję wydania
    const item = window.warehouseItems[res.itemId];
    if (item) {
      item.quantity -= res.quantity;
      
      const transaction = {
        id: generateId(),
        type: 'out',
        itemId: res.itemId,
        itemName: res.itemName,
        quantity: res.quantity,
        unit: res.unit,
        person: `Zlecenie: ${res.orderName}`,
        notes: `Wykorzystanie rezerwacji ${resId}`,
        date: new Date().toISOString(),
        timestamp: Date.now()
      };
      
      if (!window.warehouseTransactions) {
        window.warehouseTransactions = [];
      }
      window.warehouseTransactions.push(transaction);
    }
    
    saveWarehouseToStorage();
    renderReservations();
    renderWarehouse();
  }
}

function cancelReservation(resId) {
  if (confirm('Anulować rezerwację?')) {
    const res = window.warehouseReservations.find(r => r.id === resId);
    if (res) {
      res.status = 'cancelled';
      saveWarehouseToStorage();
      renderReservations();
    }
  }
}

function deleteReservation(resId) {
  if (confirm('Usunąć rezerwację?')) {
    window.warehouseReservations = window.warehouseReservations.filter(r => r.id !== resId);
    saveWarehouseToStorage();
    renderReservations();
  }
}

function autoReserveForOrders() {
  alert('Funkcja auto-rezerwacji w trakcie budowy. Będzie automatycznie rezerwować materiały na podstawie procesów produkcyjnych przypisanych do zleceń.');
}

// ===== SZABLONY MATERIAŁOWE =====

function showTemplateModal(templateId = null) {
  const isEdit = templateId !== null;
  const template = isEdit ? window.materialTemplates.find(t => t.id === templateId) : null;
  
  const materialsHtml = (template?.materials || []).map((mat, idx) => {
    return `
      <div class="row" style="gap:8px;margin-bottom:8px;align-items:center" data-mat-idx="${idx}">
        <select class="template-mat-select" style="flex:2;padding:8px;border:1px solid #ccc;border-radius:4px">
          ${window.warehouseItems.map((item, itemIdx) => 
            `<option value="${itemIdx}" ${mat.itemId === itemIdx ? 'selected' : ''}>${item.name} (${item.unit})</option>`
          ).join('')}
        </select>
        <input type="number" class="template-mat-qty" value="${mat.quantity}" min="0.01" step="0.01" placeholder="Ilość" style="flex:1;padding:8px;border:1px solid #ccc;border-radius:4px">
        <button class="btn red small" onclick="removeTemplateMaterial(${idx})">✕</button>
      </div>
    `;
  }).join('');

  const content = `
    <div style="display: flex; flex-direction: column; gap: 16px;">
      <div>
        <label style="display: block; margin-bottom: 4px; font-weight: bold;">Nazwa szablonu:</label>
        <input type="text" id="template-modal-name" value="${template?.name || ''}" placeholder="np. Zestaw drzwi sosnowych" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
      </div>
      <div>
        <label style="display: block; margin-bottom: 8px; font-weight: bold;">Materiały:</label>
        <div id="template-materials-list">
          ${materialsHtml || '<div style="color:#999;text-align:center;padding:20px">Brak materiałów. Kliknij "Dodaj materiał"</div>'}
        </div>
        <button class="btn blue small" onclick="addTemplateMaterial()" style="margin-top:8px">+ Dodaj materiał</button>
      </div>
    </div>
  `;

  showModal(isEdit ? '✏️ Edytuj szablon' : '📑 Nowy szablon', content, [
    { text: 'Anuluj', action: () => {} },
    {
      text: isEdit ? 'Zapisz' : 'Utwórz',
      action: () => {
        const name = document.getElementById('template-modal-name').value.trim();
        if (!name) {
          alert('Podaj nazwę szablonu');
          return;
        }

        // Zbierz materiały
        const materials = [];
        document.querySelectorAll('#template-materials-list > div[data-mat-idx]').forEach(row => {
          const select = row.querySelector('.template-mat-select');
          const qtyInput = row.querySelector('.template-mat-qty');
          const itemIdx = parseInt(select.value);
          const quantity = parseFloat(qtyInput.value);
          
          if (!isNaN(itemIdx) && !isNaN(quantity) && quantity > 0) {
            const item = window.warehouseItems[itemIdx];
            materials.push({
              itemId: item.id,  // ✅ Używamy prawdziwego ID z magazynu, nie indeksu!
              itemName: item.name,
              quantity: quantity,
              unit: item.unit
            });
          }
        });

        if (materials.length === 0) {
          alert('Dodaj przynajmniej jeden materiał');
          return;
        }

        if (isEdit) {
          // Edycja
          const idx = window.materialTemplates.findIndex(t => t.id === templateId);
          window.materialTemplates[idx] = {
            id: templateId,
            name: name,
            materials: materials,
            updatedAt: Date.now()
          };
        } else {
          // Nowy
          window.materialTemplates.push({
            id: generateId(),
            name: name,
            materials: materials,
            createdAt: Date.now()
          });
        }

        saveWarehouseToStorage();
        renderTemplates();
        alert(`✅ Szablon "${name}" został ${isEdit ? 'zaktualizowany' : 'utworzony'}`);
      }
    }
  ]);
}

function addTemplateMaterial() {
  const list = document.getElementById('template-materials-list');
  if (!list) return;
  
  const emptyMsg = list.querySelector('div[style*="color:#999"]');
  if (emptyMsg) emptyMsg.remove();
  
  const newIdx = list.querySelectorAll('div[data-mat-idx]').length;
  const newRow = document.createElement('div');
  newRow.className = 'row';
  newRow.style = 'gap:8px;margin-bottom:8px;align-items:center';
  newRow.setAttribute('data-mat-idx', newIdx);
  newRow.innerHTML = `
    <select class="template-mat-select" style="flex:2;padding:8px;border:1px solid #ccc;border-radius:4px">
      ${window.warehouseItems.map((item, itemIdx) => 
        `<option value="${itemIdx}">${item.name} (${item.unit})</option>`
      ).join('')}
    </select>
    <input type="number" class="template-mat-qty" value="1" min="0.01" step="0.01" placeholder="Ilość" style="flex:1;padding:8px;border:1px solid #ccc;border-radius:4px">
    <button class="btn red small" onclick="this.parentElement.remove()">✕</button>
  `;
  list.appendChild(newRow);
}

function removeTemplateMaterial(idx) {
  const row = document.querySelector(`#template-materials-list > div[data-mat-idx="${idx}"]`);
  if (row) row.remove();
}

function renderTemplates() {
  const list = document.getElementById('wh-templates-list');
  if (!list) return;

  const templates = window.materialTemplates || [];

  if (templates.length === 0) {
    list.innerHTML = '<div style="text-align:center;padding:40px;color:#999">Brak szablonów materiałowych. Kliknij "Nowy szablon".</div>';
    return;
  }

  list.innerHTML = templates.map(tmpl => {
    const materials = tmpl.materials || [];
    const materialsCount = materials.length;
    
    // Wygeneruj checklistę materiałów
    let checklistHtml = '';
    if (materialsCount === 0) {
      checklistHtml = '<div style="text-align:center;padding:20px;color:#94a3b8">Brak materiałów</div>';
    } else {
      checklistHtml = materials.map((m, idx) => `
        <div style="display:flex;align-items:center;gap:12px;padding:8px 0;border-bottom:1px solid #e2e8f0;background:white">
          <input type="checkbox" disabled style="cursor:not-allowed;width:16px;height:16px">
          <span style="flex:1;font-size:15px;color:#000000;font-weight:500">${m.itemName || 'Bez nazwy'}</span>
          <span style="font-size:14px;color:#475569;font-weight:600">${m.quantity || 0} ${m.unit || 'szt'}</span>
        </div>
      `).join('');
    }

    return `
      <div class="card" style="margin-bottom:8px">
        <div class="row" style="justify-content:space-between;align-items:flex-start;margin-bottom:12px">
          <div style="flex:1">
            <div style="font-weight:600;margin-bottom:4px">� ${tmpl.name}</div>
            <div style="font-size:12px;color:#64748b">
              ${materialsCount} ${materialsCount === 1 ? 'pozycja' : materialsCount < 5 ? 'pozycje' : 'pozycji'} do sprawdzenia
            </div>
          </div>
          <div class="row" style="gap:4px">
            <button class="btn small" onclick="showTemplateModal('${tmpl.id}')">Edytuj</button>
            <button class="btn red small" onclick="deleteTemplate('${tmpl.id}')">Usuń</button>
          </div>
        </div>
        <div style="background:#f8fafc;padding:12px;border-radius:4px;max-height:200px;overflow-y:auto">
          ${checklistHtml}
        </div>
      </div>
    `;
  }).join('');
}

function deleteTemplate(templateId) {
  const template = window.materialTemplates.find(t => t.id === templateId);
  if (!template) return;
  
  if (confirm(`Usunąć szablon "${template.name}"?`)) {
    window.materialTemplates = window.materialTemplates.filter(t => t.id !== templateId);
    saveWarehouseToStorage();
    renderTemplates();
  }
}

// Checklist materiałów dla zlecenia
function showMaterialChecklist(orderId) {
  const order = (state.orders || []).find(o => o.id === orderId);
  if (!order) {
    alert('Nie znaleziono zlecenia');
    return;
  }

  if (!order.processId) {
    alert('To zlecenie nie ma przypisanego procesu');
    return;
  }

  const process = (state.processes || []).find(p => p.id === order.processId);
  if (!process || !process.materialTemplateId) {
    alert('Proces nie ma przypisanego szablonu materiałowego');
    return;
  }

  const template = (window.materialTemplates || []).find(t => t.id === process.materialTemplateId);
  if (!template) {
    alert('Nie znaleziono szablonu materiałowego');
    return;
  }

  // Inicjalizuj stan checklisty jeśli nie istnieje
  if (!order.materialChecklist) {
    order.materialChecklist = template.materials.map((m, idx) => ({
      itemId: m.itemId,
      itemName: m.itemName,
      quantity: m.quantity,
      unit: m.unit,
      checked: false,
      checkedAt: null,
      checkedBy: null
    }));
    save();
  }

  // Wygeneruj HTML checklisty (CUSTOM CHECKBOX - bez input)
  const checklistHtml = order.materialChecklist.map((item, idx) => {
    const isChecked = item.checked;
    const checkedStyle = isChecked ? 'text-decoration:line-through;color:#94a3b8' : '';
    const checkInfo = isChecked && item.checkedAt ? 
      `<div style="font-size:10px;color:#94a3b8;margin-top:2px">✓ ${new Date(item.checkedAt).toLocaleString('pl-PL')}</div>` : '';
    
    const checkboxStyle = isChecked 
      ? 'background:#16a34a;border:2px solid #16a34a;color:white' 
      : 'background:#ffffff;border:2px solid #cbd5e1;color:transparent';
    
    return `
      <div onclick="event.stopPropagation(); window.toggleChecklistItem('${orderId}', ${idx})" 
           style="display:flex;align-items:flex-start;gap:14px;padding:14px;border-bottom:1px solid #e2e8f0;background:#ffffff;transition:all 0.2s;cursor:pointer !important"
           onmouseover="this.style.background='#f0fdf4';this.style.transform='translateX(4px)'" 
           onmouseout="this.style.background='#ffffff';this.style.transform='translateX(0)'">
        <div style="width:26px;height:26px;min-width:26px;border-radius:6px;display:flex;align-items:center;justify-content:center;font-size:18px;font-weight:bold;transition:all 0.2s;margin-top:2px;flex-shrink:0;cursor:pointer !important;${checkboxStyle}">
          ${isChecked ? '✓' : ''}
        </div>
        <div style="flex:1;cursor:pointer !important">
          <div style="${checkedStyle};font-size:16px;font-weight:600;color:#000000;transition:all 0.2s">${item.itemName}</div>
          <div style="font-size:13px;color:#64748b;margin-top:4px;font-weight:500">${item.quantity} ${item.unit}</div>
          ${checkInfo}
        </div>
      </div>
    `;
  }).join('');

  const checkedCount = order.materialChecklist.filter(i => i.checked).length;
  const totalCount = order.materialChecklist.length;
  const progress = totalCount > 0 ? Math.round((checkedCount / totalCount) * 100) : 0;

  const content = `
    <div style="margin-bottom:16px">
      <div style="font-size:14px;color:#64748b;margin-bottom:8px">
        Szablon: <strong>${template.name}</strong>
      </div>
      <div style="display:flex;align-items:center;gap:12px">
        <div style="flex:1;background:#e2e8f0;border-radius:8px;height:24px;overflow:hidden">
          <div style="height:100%;width:${progress}%;background:linear-gradient(90deg,#16a34a,#a3e635);transition:width 0.3s"></div>
        </div>
        <div style="font-size:14px;font-weight:600;color:#16a34a">${checkedCount}/${totalCount}</div>
      </div>
    </div>
    <div id="checklist-scroll-container" style="max-height:600px;overflow-y:auto;border:1px solid #e2e8f0;border-radius:8px">
      ${checklistHtml}
    </div>
  `;

  showModal(`📋 Checklist materiałów - ${order.name}`, content, [
    { 
      text: '🔒 Auto-rezerwuj zaznaczone', 
      action: () => {
        window.checklistScrollPosition = undefined;
        // Zamknij modal przed rezerwacją
        const modal = document.getElementById('custom-modal');
        if (modal) {
          modal.remove();
        }
        // Wykonaj rezerwację
        autoReserveFromChecklist(orderId);
        // Odśwież tabelę zleceń
        if (typeof renderOrderPage === 'function') {
          setTimeout(() => {
            renderOrderPage();
            console.log('✅ Tabela zleceń odświeżona po rezerwacji');
          }, 300);
        }
      }
    },
    { 
      text: 'Zamknij', 
      action: () => {
        // Wyczyść zapamiętaną pozycję scrolla przy zamykaniu
        window.checklistScrollPosition = undefined;
        // Odśwież tabelę zleceń aby pokazać zaktualizowany status materiałów
        renderOrderPage();
      }
    }
  ]);
  
  // Przywróć pozycję scrolla jeśli była zapamiętana
  if (window.checklistScrollPosition !== undefined) {
    setTimeout(() => {
      const scrollContainer = document.getElementById('checklist-scroll-container');
      if (scrollContainer) {
        scrollContainer.scrollTop = window.checklistScrollPosition;
        console.log('📜 Przywrócono scroll na pozycję:', window.checklistScrollPosition);
      }
    }, 50);
  }
}

// Flaga blokująca wielokrotne wywołanie
let isTogglingChecklistItem = false;

function toggleChecklistItem(orderId, itemIndex) {
  // Blokada wielokrotnego wywołania
  if (isTogglingChecklistItem) {
    console.warn('⚠️ toggleChecklistItem już w trakcie wykonywania, pomijam...');
    return;
  }
  
  isTogglingChecklistItem = true;
  console.log('🔄 toggleChecklistItem:', orderId, itemIndex);
  
  const order = (state.orders || []).find(o => o.id === orderId);
  if (!order || !order.materialChecklist) {
    console.error('❌ Nie znaleziono zlecenia lub checklisty');
    isTogglingChecklistItem = false;
    return;
  }

  const item = order.materialChecklist[itemIndex];
  const oldChecked = item.checked;
  item.checked = !item.checked;
  item.checkedAt = item.checked ? Date.now() : null;
  item.checkedBy = item.checked ? 'Użytkownik' : null;

  console.log('✅ Zmieniono stan:', oldChecked, '→', item.checked, 'dla:', item.itemName);
  
  save();
  console.log('💾 Stan zapisany, odświeżam modal...');
  
  // Zapamiętaj pozycję scrolla przed usunięciem modalu
  const scrollContainer = document.getElementById('checklist-scroll-container');
  if (scrollContainer) {
    window.checklistScrollPosition = scrollContainer.scrollTop;
    console.log('📜 Zapamiętano pozycję scrolla:', window.checklistScrollPosition);
  }
  
  // Usuń stary modal przed utworzeniem nowego
  const oldModal = document.getElementById('custom-modal');
  if (oldModal) {
    oldModal.remove();
  }
  
  // Odśwież modal
  showMaterialChecklist(orderId);
  
  // Odśwież tabelę zleceń aby pokazać zaktualizowany status materiałów
  if (typeof renderOrderPage === 'function') {
    renderOrderPage();
  }
  
  // Odblokuj po krótkim czasie (pozwól modal się wyrenderować)
  setTimeout(() => {
    isTogglingChecklistItem = false;
    console.log('✅ toggleChecklistItem odblokowany');
  }, 100);
}

// Wyświetl modal z materiałami zlecenia i opcją wydania z magazynu
window.showOrderMaterials = function(orderId) {
  console.log('📦 showOrderMaterials:', orderId);
  
  const order = (state.orders || []).find(o => o.id === orderId);
  if (!order) {
    alert('Nie znaleziono zlecenia');
    return;
  }
  
  if (!order.materialChecklist || order.materialChecklist.length === 0) {
    alert('To zlecenie nie ma przypisanych materiałów');
    return;
  }
  
  const warehouseItems = window.warehouseItems || [];
  const reservations = window.warehouseReservations || [];
  
  // Przygotuj listę materiałów z informacją o dostępności
  const materialsHtml = order.materialChecklist.map((item, idx) => {
    const warehouseItem = warehouseItems.find(w => w.id === item.itemId);
    
    if (!warehouseItem) {
      return `
        <div style="padding:16px;background:#fef2f2;border:2px solid #fecaca;border-radius:8px;margin-bottom:12px">
          <div style="display:flex;align-items:center;gap:12px">
            <div style="font-size:32px">❌</div>
            <div style="flex:1">
              <div style="font-size:16px;font-weight:600;color:#dc2626">${item.itemName}</div>
              <div style="font-size:14px;color:#991b1b;margin-top:4px">Potrzebne: ${item.quantity} ${item.unit}</div>
              <div style="font-size:13px;color:#991b1b;margin-top:4px;font-weight:600">⚠️ Materiał nie znaleziony w magazynie</div>
            </div>
          </div>
        </div>
      `;
    }
    
    const reserved = reservations.filter(r => r.itemId === item.itemId && r.status === 'active').reduce((sum, r) => sum + (r.quantity || 0), 0);
    const available = warehouseItem.quantity - reserved;
    const needed = item.quantity;
    
    let statusIcon = '';
    let statusText = '';
    let statusColor = '';
    let bgColor = '';
    let borderColor = '';
    
    if (available >= needed) {
      statusIcon = '✅';
      statusText = 'Dostępne';
      statusColor = '#16a34a';
      bgColor = '#f0fdf4';
      borderColor = '#bbf7d0';
    } else if (available > 0) {
      statusIcon = '⚠️';
      statusText = `Dostępne tylko ${available} ${item.unit} (brakuje ${needed - available})`;
      statusColor = '#f59e0b';
      bgColor = '#fffbeb';
      borderColor = '#fcd34d';
    } else {
      statusIcon = '❌';
      statusText = 'Brak w magazynie';
      statusColor = '#dc2626';
      bgColor = '#fef2f2';
      borderColor = '#fecaca';
    }
    
    return `
      <div style="padding:16px;background:${bgColor};border:2px solid ${borderColor};border-radius:8px;margin-bottom:12px">
        <div style="display:flex;align-items:center;gap:12px">
          <div style="font-size:32px">${statusIcon}</div>
          <div style="flex:1">
            <div style="font-size:16px;font-weight:600;color:#1e293b">${item.itemName}</div>
            <div style="font-size:14px;color:#64748b;margin-top:4px">Potrzebne: <strong>${needed} ${item.unit}</strong></div>
            <div style="font-size:14px;color:#64748b">W magazynie: <strong>${warehouseItem.quantity} ${item.unit}</strong></div>
            ${reserved > 0 ? `<div style="font-size:13px;color:#64748b">Zarezerwowane: <strong>${reserved} ${item.unit}</strong></div>` : ''}
            <div style="font-size:14px;color:${statusColor};margin-top:4px;font-weight:600">${statusText}</div>
          </div>
        </div>
      </div>
    `;
  }).join('');
  
  // Sprawdź czy można wydać materiały (wszystkie dostępne lub częściowo dostępne)
  let canIssue = false;
  let allAvailable = true;
  let hasPartial = false;
  let allZero = true; // Czy wszystkie materiały mają 0 w magazynie
  
  order.materialChecklist.forEach(item => {
    const warehouseItem = warehouseItems.find(w => w.id === item.itemId);
    if (!warehouseItem) {
      allAvailable = false;
      return;
    }
    const reserved = reservations.filter(r => r.itemId === item.itemId && r.status === 'active').reduce((sum, r) => sum + (r.quantity || 0), 0);
    const available = warehouseItem.quantity - reserved;
    
    if (available > 0) {
      canIssue = true;
      allZero = false;
    }
    if (available < item.quantity) {
      allAvailable = false;
      if (available > 0) {
        hasPartial = true;
      }
    }
  });
  
  // Jeśli wszystkie materiały są w magazynie (nawet jeśli quantity=0), pozwól na "obciążenie"
  // To spowoduje dodanie wszystkich do listy zakupów
  const allMaterialsExist = order.materialChecklist.every(item => 
    warehouseItems.find(w => w.id === item.itemId)
  );
  
  if (allMaterialsExist && allZero) {
    canIssue = true; // Pozwól dodać wszystko do listy zakupów
  }
  
  const content = `
    <div style="margin-bottom:16px">
      <div style="font-size:14px;color:#64748b">
        Zlecenie: <strong>${order.name}</strong> | Klient: <strong>${order.client || '-'}</strong>
      </div>
    </div>
    <div style="max-height:500px;overflow-y:auto">
      ${materialsHtml}
    </div>
  `;
  
  const buttons = [];
  
  if (canIssue) {
    let issueText = '🔄 Obciąż magazyn';
    let buttonStyle = 'background:#16a34a;color:white;font-weight:600';
    
    if (allZero) {
      issueText = '🛒 Dodaj wszystko do listy zakupów';
      buttonStyle = 'background:#f59e0b;color:white;font-weight:600';
    } else if (!allAvailable) {
      issueText = '🔄 Obciąż magazyn (częściowo)';
    }
    
    buttons.push({
      text: issueText,
      style: buttonStyle,
      action: () => {
        document.getElementById('custom-modal')?.remove();
        issueOrderMaterials(orderId);
      }
    });
  }
  
  buttons.push({
    text: 'Zamknij',
    action: () => {}
  });
  
  showModal(`📦 Materiały - ${order.name}`, content, buttons);
};

// Blokada wielokrotnego wydawania
let isIssuingMaterials = false;

// Wydanie materiałów z magazynu dla zlecenia (WZ)
function issueOrderMaterials(orderId) {
  if (isIssuingMaterials) {
    console.warn('⚠️ Wydawanie materiałów już w trakcie...');
    return;
  }
  
  isIssuingMaterials = true;
  console.log('🔄 Rozpoczynam wydawanie materiałów dla zlecenia:', orderId);
  
  const order = (state.orders || []).find(o => o.id === orderId);
  if (!order || !order.materialChecklist) {
    alert('Nie znaleziono zlecenia lub checklisty');
    isIssuingMaterials = false;
    return;
  }
  
  // Sprawdź czy materiały nie zostały już wydane
  const alreadyIssued = order.materialChecklist.every(item => item.issued);
  if (alreadyIssued) {
    alert('⚠️ Materiały dla tego zlecenia zostały już wydane!');
    isIssuingMaterials = false;
    return;
  }
  
  const warehouseItems = window.warehouseItems || [];
  const warehouseTransactions = window.warehouseTransactions || [];
  const reservations = window.warehouseReservations || [];
  
  // Inicjalizacja listy zakupów jeśli nie istnieje
  if (!window.shoppingList) {
    window.shoppingList = [];
  }
  
  const results = {
    issued: [],        // Wydane materiały
    partial: [],       // Wydane częściowo
    shortage: [],      // Braki dodane do listy zakupów
    notFound: []       // Materiał nie istnieje
  };
  
  // Potwierdź operację
  const confirmMsg = `Czy na pewno chcesz wydać materiały z magazynu dla zlecenia "${order.name}"?\n\nOperacja utworzy dokument WZ i zmniejszy stany magazynowe.`;
  if (!confirm(confirmMsg)) {
    isIssuingMaterials = false;
    return;
  }
  
  // Przetwarzaj każdy materiał
  order.materialChecklist.forEach(item => {
    const warehouseItem = warehouseItems.find(w => w.id === item.itemId);
    
    if (!warehouseItem) {
      results.notFound.push(item);
      // Dodaj do listy zakupów
      addToShoppingList(item.itemId, item.itemName, item.quantity, item.unit, orderId, order.name, 'Materiał nie znaleziony w magazynie');
      results.shortage.push(item);
      return;
    }
    
    const reserved = reservations.filter(r => r.itemId === item.itemId && r.status === 'active').reduce((sum, r) => sum + (r.quantity || 0), 0);
    const available = warehouseItem.quantity - reserved;
    const needed = item.quantity;
    
    if (available <= 0) {
      // Brak w magazynie - dodaj do listy zakupów
      addToShoppingList(item.itemId, item.itemName, needed, item.unit, orderId, order.name, 'Brak w magazynie');
      results.shortage.push(item);
      return;
    }
    
    const issueQty = Math.min(available, needed);
    
    // Utwórz transakcję WZ
    const transaction = {
      id: 'wz-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9),
      itemId: item.itemId,
      itemName: item.itemName,
      type: 'WZ',
      quantity: -issueQty, // ujemna wartość = wydanie
      unit: item.unit,
      date: new Date().toISOString().split('T')[0],
      notes: `Wydanie dla zlecenia: ${order.name}`,
      orderId: orderId,
      createdAt: Date.now()
    };
    
    warehouseTransactions.push(transaction);
    
    // Zmniejsz stan magazynowy
    warehouseItem.quantity -= issueQty;
    
    // Oznacz jako wydane w checkliście
    item.issued = true;
    item.issuedQty = issueQty;
    item.issuedAt = Date.now();
    
    if (issueQty === needed) {
      results.issued.push({...item, issuedQty: issueQty});
    } else {
      results.partial.push({...item, issuedQty: issueQty, shortageQty: needed - issueQty});
      // Dodaj brakującą ilość do listy zakupów
      addToShoppingList(item.itemId, item.itemName, needed - issueQty, item.unit, orderId, order.name, 'Wydano częściowo');
      results.shortage.push({...item, shortageQty: needed - issueQty});
    }
    
    // Oznacz rezerwację jako wykorzystaną (jeśli była)
    const orderReservations = reservations.filter(r => r.itemId === item.itemId && r.orderId === orderId && r.status === 'active');
    orderReservations.forEach(r => {
      r.status = 'used';
      r.usedAt = Date.now();
    });
  });
  
  // Zapisz zmiany
  window.warehouseTransactions = warehouseTransactions;
  window.warehouseReservations = reservations;
  saveWarehouseToStorage();
  save();
  
  console.log('✅ Wydawanie materiałów zakończone:', results);
  
  // Odblokuj
  isIssuingMaterials = false;
  
  // Pokaż raport (odświeżenie tabeli nastąpi po zamknięciu modalu)
  showIssueReport(orderId, results);
}

// Dodaj materiał do listy zakupów
function addToShoppingList(itemId, itemName, quantity, unit, orderId, orderName, reason) {
  if (!window.shoppingList) {
    window.shoppingList = [];
  }
  
  // Sprawdź czy już jest na liście (dla tego samego zlecenia i materiału)
  const existing = window.shoppingList.find(s => 
    s.itemId === itemId && 
    s.orderId === orderId && 
    s.status === 'pending'
  );
  
  if (existing) {
    // Zwiększ ilość
    existing.quantity += quantity;
    existing.updatedAt = Date.now();
    console.log('📝 Zwiększono ilość na liście zakupów:', existing);
  } else {
    // Dodaj nowy wpis
    const item = {
      id: 'shop-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9),
      itemId: itemId,
      itemName: itemName,
      quantity: quantity,
      unit: unit,
      orderId: orderId,
      orderName: orderName,
      reason: reason,
      status: 'pending', // pending | ordered | received
      addedAt: Date.now(),
      updatedAt: Date.now()
    };
    window.shoppingList.push(item);
    console.log('📝 Dodano do listy zakupów:', item);
  }
  
  // Zapisz do localStorage
  localStorage.setItem('shoppingList', JSON.stringify(window.shoppingList));
  updateShoppingListBadge();
}

// Pokaż raport wydania materiałów
function showIssueReport(orderId, results) {
  const order = (state.orders || []).find(o => o.id === orderId);
  const orderName = order ? order.name : orderId;
  
  let html = `<div style="max-height:500px;overflow-y:auto">`;
  
  // Wydane w pełni
  if (results.issued.length > 0) {
    html += `<div style="margin-bottom:20px">
      <h4 style="color:#16a34a;margin-bottom:12px">✅ Wydane materiały (${results.issued.length})</h4>`;
    results.issued.forEach(item => {
      html += `<div style="padding:12px;background:#f0fdf4;border:1px solid #bbf7d0;border-radius:6px;margin-bottom:8px">
        <div style="font-weight:600">${item.itemName}</div>
        <div style="font-size:14px;color:#16a34a">Wydano: ${item.issuedQty} ${item.unit}</div>
      </div>`;
    });
    html += `</div>`;
  }
  
  // Wydane częściowo
  if (results.partial.length > 0) {
    html += `<div style="margin-bottom:20px">
      <h4 style="color:#f59e0b;margin-bottom:12px">⚠️ Wydane częściowo (${results.partial.length})</h4>`;
    results.partial.forEach(item => {
      html += `<div style="padding:12px;background:#fffbeb;border:1px solid #fcd34d;border-radius:6px;margin-bottom:8px">
        <div style="font-weight:600">${item.itemName}</div>
        <div style="font-size:14px;color:#f59e0b">Wydano: ${item.issuedQty} ${item.unit}</div>
        <div style="font-size:14px;color:#dc2626">Brakuje: ${item.shortageQty} ${item.unit} (dodano do listy zakupów)</div>
      </div>`;
    });
    html += `</div>`;
  }
  
  // Braki
  if (results.shortage.length > 0) {
    html += `<div style="margin-bottom:20px">
      <h4 style="color:#dc2626;margin-bottom:12px">🛒 Dodano do listy zakupów (${results.shortage.length})</h4>`;
    results.shortage.forEach(item => {
      const qty = item.shortageQty || item.quantity;
      html += `<div style="padding:12px;background:#fef2f2;border:1px solid #fecaca;border-radius:6px;margin-bottom:8px">
        <div style="font-weight:600">${item.itemName}</div>
        <div style="font-size:14px;color:#dc2626">Do zamówienia: ${qty} ${item.unit}</div>
      </div>`;
    });
    html += `</div>`;
  }
  
  // Nie znaleziono
  if (results.notFound.length > 0) {
    html += `<div style="margin-bottom:20px">
      <h4 style="color:#dc2626;margin-bottom:12px">❌ Nie znaleziono (${results.notFound.length})</h4>`;
    results.notFound.forEach(item => {
      html += `<div style="padding:12px;background:#fef2f2;border:1px solid #fecaca;border-radius:6px;margin-bottom:8px">
        <div style="font-weight:600">${item.itemName}</div>
        <div style="font-size:14px;color:#dc2626">Materiał nie istnieje w magazynie (dodano do listy zakupów)</div>
      </div>`;
    });
    html += `</div>`;
  }
  
  html += `</div>`;
  
  showModal(`📄 Raport wydania - ${orderName}`, html, [
    {
      text: '🛒 Pokaż listę zakupów',
      style: 'background:#3b82f6;color:white',
      action: () => {
        document.getElementById('custom-modal')?.remove();
        showShoppingList();
      }
    },
    {
      text: 'Zamknij',
      action: () => {
        // Odśwież tabelę zleceń po zamknięciu raportu
        renderOrderPage();
      }
    }
  ]);
}

// Wyświetl listę zakupów
window.showShoppingList = function() {
  console.log('🛒 showShoppingList');
  
  // Wczytaj listę z localStorage
  if (!window.shoppingList) {
    const stored = localStorage.getItem('shoppingList');
    window.shoppingList = stored ? JSON.parse(stored) : [];
  }
  
  const pending = window.shoppingList.filter(item => item.status === 'pending');
  console.log('📝 Pozycje pending:', pending.length, pending);
  const ordered = window.shoppingList.filter(item => item.status === 'ordered');
  const received = window.shoppingList.filter(item => item.status === 'received');
  
  let html = `<div style="max-height:500px;overflow-y:auto">`;
  
  // Oczekujące zamówienia
  if (pending.length > 0) {
    html += `<div style="margin-bottom:24px">
      <h4 style="color:#f59e0b;margin-bottom:12px;display:flex;align-items:center;gap:8px">
        <span>📝 Do zamówienia (${pending.length})</span>
      </h4>`;
    
    // Grupuj po materiale
    const grouped = {};
    pending.forEach(item => {
      // Debug: sprawdź czy itemId istnieje
      if (!item.itemId) {
        console.warn('⚠️ Pozycja bez itemId:', item);
        return; // Pomiń pozycje bez itemId
      }
      
      if (!grouped[item.itemId]) {
        grouped[item.itemId] = {
          itemId: item.itemId,
          itemName: item.itemName,
          unit: item.unit,
          totalQty: 0,
          orders: []
        };
      }
      grouped[item.itemId].totalQty += item.quantity;
      grouped[item.itemId].orders.push(item);
    });
    
    Object.values(grouped).forEach(group => {
      html += `<div style="padding:16px;background:#fffbeb;border:2px solid #fcd34d;border-radius:8px;margin-bottom:12px">
        <div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:12px">
          <div>
            <div style="font-size:18px;font-weight:600;color:#1e293b">${group.itemName}</div>
            <div style="font-size:16px;color:#f59e0b;font-weight:600;margin-top:4px">Razem: ${group.totalQty} ${group.unit}</div>
          </div>
        </div>
        <div style="margin-top:12px;padding-top:12px;border-top:1px solid #fcd34d">
          <div style="font-size:13px;color:#64748b;margin-bottom:6px;font-weight:600">Potrzebne dla zleceń:</div>`;
      
      group.orders.forEach(order => {
        html += `<div style="font-size:13px;color:#64748b;margin-bottom:4px">
          • ${order.orderName}: ${order.quantity} ${order.unit} <span style="color:#94a3b8">(${order.reason})</span>
        </div>`;
      });
      
      html += `</div>
        <div style="margin-top:12px;display:flex;gap:8px">
          <button class="btn primary" onclick="window.markAsOrdered('${group.itemId}')" style="background:#16a34a">✅ Zamówiono</button>
          <button class="btn" onclick="window.removeFromShoppingList('${group.itemId}')" style="background:#dc2626;color:white">🗑️ Usuń</button>
        </div>
      </div>`;
    });
    
    html += `</div>`;
  } else {
    html += `<div style="padding:20px;text-align:center;color:#94a3b8">
      <div style="font-size:48px;margin-bottom:12px">✅</div>
      <div>Brak materiałów do zamówienia</div>
    </div>`;
  }
  
  // Zamówione
  if (ordered.length > 0) {
    html += `<div style="margin-bottom:24px">
      <h4 style="color:#3b82f6;margin-bottom:12px">📦 Zamówione (${ordered.length})</h4>`;
    
    ordered.forEach(item => {
      const orderDate = new Date(item.updatedAt).toLocaleDateString();
      html += `<div style="padding:12px;background:#eff6ff;border:1px solid #93c5fd;border-radius:6px;margin-bottom:8px">
        <div style="font-weight:600">${item.itemName}</div>
        <div style="font-size:14px;color:#3b82f6">Ilość: ${item.quantity} ${item.unit}</div>
        <div style="font-size:13px;color:#64748b">Zlecenie: ${item.orderName}</div>
        <div style="font-size:12px;color:#94a3b8">Zamówiono: ${orderDate}</div>
        <div style="margin-top:8px">
          <button class="btn primary" onclick="window.markAsReceivedFromShoppingList('${item.id}')" style="background:#16a34a">✅ Dostarczono</button>
        </div>
      </div>`;
    });
    
    html += `</div>`;
  }
  
  // Dostarczone (ostatnie 10)
  if (received.length > 0) {
    html += `<div style="margin-bottom:24px">
      <h4 style="color:#16a34a;margin-bottom:12px">✅ Dostarczone (ostatnie ${Math.min(10, received.length)})</h4>`;
    
    received.slice(0, 10).forEach(item => {
      const receiveDate = new Date(item.updatedAt).toLocaleDateString();
      html += `<div style="padding:12px;background:#f0fdf4;border:1px solid #bbf7d0;border-radius:6px;margin-bottom:8px">
        <div style="font-weight:600">${item.itemName}</div>
        <div style="font-size:14px;color:#16a34a">Ilość: ${item.quantity} ${item.unit}</div>
        <div style="font-size:13px;color:#64748b">Zlecenie: ${item.orderName}</div>
        <div style="font-size:12px;color:#94a3b8">Dostarczono: ${receiveDate}</div>
      </div>`;
    });
    
    html += `</div>`;
  }
  
  html += `</div>`;
  
  showModal('🛒 Lista zakupów', html, [
    {
      text: 'Odśwież',
      action: () => {
        document.getElementById('custom-modal')?.remove();
        window.showShoppingList();
      }
    },
    {
      text: 'Zamknij',
      action: () => {}
    }
  ]);
};

// Oznacz materiał jako zamówiony (wszystkie oczekujące pozycje tego materiału)
window.markAsOrdered = function(itemId) {
  if (!window.shoppingList) return;
  
  let updated = 0;
  window.shoppingList.forEach(item => {
    if (item.itemId === itemId && item.status === 'pending') {
      item.status = 'ordered';
      item.updatedAt = Date.now();
      updated++;
    }
  });
  
  localStorage.setItem('shoppingList', JSON.stringify(window.shoppingList));
  updateShoppingListBadge();
  console.log(`✅ Oznaczono ${updated} pozycji jako zamówione`);
  
  // Odśwież modal
  document.getElementById('custom-modal')?.remove();
  window.showShoppingList();
};

// Oznacz materiał jako dostarczony (LISTA ZAKUPÓW - stara funkcja)
window.markAsReceivedFromShoppingList = function(itemId) {
  if (!window.shoppingList) return;
  
  const item = window.shoppingList.find(i => i.id === itemId);
  if (!item) return;
  
  item.status = 'received';
  item.updatedAt = Date.now();
  
  localStorage.setItem('shoppingList', JSON.stringify(window.shoppingList));
  updateShoppingListBadge();
  console.log('✅ Oznaczono jako dostarczone:', item.itemName);
  
  // Opcjonalnie: dodaj do magazynu (PZ)
  const addToWarehouse = confirm(`Czy chcesz dodać "${item.itemName}" (${item.quantity} ${item.unit}) do magazynu?\n\nZostanie utworzony dokument PZ.`);
  
  if (addToWarehouse) {
    const warehouseItems = window.warehouseItems || [];
    const warehouseItem = warehouseItems.find(w => w.id === item.itemId);
    
    if (warehouseItem) {
      // Zwiększ stan
      warehouseItem.quantity += item.quantity;
      
      // Utwórz transakcję PZ
      const transaction = {
        id: 'pz-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9),
        itemId: item.itemId,
        itemName: item.itemName,
        type: 'PZ',
        quantity: item.quantity,
        unit: item.unit,
        date: new Date().toISOString().split('T')[0],
        notes: `Przyjęcie z listy zakupów (zlecenie: ${item.orderName})`,
        orderId: item.orderId,
        createdAt: Date.now()
      };
      
      if (!window.warehouseTransactions) {
        window.warehouseTransactions = [];
      }
      window.warehouseTransactions.push(transaction);
      
      saveWarehouseToStorage();
      console.log('✅ Dodano do magazynu:', item.itemName, '+', item.quantity, item.unit);
      alert(`✅ Dodano ${item.itemName} (+${item.quantity} ${item.unit}) do magazynu`);
    } else {
      alert('⚠️ Materiał nie istnieje w magazynie. Najpierw dodaj go ręcznie.');
    }
  }
  
  // Odśwież modal
  document.getElementById('custom-modal')?.remove();
  window.showShoppingList();
};

// Usuń z listy zakupów (wszystkie oczekujące pozycje tego materiału)
window.removeFromShoppingList = function(itemId) {
  if (!window.shoppingList) return;
  
  const toRemove = window.shoppingList.filter(i => i.itemId === itemId && i.status === 'pending');
  
  if (toRemove.length === 0) return;
  
  const confirmMsg = `Czy na pewno usunąć ${toRemove.length} pozycji materiału "${toRemove[0].itemName}" z listy zakupów?`;
  if (!confirm(confirmMsg)) return;
  
  window.shoppingList = window.shoppingList.filter(i => !(i.itemId === itemId && i.status === 'pending'));
  
  localStorage.setItem('shoppingList', JSON.stringify(window.shoppingList));
  updateShoppingListBadge();
  console.log('🗑️ Usunięto z listy zakupów:', toRemove.length, 'pozycji');
  
  // Odśwież modal
  document.getElementById('custom-modal')?.remove();
  window.showShoppingList();
};

// Auto-rezerwacja materiałów z checklisty
function autoReserveFromChecklist(orderId) {
  console.log('🔒 Rozpoczynam auto-rezerwację dla zlecenia:', orderId);
  
  const order = (state.orders || []).find(o => o.id === orderId);
  if (!order || !order.materialChecklist) {
    alert('Nie znaleziono zlecenia lub checklisty');
    return;
  }

  // Pobierz tylko zaznaczone materiały
  const checkedItems = order.materialChecklist.filter(item => item.checked);
  
  if (checkedItems.length === 0) {
    alert('Nie zaznaczono żadnych materiałów do rezerwacji');
    return;
  }

  const results = {
    reserved: [],      // Udane rezerwacje
    insufficient: [],  // Niewystarczająca ilość
    notFound: []       // Materiał nie istnieje w magazynie
  };

  // Sprawdź każdy zaznaczony materiał
  checkedItems.forEach(item => {
    const warehouseItem = (window.warehouseItems || []).find(w => w.id === item.itemId);
    
    if (!warehouseItem) {
      results.notFound.push({
        orderId: orderId,
        orderName: order.name,
        name: item.itemName,
        needed: item.quantity,
        unit: item.unit
      });
      return;
    }

    // Oblicz dostępną ilość (zapas - już zarezerwowane)
    const existingReservations = (window.warehouseReservations || [])
      .filter(r => r.itemId === item.itemId && r.status === 'active')
      .reduce((sum, r) => sum + r.quantity, 0);
    
    const available = warehouseItem.quantity - existingReservations;

    if (available < item.quantity) {
      results.insufficient.push({
        orderId: orderId,
        orderName: order.name,
        name: item.itemName,
        needed: item.quantity,
        available: available,
        unit: item.unit
      });
      return;
    }

    // Utwórz rezerwację
    const reservation = {
      id: generateId(),
      itemId: item.itemId,
      itemName: item.itemName,
      orderId: orderId,
      orderName: order.name,
      quantity: item.quantity,
      unit: item.unit,
      status: 'active',
      createdAt: Date.now(),
      createdBy: 'Auto-rezerwacja'
    };

    if (!window.warehouseReservations) {
      window.warehouseReservations = [];
    }
    window.warehouseReservations.push(reservation);

    results.reserved.push({
      orderId: orderId,
      orderName: order.name,
      name: item.itemName,
      quantity: item.quantity,
      unit: item.unit
    });

    console.log('✅ Zarezerwowano:', item.itemName, item.quantity, item.unit);
  });

  // Zapisz stan magazynu
  saveWarehouseToStorage();
  
  console.log('💾 Stan zapisany, rezerwacji w localStorage:', window.warehouseReservations.length);
  console.log('📋 Wszystkie rezerwacje:', window.warehouseReservations);
  
  // Przełącz na zakładkę Rezerwacje i odśwież widok
  if (typeof switchWarehouseTab === 'function') {
    console.log('🔄 Przełączam na zakładkę Rezerwacje...');
    switchWarehouseTab('reservations');
  } else if (typeof renderReservations === 'function') {
    console.log('🔄 Odświeżam widok rezerwacji...');
    renderReservations();
  } else {
    console.warn('⚠️ Brak dostępnych funkcji do odświeżenia!');
  }
  
  // Odśwież tabelę zleceń (jeśli jest dostępna w tym scope)
  try {
    if (typeof renderOrderPage === 'function') {
      console.log('🔄 Odświeżam tabelę zleceń...');
      renderOrderPage();
    }
  } catch (e) {
    console.log('ℹ️ renderOrderPage nie jest dostępna w tym kontekście (to normalne)');
  }

  // Zmień kolor przycisku na zielony
  const modal = document.getElementById('custom-modal');
  if (modal) {
    const buttons = modal.querySelectorAll('.btn');
    buttons.forEach(btn => {
      if (btn.textContent.includes('Auto-rezerwuj')) {
        btn.style.background = '#16a34a';
        btn.style.color = '#ffffff';
        btn.style.border = '2px solid #16a34a';
        btn.textContent = '✅ Zarezerwowano';
        btn.disabled = true;
        btn.style.cursor = 'not-allowed';
        btn.style.opacity = '0.8';
      }
    });
  }

  // Pokaż raport
  showReservationReport(results);
}

// Pokaż raport z rezerwacji
function showReservationReport(results) {
  let html = '<div style="font-family:system-ui,-apple-system,sans-serif">';

  // Sekcja: Zarezerwowano
  if (results.reserved.length > 0) {
    html += `
      <div style="margin-bottom:20px">
        <h4 style="color:#16a34a;margin:0 0 10px 0;display:flex;align-items:center;gap:8px">
          <span style="font-size:24px">✅</span>
          <span>Zarezerwowano (${results.reserved.length})</span>
        </h4>
        <div style="background:#f0fdf4;border:1px solid #86efac;border-radius:6px;padding:10px">
          ${results.reserved.map(r => `
            <div style="padding:6px 0;border-bottom:1px solid #86efac40">
              <strong>${r.name}</strong> - ${r.quantity} ${r.unit}
              ${r.orderId ? `<div style="color:#059669;font-size:11px;margin-top:2px;cursor:pointer;text-decoration:underline" onclick="document.getElementById('custom-modal').remove(); window.showMaterialChecklist('${r.orderId}')">📋 Zlecenie: ${r.orderName}</div>` : ''}
            </div>
          `).join('')}
        </div>
      </div>
    `;
  }

  // Sekcja: Niewystarczająca ilość
  if (results.insufficient.length > 0) {
    html += `
      <div style="margin-bottom:20px">
        <h4 style="color:#f59e0b;margin:0 0 10px 0;display:flex;align-items:center;gap:8px">
          <span style="font-size:24px">⚠️</span>
          <span>Niewystarczająca ilość (${results.insufficient.length})</span>
        </h4>
        <div style="background:#fffbeb;border:1px solid #fcd34d;border-radius:6px;padding:10px">
          ${results.insufficient.map(r => `
            <div style="padding:6px 0;border-bottom:1px solid #fcd34d40">
              <strong>${r.name}</strong><br>
              <span style="font-size:13px;color:#92400e">
                Potrzeba: ${r.needed} ${r.unit} | Dostępne: ${r.available} ${r.unit}
              </span>
              ${r.orderId ? `<div style="color:#b45309;font-size:11px;margin-top:2px;cursor:pointer;text-decoration:underline" onclick="document.getElementById('custom-modal').remove(); window.showMaterialChecklist('${r.orderId}')">📋 Zlecenie: ${r.orderName}</div>` : ''}
            </div>
          `).join('')}
        </div>
      </div>
    `;
  }

  // Sekcja: Nie znaleziono
  if (results.notFound.length > 0) {
    html += `
      <div style="margin-bottom:20px">
        <h4 style="color:#dc2626;margin:0 0 10px 0;display:flex;align-items:center;gap:8px">
          <span style="font-size:24px">❌</span>
          <span>Nie znaleziono w magazynie (${results.notFound.length})</span>
        </h4>
        <div style="background:#fef2f2;border:1px solid #fca5a5;border-radius:6px;padding:10px">
          ${results.notFound.map(r => `
            <div style="padding:6px 0;border-bottom:1px solid #fca5a540">
              <strong>${r.name}</strong> - ${r.needed} ${r.unit}
              ${r.orderId ? `<div style="color:#dc2626;font-size:11px;margin-top:2px;cursor:pointer;text-decoration:underline" onclick="document.getElementById('custom-modal').remove(); window.showMaterialChecklist('${r.orderId}')">📋 Zlecenie: ${r.orderName}</div>` : ''}
            </div>
          `).join('')}
        </div>
      </div>
    `;
  }

  html += '</div>';

  showModal('📊 Raport rezerwacji', html, [
    { 
      text: 'OK', 
      action: () => {
        // Odśwież tabelę zleceń po zamknięciu raportu
        if (typeof renderOrderPage === 'function') {
          renderOrderPage();
          console.log('✅ Tabela zleceń odświeżona po zamknięciu raportu');
        }
      } 
    }
  ]);
}

// Auto-rezerwacja dla wszystkich zleceń
function autoReserveForOrders() {
  console.log('⚡ Rozpoczynam auto-rezerwację dla wszystkich zleceń...');
  
  if (!state.orders || state.orders.length === 0) {
    alert('Brak zleceń do przetworzenia');
    return;
  }

  // Zbierz wszystkie zlecenia z procesami i szablonami
  const ordersToProcess = [];
  
  state.orders.forEach(order => {
    if (!order.processId) return;
    
    const process = (state.processes || []).find(p => p.id === order.processId);
    if (!process || !process.materialTemplateId) return;
    
    const template = (window.materialTemplates || []).find(t => t.id === process.materialTemplateId);
    if (!template) return;
    
    ordersToProcess.push({
      order: order,
      process: process,
      template: template
    });
  });

  if (ordersToProcess.length === 0) {
    alert('Nie znaleziono zleceń z przypisanymi szablonami materiałowymi');
    return;
  }

  const globalResults = {
    reserved: [],
    insufficient: [],
    notFound: [],
    ordersProcessed: 0
  };

  // Przetwórz każde zlecenie
  ordersToProcess.forEach(({ order, process, template }) => {
    console.log(`📋 Przetwarzam zlecenie: ${order.name}`);
    
    // Inicjalizuj checklistę jeśli nie istnieje
    if (!order.materialChecklist) {
      order.materialChecklist = template.materials.map((m) => ({
        itemId: m.itemId,
        itemName: m.itemName,
        quantity: m.quantity,
        unit: m.unit,
        checked: false,
        checkedAt: null,
        checkedBy: null
      }));
    }

    // Przetwórz wszystkie materiały z szablonu (nie tylko zaznaczone)
    template.materials.forEach(material => {
      const warehouseItem = (window.warehouseItems || []).find(w => w.id === material.itemId);
      
      if (!warehouseItem) {
        globalResults.notFound.push({
          orderId: order.id,
          orderName: order.name,
          name: material.itemName,
          needed: material.quantity,
          unit: material.unit
        });
        return;
      }

      // Oblicz dostępną ilość
      const existingReservations = (window.warehouseReservations || [])
        .filter(r => r.itemId === material.itemId && r.status === 'active')
        .reduce((sum, r) => sum + r.quantity, 0);
      
      const available = warehouseItem.quantity - existingReservations;

      // Sprawdź czy już jest rezerwacja dla tego zlecenia i materiału
      const existingReservation = (window.warehouseReservations || [])
        .find(r => r.orderId === order.id && r.itemId === material.itemId && r.status === 'active');

      if (existingReservation) {
        console.log(`ℹ️ Rezerwacja już istnieje dla ${material.itemName} w zleceniu ${order.name}`);
        return;
      }

      if (available < material.quantity) {
        globalResults.insufficient.push({
          orderId: order.id,
          orderName: order.name,
          name: material.itemName,
          needed: material.quantity,
          available: available,
          unit: material.unit
        });
        return;
      }

      // Utwórz rezerwację
      const reservation = {
        id: generateId(),
        itemId: material.itemId,
        itemName: material.itemName,
        orderId: order.id,
        orderName: order.name,
        quantity: material.quantity,
        unit: material.unit,
        status: 'active',
        createdAt: Date.now(),
        createdBy: 'Auto-rezerwacja (dla zleceń)'
      };

      if (!window.warehouseReservations) {
        window.warehouseReservations = [];
      }
      window.warehouseReservations.push(reservation);

      globalResults.reserved.push({
        orderId: order.id,
        orderName: order.name,
        name: material.itemName,
        quantity: material.quantity,
        unit: material.unit
      });

      console.log(`✅ Zarezerwowano: ${material.itemName} (${material.quantity} ${material.unit}) dla ${order.name}`);
    });

    globalResults.ordersProcessed++;
  });

  // Zapisz stan magazynu
  saveWarehouseToStorage();
  
  console.log('💾 Stan zapisany, rezerwacji w localStorage:', window.warehouseReservations.length);
  
  // Przełącz na zakładkę Rezerwacje i odśwież widok
  if (typeof switchWarehouseTab === 'function') {
    console.log('🔄 Przełączam na zakładkę Rezerwacje...');
    switchWarehouseTab('reservations');
  } else if (typeof renderReservations === 'function') {
    console.log('🔄 Odświeżam widok rezerwacji...');
    renderReservations();
  }
  
  // Odśwież tabelę zleceń (jeśli jest dostępna)
  try {
    if (typeof renderOrderPage === 'function') {
      renderOrderPage();
    }
  } catch (e) {
    // ignoruj błędy scope
  }

  // Pokaż globalny raport
  showGlobalReservationReport(globalResults, ordersToProcess.length);
}

// Pokaż globalny raport z rezerwacji dla wszystkich zleceń
function showGlobalReservationReport(results, totalOrders) {
  let html = '<div style="font-family:system-ui,-apple-system,sans-serif">';

  html += `
    <div style="background:#f8fafc;border:1px solid #e2e8f0;border-radius:6px;padding:12px;margin-bottom:20px">
      <strong>Przetworzono zleceń:</strong> ${results.ordersProcessed} / ${totalOrders}
    </div>
  `;

  // Sekcja: Zarezerwowano
  if (results.reserved.length > 0) {
    html += `
      <div style="margin-bottom:20px">
        <h4 style="color:#16a34a;margin:0 0 10px 0;display:flex;align-items:center;gap:8px">
          <span style="font-size:24px">✅</span>
          <span>Zarezerwowano (${results.reserved.length})</span>
        </h4>
        <div style="background:#f0fdf4;border:1px solid #86efac;border-radius:6px;padding:10px;max-height:300px;overflow-y:auto">
          ${results.reserved.map(r => `
            <div style="padding:6px 0;border-bottom:1px solid #86efac40;font-size:13px">
              <strong>${r.name}</strong> - ${r.quantity} ${r.unit}
              <div style="color:#059669;font-size:11px">Zlecenie: ${r.orderName}</div>
            </div>
          `).join('')}
        </div>
      </div>
    `;
  }

  // Sekcja: Niewystarczająca ilość
  if (results.insufficient.length > 0) {
    html += `
      <div style="margin-bottom:20px">
        <h4 style="color:#f59e0b;margin:0 0 10px 0;display:flex;align-items:center;gap:8px">
          <span style="font-size:24px">⚠️</span>
          <span>Niewystarczająca ilość (${results.insufficient.length})</span>
        </h4>
        <div style="background:#fffbeb;border:1px solid #fcd34d;border-radius:6px;padding:10px;max-height:300px;overflow-y:auto">
          ${results.insufficient.map(r => `
            <div style="padding:6px 0;border-bottom:1px solid #fcd34d40;font-size:13px">
              <strong>${r.name}</strong><br>
              <span style="font-size:12px;color:#92400e">
                Potrzeba: ${r.needed} ${r.unit} | Dostępne: ${r.available} ${r.unit}
              </span>
              <div style="color:#b45309;font-size:11px">Zlecenie: ${r.orderName}</div>
            </div>
          `).join('')}
        </div>
      </div>
    `;
  }

  // Sekcja: Nie znaleziono
  if (results.notFound.length > 0) {
    html += `
      <div style="margin-bottom:20px">
        <h4 style="color:#dc2626;margin:0 0 10px 0;display:flex;align-items:center;gap:8px">
          <span style="font-size:24px">❌</span>
          <span>Nie znaleziono w magazynie (${results.notFound.length})</span>
        </h4>
        <div style="background:#fef2f2;border:1px solid #fca5a5;border-radius:6px;padding:10px;max-height:300px;overflow-y:auto">
          ${results.notFound.map(r => `
            <div style="padding:6px 0;border-bottom:1px solid #fca5a540;font-size:13px">
              <strong>${r.name}</strong> - ${r.needed} ${r.unit}
              <div style="color:#dc2626;font-size:11px">Zlecenie: ${r.orderName}</div>
            </div>
          `).join('')}
        </div>
      </div>
    `;
  }

  html += '</div>';

  showModal('📊 Raport masowej rezerwacji', html, [
    { text: 'OK', action: () => {
      // Odśwież widok rezerwacji
      if (typeof renderReservations === 'function') {
        renderReservations();
      }
    }}
  ]);
}

// Migracja starych szablonów (naprawa błędnych ID)
function migrateTemplateIds() {
  console.log('🔧 Rozpoczynam migrację szablonów materiałowych...');
  
  if (!window.materialTemplates || window.materialTemplates.length === 0) {
    console.log('ℹ️ Brak szablonów do migracji');
    return { migrated: 0, failed: 0 };
  }

  let migratedCount = 0;
  let failedCount = 0;

  window.materialTemplates.forEach(template => {
    console.log(`📋 Sprawdzam szablon: ${template.name}`);
    
    let templateChanged = false;

    template.materials.forEach((material, idx) => {
      // Sprawdź czy itemId to liczba mała (prawdopodobnie indeks)
      if (typeof material.itemId === 'number' && material.itemId < 1000) {
        // Spróbuj znaleźć materiał po nazwie
        const matchingItem = (window.warehouseItems || []).find(w => w.name === material.itemName);
        
        if (matchingItem) {
          console.log(`✅ Naprawiam: ${material.itemName} (${material.itemId} → ${matchingItem.id})`);
          material.itemId = matchingItem.id;
          templateChanged = true;
        } else {
          console.warn(`⚠️ Nie znaleziono materiału: ${material.itemName}`);
          failedCount++;
        }
      }
    });

    if (templateChanged) {
      migratedCount++;
      template.migratedAt = Date.now();
    }
  });

  if (migratedCount > 0) {
    saveWarehouseToStorage();
    console.log(`✅ Zmigrowano ${migratedCount} szablonów`);
  }

  if (failedCount > 0) {
    console.warn(`⚠️ Nie udało się naprawić ${failedCount} materiałów`);
  }

  return { migrated: migratedCount, failed: failedCount };
}

// Diagnoza szablonów - pokaż szczegóły
function diagnoseShablon() {
  let html = '<div style="font-family:monospace;font-size:12px">';
  
  html += '<h3>📊 Diagnoza szablonów materiałowych</h3>';
  
  html += `<p><strong>Liczba szablonów:</strong> ${(window.materialTemplates || []).length}</p>`;
  html += `<p><strong>Liczba pozycji magazynowych:</strong> ${(window.warehouseItems || []).length}</p><hr>`;
  
  (window.materialTemplates || []).forEach((template, idx) => {
    html += `<div style="margin-bottom:20px;padding:10px;background:#f0f0f0;border-radius:6px">`;
    html += `<h4>Szablon #${idx + 1}: "${template.name}"</h4>`;
    html += `<p><strong>ID szablonu:</strong> ${template.id}</p>`;
    html += `<p><strong>Liczba materiałów:</strong> ${template.materials.length}</p>`;
    
    template.materials.forEach((mat, matIdx) => {
      const warehouseItem = (window.warehouseItems || []).find(w => w.id === mat.itemId);
      const status = warehouseItem ? '✅ OK' : '❌ NIE ZNALEZIONO';
      const color = warehouseItem ? '#16a34a' : '#dc2626';
      
      html += `<div style="margin:5px 0;padding:5px;background:white;border-left:3px solid ${color}">`;
      html += `<strong>${matIdx + 1}. ${mat.itemName}</strong><br>`;
      html += `itemId: <code>${mat.itemId}</code> (typ: ${typeof mat.itemId})<br>`;
      html += `ilość: ${mat.quantity} ${mat.unit}<br>`;
      html += `<span style="color:${color}">${status}</span>`;
      
      if (!warehouseItem && typeof mat.itemId === 'number' && mat.itemId < 100) {
        html += `<br><span style="color:#f59e0b">⚠️ To wygląda na indeks (${mat.itemId}), a nie ID!</span>`;
        
        // Spróbuj znaleźć po nazwie
        const byName = (window.warehouseItems || []).find(w => w.name === mat.itemName);
        if (byName) {
          html += `<br><span style="color:#059669">💡 Znaleziono w magazynie po nazwie! Prawdziwe ID: ${byName.id}</span>`;
        }
      }
      
      html += '</div>';
    });
    
    html += '</div>';
  });
  
  html += '</div>';
  
  showModal('🔍 Diagnoza szablonów', html, [
    { text: 'Zamknij', action: () => {} }
  ]);
}

// Automatyczna migracja przy starcie (jeśli potrzebna)
function autoMigrateIfNeeded() {
  // Sprawdź czy są szablony do migracji
  const needsMigration = (window.materialTemplates || []).some(template => 
    template.materials.some(m => typeof m.itemId === 'number' && m.itemId < 1000 && !template.migratedAt)
  );

  if (needsMigration) {
    console.log('🔍 Wykryto stare szablony, uruchamiam migrację...');
    const result = migrateTemplateIds();
    
    if (result.migrated > 0) {
      alert(`✅ Automatycznie naprawiono ${result.migrated} szablonów materiałowych.\n\nTwoje szablony zostały zaktualizowane i teraz używają poprawnych ID z magazynu.`);
    }
    
    if (result.failed > 0) {
      alert(`⚠️ ${result.failed} materiałów nie udało się naprawić.\n\nNie znaleziono ich w magazynie. Sprawdź czy wszystkie materiały z szablonów istnieją w zakładce "Pozycje".`);
    }
  }
}

// Przypisz funkcje do window
window.showMaterialChecklist = showMaterialChecklist;
window.toggleChecklistItem = toggleChecklistItem;
window.autoReserveFromChecklist = autoReserveFromChecklist;
window.autoReserveForOrders = autoReserveForOrders;
window.migrateTemplateIds = migrateTemplateIds;
window.diagnoseShablon = diagnoseShablon;

// Odśwież wszystkie checklisty zleceń z szablonów
function refreshAllChecklists() {
  if (!confirm('⚠️ To usunie wszystkie stare checklisty i wygeneruje je na nowo z aktualnych szablonów.\n\nKontynuować?')) {
    return;
  }
  
  console.log('♻️ Odświeżam checklisty dla wszystkich zleceń...');
  
  let refreshed = 0;
  let skipped = 0;
  let errors = 0;
  
  (state.orders || []).forEach(order => {
    if (!order.processId) {
      skipped++;
      return;
    }
    
    const process = (state.processes || []).find(p => p.id === order.processId);
    if (!process || !process.materialTemplateId) {
      skipped++;
      return;
    }
    
    const template = (window.materialTemplates || []).find(t => t.id === process.materialTemplateId);
    if (!template) {
      console.warn(`⚠️ Nie znaleziono szablonu ${process.materialTemplateId} dla procesu ${process.name}`);
      errors++;
      return;
    }
    
    // Usuń stary checklist i utwórz nowy
    order.materialChecklist = template.materials.map((m) => ({
      itemId: m.itemId,
      itemName: m.itemName,
      quantity: m.quantity,
      unit: m.unit,
      checked: false,
      checkedAt: null,
      checkedBy: null
    }));
    
    refreshed++;
    console.log(`✅ Odświeżono checklist dla zlecenia: ${order.name}`);
  });
  
  if (refreshed > 0) {
    save();
    alert(`✅ Odświeżono ${refreshed} checklistów\n⏭️ Pominięto: ${skipped}\n❌ Błędy: ${errors}\n\nChecklisty zostały wygenerowane na nowo z aktualnych szablonów.`);
  } else {
    alert(`ℹ️ Nie znaleziono checklistów do odświeżenia.\n⏭️ Pominięto: ${skipped}\n❌ Błędy: ${errors}`);
  }
}

window.refreshAllChecklists = refreshAllChecklists;

// Uruchom auto-migrację po załadowaniu
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    setTimeout(autoMigrateIfNeeded, 1000);
  });
} else {
  setTimeout(autoMigrateIfNeeded, 1000);
}

// Funkcje synchronizacji z aplikacją pracowników
function exportTasksForWorkers() {
  // Przykładowe zadania - w rzeczywistości należy zebrać z systemu MRP
  const sampleTasks = [
    {
      id: 1,
      title: "Cięcie drzwi #1234",
      model: "DREWNO-001",
      quantity: 5,
      unit: "szt",
      deadline: "14:00",
      status: "pending",
      estimatedTime: 120,
      priority: "high",
      assignedTo: "Jan Kowalski"
    },
    {
      id: 2,
      title: "Montaż okuć #1235",
      model: "DREWNO-002",
      quantity: 3,
      unit: "szt",
      deadline: "16:00",
      status: "pending",
      estimatedTime: 90,
      priority: "medium",
      assignedTo: "Anna Nowak"
    },
    {
      id: 3,
      title: "Lakierowanie #1236",
      model: "DREWNO-003",
      quantity: 8,
      unit: "szt",
      deadline: "12:00",
      status: "pending",
      estimatedTime: 180,
      priority: "high",
      assignedTo: "Piotr Wiśniewski"
    }
  ];

  const exportData = {
    exportDate: new Date().toISOString(),
    tasks: sampleTasks,
    version: "1.0",
    system: "Doors Planner Admin"
  };

  const jsonContent = JSON.stringify(exportData, null, 2);
  const blob = new Blob([jsonContent], { type: 'application/json;charset=utf-8;' });
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);
  link.setAttribute('href', url);
  link.setAttribute('download', 'tasks-export.json');
  link.style.visibility = 'hidden';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);

  alert('📤 Plik tasks-export.json został pobrany.\n\nPrzenieś go na urządzenie pracownika i zaimportuj w aplikacji Worker App.');
}

function importWorkerConfirmations() {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.json';

  input.onchange = function(e) {
    const file = e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function(e) {
      try {
        const data = JSON.parse(e.target.result);

        if (data.confirmations && Array.isArray(data.confirmations)) {
          let importedCount = 0;
          let completedCount = 0;

          data.confirmations.forEach(confirmation => {
            console.log('Import potwierdzenia:', confirmation);
            importedCount++;

            if (confirmation.status === 'completed') {
              completedCount++;
            }

            // Tutaj należy zaktualizować zadania w głównym systemie
            // Na razie tylko logujemy
          });

          alert(`✅ Zaimportowano ${importedCount} potwierdzeń zadań\n` +
                `📊 Ukończonych zadań: ${completedCount}\n\n` +
                `Szczegóły w konsoli przeglądarki.`);

        } else if (data.tasks && Array.isArray(data.tasks)) {
          // To może być plik eksportu zadań zamiast potwierdzeń
          alert('To wygląda na plik eksportu zadań, a nie potwierdzeń.\n\n' +
                'Użyj funkcji "Importuj zadania" w aplikacji Worker App.');
        } else {
          alert('❌ Nieprawidłowy format pliku.\n\n' +
                'Oczekiwany format: {"confirmations": [...]}');
        }
      } catch (error) {
        alert('❌ Błąd podczas parsowania pliku:\n' + error.message);
      }
    };

    reader.readAsText(file);
  };

  input.click();
}

function exportWarehouseToCSV() {
  if (!window.warehouseItems || window.warehouseItems.length === 0) {
    alert('Brak pozycji do eksportu');
    return;
  }

  const csvContent = 'Nazwa,Ilość,Jednostka,Cena,Stan minimalny\n' +
    window.warehouseItems.map(item =>
      `"${item.name}",${item.quantity},"${item.unit}",${item.price},${item.minStock || 0}`
    ).join('\n');

  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);
  link.setAttribute('href', url);
  link.setAttribute('download', 'magazyn.csv');
  link.style.visibility = 'hidden';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}

function toggleOrderFilter() {
  window.showOnlyLowStock = !window.showOnlyLowStock;
  const button = document.querySelector('button[onclick="toggleOrderFilter()"]');
  if (button) {
    button.textContent = window.showOnlyLowStock ? '🔴 Do zamówienia (WŁĄCZONE)' : '🔴 Do zamówienia';
    button.className = window.showOnlyLowStock ? 'btn red' : 'btn orange';
  }
  renderWarehouse();
}

function renderWarehouse() {
  const list = document.getElementById('wh-list');
  if (!list) return;
  
  const searchTerm = document.getElementById('wh-search')?.value.toLowerCase() || '';
  let filteredItems = window.warehouseItems.filter(item => 
    item.name.toLowerCase().includes(searchTerm)
  );
  
  // Dodatkowe filtrowanie dla pozycji do zamówienia
  if (window.showOnlyLowStock) {
    filteredItems = filteredItems.filter(item => 
      item.minStock && item.quantity <= item.minStock
    );
  }
  
  if (filteredItems.length === 0) {
    const message = window.showOnlyLowStock 
      ? 'Brak pozycji do zamówienia (wszystkie mają wystarczający stan).'
      : 'Brak pozycji spełniających kryteria wyszukiwania.';
    list.innerHTML = `<div style="text-align:center;padding:40px;color:#999">${message}</div>`;
    return;
  }
  
  // TABELA zamiast kart
  const tableHtml = `
    <table style="width:100%;border-collapse:collapse;background:#2c3e50;box-shadow:0 1px 3px rgba(0,0,0,0.3)">
      <thead>
        <tr style="background:#34495e;border-bottom:2px solid #1a252f">
          <th style="padding:12px;text-align:left;font-weight:700;font-size:14px;color:#ffffff !important">Nazwa</th>
          <th style="padding:12px;text-align:center;font-weight:700;font-size:14px;color:#ffffff !important;width:100px">Ilość</th>
          <th style="padding:12px;text-align:center;font-weight:700;font-size:14px;color:#ffffff !important;width:80px">Jedn.</th>
          <th style="padding:12px;text-align:right;font-weight:700;font-size:14px;color:#ffffff !important;width:100px">Cena (zł)</th>
          <th style="padding:12px;text-align:center;font-weight:700;font-size:14px;color:#ffffff !important;width:80px">Min</th>
          <th style="padding:12px;text-align:left;font-weight:700;font-size:14px;color:#ffffff !important;width:180px">📍 Lokalizacja</th>
          <th style="padding:12px;text-align:center;font-weight:700;font-size:14px;color:#ffffff !important;width:180px">Akcje</th>
        </tr>
      </thead>
      <tbody>
        ${filteredItems.map((item, index) => {
          const isLowStock = item.minStock && item.quantity <= item.minStock;
          const rowStyle = isLowStock ? 'background:#c0392b' : (index % 2 === 0 ? 'background:#34495e' : 'background:#2c3e50');
          
          // Lokalizacja
          let locationStr = '-';
          if (item.location && (item.location.shelf || item.location.rack || item.location.sector)) {
            const parts = [];
            if (item.location.shelf) parts.push(`R:${item.location.shelf}`);
            if (item.location.rack) parts.push(`P:${item.location.rack}`);
            if (item.location.sector) parts.push(`S:${item.location.sector}`);
            locationStr = parts.join(' • ');
          }
          
          return `
            <tr style="${rowStyle};border-bottom:1px solid #1a252f">
              <td style="padding:12px">
                <div style="font-weight:600;font-size:15px;color:#ffffff !important">${item.name}</div>
                ${isLowStock ? '<div style="font-size:12px;color:#ffeb3b !important;font-weight:700;margin-top:2px">⚠️ DO ZAMÓWIENIA</div>' : ''}
              </td>
              <td style="padding:12px;text-align:center;font-weight:700;font-size:15px;color:${isLowStock ? '#ffeb3b' : '#ffffff'} !important">${item.quantity}</td>
              <td style="padding:12px;text-align:center;font-size:14px;color:#ffffff !important">${item.unit}</td>
              <td style="padding:12px;text-align:right;font-weight:600;font-size:14px;color:#ffffff !important">${item.price.toFixed(2)}</td>
              <td style="padding:12px;text-align:center;font-size:14px;color:#ffffff !important">${item.minStock || '-'}</td>
              <td style="padding:12px;font-size:14px;color:#ffffff !important">${locationStr}</td>
              <td style="padding:12px;text-align:center">
                <div style="display:flex;gap:4px;justify-content:center">
                  <button class="btn small" onclick="editWarehouseItem(${window.warehouseItems.indexOf(item)})" style="padding:6px 12px;font-size:13px">Edytuj</button>
                  <button class="btn red small" onclick="deleteWarehouseItem(${window.warehouseItems.indexOf(item)})" style="padding:6px 12px;font-size:13px">Usuń</button>
                </div>
              </td>
            </tr>
          `;
        }).join('')}
      </tbody>
    </table>
  `;
  
  list.innerHTML = tableHtml;
}

// Dodaj event listener po załadowaniu DOM
document.addEventListener('DOMContentLoaded', () => {
  loadWarehouseFromStorage();
  window.showOnlyLowStock = false; // Inicjalizacja filtra pozycji do zamówienia
  
  const addBtn = document.getElementById('wh-add');
  if (addBtn) {
    addBtn.addEventListener('click', addWarehouseItem);
  }
  
  const searchInput = document.getElementById('wh-search');
  if (searchInput) {
    searchInput.addEventListener('input', renderWarehouse);
  }
});

// Automatyczne renderowanie przy wejściu do zakładki
document.addEventListener('click', (e) => {
  if (e.target.matches('[data-nav="wh"]')) {
    setTimeout(renderWarehouse, 100);
  }
});

// Funkcja do generowania testowych zamówień z terminami
function generateDeadlineTestOrders() {
  const today = new Date();
  const testOrders = [
    {
      id: 'test-order-1',
      name: 'Drzwi wejściowe dąb',
      client: 'Firma ABC Sp. z o.o.',
      model: 'Dąb Classic',
      quantity: 5,
      startDate: today.toISOString().slice(0, 10),
      endDate: new Date(today.getTime() + 2 * 24 * 60 * 60 * 1000).toISOString().slice(0, 10), // Za 2 dni
      processId: 'proc1'
    },
    {
      id: 'test-order-2',
      name: 'Drzwi wewnętrzne sosna',
      client: 'Dom prywatny Kowalski',
      model: 'Sosna Light',
      quantity: 3,
      startDate: today.toISOString().slice(0, 10),
      endDate: new Date(today.getTime() + 5 * 24 * 60 * 60 * 1000).toISOString().slice(0, 10), // Za 5 dni
      processId: 'proc2'
    },
    {
      id: 'test-order-3',
      name: 'Drzwi balkonowe',
      client: 'Blok mieszkalny',
      model: 'Balkon Plus',
      quantity: 8,
      startDate: today.toISOString().slice(0, 10),
      endDate: new Date(today.getTime() + 8 * 24 * 60 * 60 * 1000).toISOString().slice(0, 10), // Za 8 dni
      processId: 'proc1'
    },
    {
      id: 'test-order-4',
      name: 'Drzwi techniczne',
      client: 'Przedsiębiorstwo XYZ',
      model: 'Techniczne Pro',
      quantity: 2,
      startDate: today.toISOString().slice(0, 10),
      endDate: new Date(today.getTime() - 1 * 24 * 60 * 60 * 1000).toISOString().slice(0, 10), // Wczoraj (przekroczony termin)
      processId: 'proc2'
    }
  ];

  // Dodaj zamówienia tylko jeśli nie istnieją
  testOrders.forEach(order => {
    if (!(state.orders || []).some(o => o.id === order.id)) {
      state.orders = state.orders || [];
      state.orders.push(order);
    }
  });

  save();
  renderOrderPage();
  renderDash(window.state || state);
  renderGantt();

  alert('✅ Dodano testowe zamówienia z różnymi terminami!\n\nSprawdź sekcję powiadomień w dashboardzie.');
}

// Dodaj event listener dla przycisku generowania testowych zamówień
document.addEventListener('DOMContentLoaded', () => {
  const genDeadlineBtn = document.getElementById('gen-deadline-test');
  if (genDeadlineBtn) {
    genDeadlineBtn.addEventListener('click', generateDeadlineTestOrders);
  }
  
  // Wykryj port i pokaż ostrzeżenie o osobnych danych
  try {
    const currentPort = window.location.port;
    const banner = document.getElementById('port-warning-banner');
    const portSpan = document.getElementById('current-port');
    const detailSpan = document.getElementById('port-warning-detail');
    const storageKey = window.storeKey || 'door_v50_state';

    if (banner && portSpan && detailSpan) {
      const friendlyPort = currentPort ? currentPort : 'brak (plik lokalny)';
      portSpan.textContent = friendlyPort;

      const storedState = localStorage.getItem(storageKey);
      let dataCount = 0;
      if (storedState) {
        try {
          const parsed = JSON.parse(storedState);
          dataCount = Array.isArray(parsed?.orders) ? parsed.orders.length : 0;
        } catch(parseErr) {
          console.warn('Błąd parsowania danych magazynu dla banera portu:', parseErr);
        }
      }

      let detailHtml = '';

      if (!currentPort) {
        detailHtml = 'Otwierasz plik lokalny (<strong>brak portu</strong>) — dane mogą się nie synchronizować. <strong>Uruchom plik przez serwer (np. Five Server), aby używać tych samych danych co reszta zespołu.</strong>';
      } else if (currentPort === '5500') {
        detailHtml = 'Aplikacja działa na domyślnym porcie <strong>5500</strong>. To osobny magazyn danych od innych portów — upewnij się, że wszyscy korzystają z tego samego portu.';
      } else {
        detailHtml = `Aplikacja na porcie <strong>${friendlyPort}</strong> ma <strong>osobne dane</strong> niż instancja na porcie 5500.`;
      }

      if (dataCount === 0) {
        detailHtml += ' <strong style="background:rgba(255,255,255,0.2);padding:2px 8px;border-radius:3px">⚠️ Brak zleceń — sprawdź, czy to właściwy port lub zaimportuj backup.</strong>';
      }

      detailSpan.innerHTML = detailHtml;
      banner.style.display = 'block';
      console.log('⚠️ OSTRZEŻENIE: Port', friendlyPort, '| Zleceń:', dataCount);
    }
  } catch(e) {
    console.warn('Błąd wykrywania portu:', e);
  }
});
</script>
</body>
</html>


